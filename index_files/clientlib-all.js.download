/*! jQuery v1.12.2 | (c) jQuery Foundation | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=a.document,e=c.slice,f=c.concat,g=c.push,h=c.indexOf,i={},j=i.toString,k=i.hasOwnProperty,l={},m="1.12.2",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return e.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:e.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a){return n.each(this,a)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(e.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:g,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray||function(a){return"array"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){var b=a&&a.toString();return!n.isArray(a)&&b-parseFloat(b)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!k.call(a,"constructor")&&!k.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(!l.ownFirst)for(b in a)return k.call(a,b);for(b in a);return void 0===b||k.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?i[j.call(a)]||"object":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(s(a)){for(c=a.length;c>d;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):g.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(h)return h.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,g=0,h=[];if(s(a))for(d=a.length;d>g;g++)e=b(a[g],g,c),null!=e&&h.push(e);else for(g in a)e=b(a[g],g,c),null!=e&&h.push(e);return f.apply([],h)},guid:1,proxy:function(a,b){var c,d,f;return"string"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=e.call(arguments,2),d=function(){return a.apply(b||this,c.concat(e.call(arguments)))},d.guid=a.guid=a.guid||n.guid++,d):void 0},now:function(){return+new Date},support:l}),"function"==typeof Symbol&&(n.fn[Symbol.iterator]=c[Symbol.iterator]),n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){i["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=!!a&&"length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ga(),z=ga(),A=ga(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+M+"))|)"+L+"*\\]",O=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+N+")*)|.*)\\)|)",P=new RegExp(L+"+","g"),Q=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),R=new RegExp("^"+L+"*,"+L+"*"),S=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),T=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),U=new RegExp(O),V=new RegExp("^"+M+"$"),W={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M+"|[*])"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+O),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},X=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,$=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,_=/[+~]/,aa=/'|\\/g,ba=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),ca=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},da=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(ea){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fa(a,b,d,e){var f,h,j,k,l,o,r,s,w=b&&b.ownerDocument,x=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==x&&9!==x&&11!==x)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==x&&(o=$.exec(a)))if(f=o[1]){if(9===x){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(w&&(j=w.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(o[2])return H.apply(d,b.getElementsByTagName(a)),d;if((f=o[3])&&c.getElementsByClassName&&b.getElementsByClassName)return H.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==x)w=b,s=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(aa,"\\$&"):b.setAttribute("id",k=u),r=g(a),h=r.length,l=V.test(k)?"#"+k:"[id='"+k+"']";while(h--)r[h]=l+" "+qa(r[h]);s=r.join(","),w=_.test(a)&&oa(b.parentNode)||b}if(s)try{return H.apply(d,w.querySelectorAll(s)),d}catch(y){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(Q,"$1"),b,d,e)}function ga(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ha(a){return a[u]=!0,a}function ia(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ja(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function ka(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function la(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function na(a){return ha(function(b){return b=+b,ha(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function oa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=fa.support={},f=fa.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fa.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ia(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ia(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Z.test(n.getElementsByClassName),c.getById=ia(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return"undefined"!=typeof b.getElementsByClassName&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=Z.test(n.querySelectorAll))&&(ia(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ia(function(a){var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Z.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ia(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",O)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Z.test(o.compareDocumentPosition),t=b||Z.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return ka(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?ka(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},fa.matches=function(a,b){return fa(a,null,null,b)},fa.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(T,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fa(b,n,null,[a]).length>0},fa.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fa.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fa.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fa.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fa.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fa.selectors={cacheLength:50,createPseudo:ha,match:W,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ba,ca),a[3]=(a[3]||a[4]||a[5]||"").replace(ba,ca),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fa.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fa.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return W.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&U.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ba,ca).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fa.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(P," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fa.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ha(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ha(function(a){var b=[],c=[],d=h(a.replace(Q,"$1"));return d[u]?ha(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ha(function(a){return function(b){return fa(a,b).length>0}}),contains:ha(function(a){return a=a.replace(ba,ca),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ha(function(a){return V.test(a||"")||fa.error("unsupported lang: "+a),a=a.replace(ba,ca).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Y.test(a.nodeName)},input:function(a){return X.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:na(function(){return[0]}),last:na(function(a,b){return[b-1]}),eq:na(function(a,b,c){return[0>c?c+b:c]}),even:na(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:na(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:na(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:na(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=la(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=ma(b);function pa(){}pa.prototype=d.filters=d.pseudos,d.setFilters=new pa,g=fa.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=R.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=S.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(Q," ")}),h=h.slice(c.length));for(g in d.filter)!(e=W[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fa.error(a):z(a,i).slice(0)};function qa(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function ra(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j,k=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(j=b[u]||(b[u]={}),i=j[b.uniqueID]||(j[b.uniqueID]={}),(h=i[d])&&h[0]===w&&h[1]===f)return k[2]=h[2];if(i[d]=k,k[2]=a(b,c,g))return!0}}}function sa(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ta(a,b,c){for(var d=0,e=b.length;e>d;d++)fa(a,b[d],c);return c}function ua(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function va(a,b,c,d,e,f){return d&&!d[u]&&(d=va(d)),e&&!e[u]&&(e=va(e,f)),ha(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ta(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ua(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ua(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ua(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function wa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ra(function(a){return a===b},h,!0),l=ra(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[ra(sa(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return va(i>1&&sa(m),i>1&&qa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(Q,"$1"),c,e>i&&wa(a.slice(i,e)),f>e&&wa(a=a.slice(e)),f>e&&qa(a))}m.push(c)}return sa(m)}function xa(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=F.call(i));u=ua(u)}H.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&fa.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ha(f):f}return h=fa.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xa(e,d)),f.selector=a}return f},i=fa.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ba,ca),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=W.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ba,ca),_.test(j[0].type)&&oa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qa(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,!b||_.test(a)&&oa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ia(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ia(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ja("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ia(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ja("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ia(function(a){return null==a.getAttribute("disabled")})||ja(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fa}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.uniqueSort=n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},v=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},w=n.expr.match.needsContext,x=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,y=/^.[^:#\[\.,]*$/;function z(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(y.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return n.inArray(a,b)>-1!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;e>b;b++)if(n.contains(d[b],this))return!0}));for(b=0;e>b;b++)n.find(a,d[b],c);return c=this.pushStack(e>1?n.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(z(this,a||[],!1))},not:function(a){return this.pushStack(z(this,a||[],!0))},is:function(a){return!!z(this,"string"==typeof a&&w.test(a)?n(a):a||[],!1).length}});var A,B=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=n.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||A,"string"==typeof a){if(e="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:B.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),x.test(e[1])&&n.isPlainObject(b))for(e in b)n.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}if(f=d.getElementById(e[2]),f&&f.parentNode){if(f.id!==e[2])return A.find(a);this.length=1,this[0]=f}return this.context=d,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof c.ready?c.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};C.prototype=n.fn,A=n(d);var D=/^(?:parents|prev(?:Until|All))/,E={children:!0,contents:!0,next:!0,prev:!0};n.fn.extend({has:function(a){var b,c=n(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(n.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=w.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?n.inArray(this[0],n(a)):n.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.uniqueSort(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function F(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return u(a,"parentNode")},parentsUntil:function(a,b,c){return u(a,"parentNode",c)},next:function(a){return F(a,"nextSibling")},prev:function(a){return F(a,"previousSibling")},nextAll:function(a){return u(a,"nextSibling")},prevAll:function(a){return u(a,"previousSibling")},nextUntil:function(a,b,c){return u(a,"nextSibling",c)},prevUntil:function(a,b,c){return u(a,"previousSibling",c)},siblings:function(a){return v((a.parentNode||{}).firstChild,a)},children:function(a){return v(a.firstChild)},contents:function(a){return n.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(E[a]||(e=n.uniqueSort(e)),D.test(a)&&(e=e.reverse())),this.pushStack(e)}});var G=/\S+/g;function H(a){var b={};return n.each(a.match(G)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?H(a):n.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){n.each(b,function(b,c){n.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==n.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return n.each(arguments,function(a,b){var c;while((c=n.inArray(b,f,c))>-1)f.splice(c,1),h>=c&&h--}),this},has:function(a){return a?n.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=!0,c||j.disable(),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().progress(c.notify).done(c.resolve).fail(c.reject):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=e.call(arguments),d=c.length,f=1!==d||a&&n.isFunction(a.promise)?d:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(d){b[a]=this,c[a]=arguments.length>1?e.call(arguments):d,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(d>1)for(i=new Array(d),j=new Array(d),k=new Array(d);d>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().progress(h(b,j,i)).done(h(b,k,c)).fail(g.reject):--f;return f||g.resolveWith(k,c),g.promise()}});var I;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(I.resolveWith(d,[n]),n.fn.triggerHandler&&(n(d).triggerHandler("ready"),n(d).off("ready"))))}});function J(){d.addEventListener?(d.removeEventListener("DOMContentLoaded",K),a.removeEventListener("load",K)):(d.detachEvent("onreadystatechange",K),a.detachEvent("onload",K))}function K(){(d.addEventListener||"load"===a.event.type||"complete"===d.readyState)&&(J(),n.ready())}n.ready.promise=function(b){if(!I)if(I=n.Deferred(),"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll)a.setTimeout(n.ready);else if(d.addEventListener)d.addEventListener("DOMContentLoaded",K),a.addEventListener("load",K);else{d.attachEvent("onreadystatechange",K),a.attachEvent("onload",K);var c=!1;try{c=null==a.frameElement&&d.documentElement}catch(e){}c&&c.doScroll&&!function f(){if(!n.isReady){try{c.doScroll("left")}catch(b){return a.setTimeout(f,50)}J(),n.ready()}}()}return I.promise(b)},n.ready.promise();var L;for(L in n(l))break;l.ownFirst="0"===L,l.inlineBlockNeedsLayout=!1,n(function(){var a,b,c,e;c=d.getElementsByTagName("body")[0],c&&c.style&&(b=d.createElement("div"),e=d.createElement("div"),e.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(e).appendChild(b),"undefined"!=typeof b.style.zoom&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",l.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(e))}),function(){var a=d.createElement("div");l.deleteExpando=!0;try{delete a.test}catch(b){l.deleteExpando=!1}a=null}();var M=function(a){var b=n.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b},N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(O,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}n.data(a,b,c)}else c=void 0;
}return c}function Q(a){var b;for(b in a)if(("data"!==b||!n.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;return!0}function R(a,b,d,e){if(M(a)){var f,g,h=n.expando,i=a.nodeType,j=i?n.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||n.guid++:h),j[k]||(j[k]=i?{}:{toJSON:n.noop}),"object"!=typeof b&&"function"!=typeof b||(e?j[k]=n.extend(j[k],b):j[k].data=n.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[n.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[n.camelCase(b)])):f=g,f}}function S(a,b,c){if(M(a)){var d,e,f=a.nodeType,g=f?n.cache:a,h=f?a[n.expando]:n.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){n.isArray(b)?b=b.concat(n.map(b,n.camelCase)):b in d?b=[b]:(b=n.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!Q(d):!n.isEmptyObject(d))return}(c||(delete g[h].data,Q(g[h])))&&(f?n.cleanData([a],!0):l.deleteExpando||g!=g.window?delete g[h]:g[h]=void 0)}}}n.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?n.cache[a[n.expando]]:a[n.expando],!!a&&!Q(a)},data:function(a,b,c){return R(a,b,c)},removeData:function(a,b){return S(a,b)},_data:function(a,b,c){return R(a,b,c,!0)},_removeData:function(a,b){return S(a,b,!0)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=n.data(f),1===f.nodeType&&!n._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));n._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){n.data(this,a)}):arguments.length>1?this.each(function(){n.data(this,a,b)}):f?P(f,a,n.data(f,a)):void 0},removeData:function(a){return this.each(function(){n.removeData(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=n._data(a,b),c&&(!d||n.isArray(c)?d=n._data(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return n._data(a,c)||n._data(a,c,{empty:n.Callbacks("once memory").add(function(){n._removeData(a,b+"queue"),n._removeData(a,c)})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=n._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}}),function(){var a;l.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,e;return c=d.getElementsByTagName("body")[0],c&&c.style?(b=d.createElement("div"),e=d.createElement("div"),e.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(e).appendChild(b),"undefined"!=typeof b.style.zoom&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(d.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(e),a):void 0}}();var T=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,U=new RegExp("^(?:([+-])=|)("+T+")([a-z%]*)$","i"),V=["Top","Right","Bottom","Left"],W=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)};function X(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return n.css(a,b,"")},i=h(),j=c&&c[3]||(n.cssNumber[b]?"":"px"),k=(n.cssNumber[b]||"px"!==j&&+i)&&U.exec(n.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,n.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var Y=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)Y(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},Z=/^(?:checkbox|radio)$/i,$=/<([\w:-]+)/,_=/^$|\/(?:java|ecma)script/i,aa=/^\s+/,ba="abbr|article|aside|audio|bdi|canvas|data|datalist|details|dialog|figcaption|figure|footer|header|hgroup|main|mark|meter|nav|output|picture|progress|section|summary|template|time|video";function ca(a){var b=ba.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}!function(){var a=d.createElement("div"),b=d.createDocumentFragment(),c=d.createElement("input");a.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",l.leadingWhitespace=3===a.firstChild.nodeType,l.tbody=!a.getElementsByTagName("tbody").length,l.htmlSerialize=!!a.getElementsByTagName("link").length,l.html5Clone="<:nav></:nav>"!==d.createElement("nav").cloneNode(!0).outerHTML,c.type="checkbox",c.checked=!0,b.appendChild(c),l.appendChecked=c.checked,a.innerHTML="<textarea>x</textarea>",l.noCloneChecked=!!a.cloneNode(!0).lastChild.defaultValue,b.appendChild(a),c=d.createElement("input"),c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),a.appendChild(c),l.checkClone=a.cloneNode(!0).cloneNode(!0).lastChild.checked,l.noCloneEvent=!!a.addEventListener,a[n.expando]=1,l.attributes=!a.getAttribute(n.expando)}();var da={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:l.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]};da.optgroup=da.option,da.tbody=da.tfoot=da.colgroup=da.caption=da.thead,da.th=da.td;function ea(a,b){var c,d,e=0,f="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||n.nodeName(d,b)?f.push(d):n.merge(f,ea(d,b));return void 0===b||b&&n.nodeName(a,b)?n.merge([a],f):f}function fa(a,b){for(var c,d=0;null!=(c=a[d]);d++)n._data(c,"globalEval",!b||n._data(b[d],"globalEval"))}var ga=/<|&#?\w+;/,ha=/<tbody/i;function ia(a){Z.test(a.type)&&(a.defaultChecked=a.checked)}function ja(a,b,c,d,e){for(var f,g,h,i,j,k,m,o=a.length,p=ca(b),q=[],r=0;o>r;r++)if(g=a[r],g||0===g)if("object"===n.type(g))n.merge(q,g.nodeType?[g]:g);else if(ga.test(g)){i=i||p.appendChild(b.createElement("div")),j=($.exec(g)||["",""])[1].toLowerCase(),m=da[j]||da._default,i.innerHTML=m[1]+n.htmlPrefilter(g)+m[2],f=m[0];while(f--)i=i.lastChild;if(!l.leadingWhitespace&&aa.test(g)&&q.push(b.createTextNode(aa.exec(g)[0])),!l.tbody){g="table"!==j||ha.test(g)?"<table>"!==m[1]||ha.test(g)?0:i:i.firstChild,f=g&&g.childNodes.length;while(f--)n.nodeName(k=g.childNodes[f],"tbody")&&!k.childNodes.length&&g.removeChild(k)}n.merge(q,i.childNodes),i.textContent="";while(i.firstChild)i.removeChild(i.firstChild);i=p.lastChild}else q.push(b.createTextNode(g));i&&p.removeChild(i),l.appendChecked||n.grep(ea(q,"input"),ia),r=0;while(g=q[r++])if(d&&n.inArray(g,d)>-1)e&&e.push(g);else if(h=n.contains(g.ownerDocument,g),i=ea(p.appendChild(g),"script"),h&&fa(i),c){f=0;while(g=i[f++])_.test(g.type||"")&&c.push(g)}return i=null,p}!function(){var b,c,e=d.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(l[b]=c in a)||(e.setAttribute(c,"t"),l[b]=e.attributes[c].expando===!1);e=null}();var ka=/^(?:input|select|textarea)$/i,la=/^key/,ma=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,na=/^(?:focusinfocus|focusoutblur)$/,oa=/^([^.]*)(?:\.(.+)|)/;function pa(){return!0}function qa(){return!1}function ra(){try{return d.activeElement}catch(a){}}function sa(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)sa(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=qa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return n().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=n.guid++)),a.each(function(){n.event.add(this,b,e,d,c)})}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=n.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return"undefined"==typeof n||a&&n.event.triggered===a.type?void 0:n.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(G)||[""],h=b.length;while(h--)f=oa.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=n.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=n.event.special[o]||{},l=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},i),(m=g[o])||(m=g[o]=[],m.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,l):m.push(l),n.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n.hasData(a)&&n._data(a);if(r&&(k=r.events)){b=(b||"").match(G)||[""],j=b.length;while(j--)if(h=oa.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=m.length;while(f--)g=m[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(m.splice(f,1),g.selector&&m.delegateCount--,l.remove&&l.remove.call(a,g));i&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(k)&&(delete r.handle,n._removeData(a,"events"))}},trigger:function(b,c,e,f){var g,h,i,j,l,m,o,p=[e||d],q=k.call(b,"type")?b.type:b,r=k.call(b,"namespace")?b.namespace.split("."):[];if(i=m=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!na.test(q+n.event.triggered)&&(q.indexOf(".")>-1&&(r=q.split("."),q=r.shift(),r.sort()),h=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=r.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:n.makeArray(c,[b]),l=n.event.special[q]||{},f||!l.trigger||l.trigger.apply(e,c)!==!1)){if(!f&&!l.noBubble&&!n.isWindow(e)){for(j=l.delegateType||q,na.test(j+q)||(i=i.parentNode);i;i=i.parentNode)p.push(i),m=i;m===(e.ownerDocument||d)&&p.push(m.defaultView||m.parentWindow||a)}o=0;while((i=p[o++])&&!b.isPropagationStopped())b.type=o>1?j:l.bindType||q,g=(n._data(i,"events")||{})[b.type]&&n._data(i,"handle"),g&&g.apply(i,c),g=h&&i[h],g&&g.apply&&M(i)&&(b.result=g.apply(i,c),b.result===!1&&b.preventDefault());if(b.type=q,!f&&!b.isDefaultPrevented()&&(!l._default||l._default.apply(p.pop(),c)===!1)&&M(e)&&h&&e[q]&&!n.isWindow(e)){m=e[h],m&&(e[h]=null),n.event.triggered=q;try{e[q]()}catch(s){}n.event.triggered=void 0,m&&(e[h]=m)}return b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,d,f,g,h=[],i=e.call(arguments),j=(n._data(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())a.rnamespace&&!a.rnamespace.test(g.namespace)||(a.handleObj=g,a.data=g.data,d=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==d&&(a.result=d)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&("click"!==a.type||isNaN(a.button)||a.button<1))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>-1:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[n.expando])return a;var b,c,e,f=a.type,g=a,h=this.fixHooks[f];h||(this.fixHooks[f]=h=ma.test(f)?this.mouseHooks:la.test(f)?this.keyHooks:{}),e=h.props?this.props.concat(h.props):this.props,a=new n.Event(g),b=e.length;while(b--)c=e[b],a[c]=g[c];return a.target||(a.target=g.srcElement||d),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,h.filter?h.filter(a,g):a},props:"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,e,f,g=b.button,h=b.fromElement;return null==a.pageX&&null!=b.clientX&&(e=a.target.ownerDocument||d,f=e.documentElement,c=e.body,a.pageX=b.clientX+(f&&f.scrollLeft||c&&c.scrollLeft||0)-(f&&f.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(f&&f.scrollTop||c&&c.scrollTop||0)-(f&&f.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&h&&(a.relatedTarget=h===a.target?b.toElement:h),a.which||void 0===g||(a.which=1&g?1:2&g?3:4&g?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ra()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ra()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return n.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c){var d=n.extend(new n.Event,c,{type:a,isSimulated:!0});n.event.trigger(d,null,b),d.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=d.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)}:function(a,b,c){var d="on"+b;a.detachEvent&&("undefined"==typeof a[d]&&(a[d]=null),a.detachEvent(d,c))},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?pa:qa):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={constructor:n.Event,isDefaultPrevented:qa,isPropagationStopped:qa,isImmediatePropagationStopped:qa,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=pa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=pa,a&&!this.isSimulated&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=pa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||n.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),l.submit||(n.event.special.submit={setup:function(){return n.nodeName(this,"form")?!1:void n.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=n.nodeName(b,"input")||n.nodeName(b,"button")?n.prop(b,"form"):void 0;c&&!n._data(c,"submit")&&(n.event.add(c,"submit._submit",function(a){a._submitBubble=!0}),n._data(c,"submit",!0))})},postDispatch:function(a){a._submitBubble&&(delete a._submitBubble,this.parentNode&&!a.isTrigger&&n.event.simulate("submit",this.parentNode,a))},teardown:function(){return n.nodeName(this,"form")?!1:void n.event.remove(this,"._submit")}}),l.change||(n.event.special.change={setup:function(){return ka.test(this.nodeName)?("checkbox"!==this.type&&"radio"!==this.type||(n.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._justChanged=!0)}),n.event.add(this,"click._change",function(a){this._justChanged&&!a.isTrigger&&(this._justChanged=!1),n.event.simulate("change",this,a)})),!1):void n.event.add(this,"beforeactivate._change",function(a){var b=a.target;ka.test(b.nodeName)&&!n._data(b,"change")&&(n.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||n.event.simulate("change",this.parentNode,a)}),n._data(b,"change",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return n.event.remove(this,"._change"),!ka.test(this.nodeName)}}),l.focusin||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a))};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=n._data(d,b);e||d.addEventListener(a,c,!0),n._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=n._data(d,b)-1;e?n._data(d,b,e):(d.removeEventListener(a,c,!0),n._removeData(d,b))}}}),n.fn.extend({on:function(a,b,c,d){return sa(this,a,b,c,d)},one:function(a,b,c,d){return sa(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=qa),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ta=/ jQuery\d+="(?:null|\d+)"/g,ua=new RegExp("<(?:"+ba+")[\\s/>]","i"),va=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,wa=/<script|<style|<link/i,xa=/checked\s*(?:[^=]|=\s*.checked.)/i,ya=/^true\/(.*)/,za=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,Aa=ca(d),Ba=Aa.appendChild(d.createElement("div"));function Ca(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function Da(a){return a.type=(null!==n.find.attr(a,"type"))+"/"+a.type,a}function Ea(a){var b=ya.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Fa(a,b){if(1===b.nodeType&&n.hasData(a)){var c,d,e,f=n._data(a),g=n._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)n.event.add(b,c,h[c][d])}g.data&&(g.data=n.extend({},g.data))}}function Ga(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!l.noCloneEvent&&b[n.expando]){e=n._data(b);for(d in e.events)n.removeEvent(b,d,e.handle);b.removeAttribute(n.expando)}"script"===c&&b.text!==a.text?(Da(b).text=a.text,Ea(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),l.html5Clone&&a.innerHTML&&!n.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&Z.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}}function Ha(a,b,c,d){b=f.apply([],b);var e,g,h,i,j,k,m=0,o=a.length,p=o-1,q=b[0],r=n.isFunction(q);if(r||o>1&&"string"==typeof q&&!l.checkClone&&xa.test(q))return a.each(function(e){var f=a.eq(e);r&&(b[0]=q.call(this,e,f.html())),Ha(f,b,c,d)});if(o&&(k=ja(b,a[0].ownerDocument,!1,a,d),e=k.firstChild,1===k.childNodes.length&&(k=e),e||d)){for(i=n.map(ea(k,"script"),Da),h=i.length;o>m;m++)g=k,m!==p&&(g=n.clone(g,!0,!0),h&&n.merge(i,ea(g,"script"))),c.call(a[m],g,m);if(h)for(j=i[i.length-1].ownerDocument,n.map(i,Ea),m=0;h>m;m++)g=i[m],_.test(g.type||"")&&!n._data(g,"globalEval")&&n.contains(j,g)&&(g.src?n._evalUrl&&n._evalUrl(g.src):n.globalEval((g.text||g.textContent||g.innerHTML||"").replace(za,"")));k=e=null}return a}function Ia(a,b,c){for(var d,e=b?n.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||n.cleanData(ea(d)),d.parentNode&&(c&&n.contains(d.ownerDocument,d)&&fa(ea(d,"script")),d.parentNode.removeChild(d));return a}n.extend({htmlPrefilter:function(a){return a.replace(va,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h,i=n.contains(a.ownerDocument,a);if(l.html5Clone||n.isXMLDoc(a)||!ua.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(Ba.innerHTML=a.outerHTML,Ba.removeChild(f=Ba.firstChild)),!(l.noCloneEvent&&l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(d=ea(f),h=ea(a),g=0;null!=(e=h[g]);++g)d[g]&&Ga(e,d[g]);if(b)if(c)for(h=h||ea(a),d=d||ea(f),g=0;null!=(e=h[g]);g++)Fa(e,d[g]);else Fa(a,f);return d=ea(f,"script"),d.length>0&&fa(d,!i&&ea(a,"script")),d=h=e=null,f},cleanData:function(a,b){for(var d,e,f,g,h=0,i=n.expando,j=n.cache,k=l.attributes,m=n.event.special;null!=(d=a[h]);h++)if((b||M(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)m[e]?n.event.remove(d,e):n.removeEvent(d,e,g.handle);j[f]&&(delete j[f],k||"undefined"==typeof d.removeAttribute?d[i]=void 0:d.removeAttribute(i),c.push(f))}}}),n.fn.extend({domManip:Ha,detach:function(a){return Ia(this,a,!0)},remove:function(a){return Ia(this,a)},text:function(a){return Y(this,function(a){return void 0===a?n.text(this):this.empty().append((this[0]&&this[0].ownerDocument||d).createTextNode(a))},null,a,arguments.length)},append:function(){return Ha(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ca(this,a);b.appendChild(a)}})},prepend:function(){return Ha(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ca(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ha(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ha(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&n.cleanData(ea(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&n.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return Y(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(ta,""):void 0;if("string"==typeof a&&!wa.test(a)&&(l.htmlSerialize||!ua.test(a))&&(l.leadingWhitespace||!aa.test(a))&&!da[($.exec(a)||["",""])[1].toLowerCase()]){a=n.htmlPrefilter(a);try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ea(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ha(this,arguments,function(b){var c=this.parentNode;n.inArray(this,a)<0&&(n.cleanData(ea(this)),c&&c.replaceChild(b,this))},a)}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=0,e=[],f=n(a),h=f.length-1;h>=d;d++)c=d===h?this:this.clone(!0),n(f[d])[b](c),g.apply(e,c.get());return this.pushStack(e)}});var Ja,Ka={HTML:"block",BODY:"block"};function La(a,b){var c=n(b.createElement(a)).appendTo(b.body),d=n.css(c[0],"display");return c.detach(),d}function Ma(a){var b=d,c=Ka[a];return c||(c=La(a,b),"none"!==c&&c||(Ja=(Ja||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ja[0].contentWindow||Ja[0].contentDocument).document,b.write(),b.close(),c=La(a,b),Ja.detach()),Ka[a]=c),c}var Na=/^margin/,Oa=new RegExp("^("+T+")(?!px)[a-z%]+$","i"),Pa=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e},Qa=d.documentElement;!function(){var b,c,e,f,g,h,i=d.createElement("div"),j=d.createElement("div");if(j.style){j.style.cssText="float:left;opacity:.5",l.opacity="0.5"===j.style.opacity,l.cssFloat=!!j.style.cssFloat,j.style.backgroundClip="content-box",j.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===j.style.backgroundClip,i=d.createElement("div"),i.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",j.innerHTML="",i.appendChild(j),l.boxSizing=""===j.style.boxSizing||""===j.style.MozBoxSizing||""===j.style.WebkitBoxSizing,n.extend(l,{reliableHiddenOffsets:function(){return null==b&&k(),f},boxSizingReliable:function(){return null==b&&k(),e},pixelMarginRight:function(){return null==b&&k(),c},pixelPosition:function(){return null==b&&k(),b},reliableMarginRight:function(){return null==b&&k(),g},reliableMarginLeft:function(){return null==b&&k(),h}});function k(){var k,l,m=d.documentElement;m.appendChild(i),j.style.cssText="-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",b=e=h=!1,c=g=!0,a.getComputedStyle&&(l=a.getComputedStyle(j),b="1%"!==(l||{}).top,h="2px"===(l||{}).marginLeft,e="4px"===(l||{width:"4px"}).width,j.style.marginRight="50%",c="4px"===(l||{marginRight:"4px"}).marginRight,k=j.appendChild(d.createElement("div")),k.style.cssText=j.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",k.style.marginRight=k.style.width="0",j.style.width="1px",g=!parseFloat((a.getComputedStyle(k)||{}).marginRight),j.removeChild(k)),j.style.display="none",f=0===j.getClientRects().length,f&&(j.style.display="",j.innerHTML="<table><tr><td></td><td>t</td></tr></table>",k=j.getElementsByTagName("td"),k[0].style.cssText="margin:0;border:0;padding:0;display:none",f=0===k[0].offsetHeight,f&&(k[0].style.display="",k[1].style.display="none",f=0===k[0].offsetHeight)),m.removeChild(i)}}}();var Ra,Sa,Ta=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ra=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)},Sa=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ra(a),g=c?c.getPropertyValue(b)||c[b]:void 0,""!==g&&void 0!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),c&&!l.pixelMarginRight()&&Oa.test(g)&&Na.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f),void 0===g?g:g+""}):Qa.currentStyle&&(Ra=function(a){return a.currentStyle},Sa=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ra(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Oa.test(g)&&!Ta.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function Ua(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Va=/alpha\([^)]*\)/i,Wa=/opacity\s*=\s*([^)]*)/i,Xa=/^(none|table(?!-c[ea]).+)/,Ya=new RegExp("^("+T+")(.*)$","i"),Za={position:"absolute",visibility:"hidden",display:"block"},$a={letterSpacing:"0",fontWeight:"400"},_a=["Webkit","O","Moz","ms"],ab=d.createElement("div").style;function bb(a){if(a in ab)return a;var b=a.charAt(0).toUpperCase()+a.slice(1),c=_a.length;while(c--)if(a=_a[c]+b,a in ab)return a}function cb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=n._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&W(d)&&(f[g]=n._data(d,"olddisplay",Ma(d.nodeName)))):(e=W(d),(c&&"none"!==c||!e)&&n._data(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function db(a,b,c){var d=Ya.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function eb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+V[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+V[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+V[f]+"Width",!0,e))):(g+=n.css(a,"padding"+V[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+V[f]+"Width",!0,e)));return g}function fb(b,c,e){var f=!0,g="width"===c?b.offsetWidth:b.offsetHeight,h=Ra(b),i=l.boxSizing&&"border-box"===n.css(b,"boxSizing",!1,h);if(d.msFullscreenElement&&a.top!==a&&b.getClientRects().length&&(g=Math.round(100*b.getBoundingClientRect()[c])),0>=g||null==g){if(g=Sa(b,c,h),(0>g||null==g)&&(g=b.style[c]),Oa.test(g))return g;f=i&&(l.boxSizingReliable()||g===b.style[c]),g=parseFloat(g)||0}return g+eb(b,c,e||(i?"border":"content"),f,h)+"px"}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Sa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":l.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;if(b=n.cssProps[h]||(n.cssProps[h]=bb(h)||h),g=n.cssHooks[b]||n.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=U.exec(c))&&e[1]&&(c=X(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(n.cssNumber[h]?"":"px")),l.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=bb(h)||h),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Sa(a,b,d)),"normal"===f&&b in $a&&(f=$a[b]),""===c||c?(e=parseFloat(f),c===!0||isFinite(e)?e||0:f):f}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?Xa.test(n.css(a,"display"))&&0===a.offsetWidth?Pa(a,Za,function(){return fb(a,b,d)}):fb(a,b,d):void 0},set:function(a,c,d){var e=d&&Ra(a);return db(a,c,d?eb(a,b,d,l.boxSizing&&"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),l.opacity||(n.cssHooks.opacity={get:function(a,b){return Wa.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=n.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===n.trim(f.replace(Va,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Va.test(f)?f.replace(Va,e):f+" "+e)}}),n.cssHooks.marginRight=Ua(l.reliableMarginRight,function(a,b){return b?Pa(a,{display:"inline-block"},Sa,[a,"marginRight"]):void 0}),n.cssHooks.marginLeft=Ua(l.reliableMarginLeft,function(a,b){
return b?(parseFloat(Sa(a,"marginLeft"))||(n.contains(a.ownerDocument,a)?a.getBoundingClientRect().left-Pa(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}):0))+"px":void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+V[d]+b]=f[d]||f[d-2]||f[0];return e}},Na.test(a)||(n.cssHooks[a+b].set=db)}),n.fn.extend({css:function(a,b){return Y(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=Ra(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return cb(this,!0)},hide:function(){return cb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){W(this)?n(this).show():n(this).hide()})}});function gb(a,b,c,d,e){return new gb.prototype.init(a,b,c,d,e)}n.Tween=gb,gb.prototype={constructor:gb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||n.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=gb.propHooks[this.prop];return a&&a.get?a.get(this):gb.propHooks._default.get(this)},run:function(a){var b,c=gb.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):gb.propHooks._default.set(this),this}},gb.prototype.init.prototype=gb.prototype,gb.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[n.cssProps[a.prop]]&&!n.cssHooks[a.prop]?a.elem[a.prop]=a.now:n.style(a.elem,a.prop,a.now+a.unit)}}},gb.propHooks.scrollTop=gb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},n.fx=gb.prototype.init,n.fx.step={};var hb,ib,jb=/^(?:toggle|show|hide)$/,kb=/queueHooks$/;function lb(){return a.setTimeout(function(){hb=void 0}),hb=n.now()}function mb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=V[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function nb(a,b,c){for(var d,e=(qb.tweeners[b]||[]).concat(qb.tweeners["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ob(a,b,c){var d,e,f,g,h,i,j,k,m=this,o={},p=a.style,q=a.nodeType&&W(a),r=n._data(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,m.always(function(){m.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=n.css(a,"display"),k="none"===j?n._data(a,"olddisplay")||Ma(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(l.inlineBlockNeedsLayout&&"inline"!==Ma(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",l.shrinkWrapBlocks()||m.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],jb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(o))"inline"===("none"===j?Ma(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=n._data(a,"fxshow",{}),f&&(r.hidden=!q),q?n(a).show():m.done(function(){n(a).hide()}),m.done(function(){var b;n._removeData(a,"fxshow");for(b in o)n.style(a,b,o[b])});for(d in o)g=nb(q?r[d]:0,d,m),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function pb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function qb(a,b,c){var d,e,f=0,g=qb.prefilters.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=hb||lb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{},easing:n.easing._default},c),originalProperties:b,originalOptions:c,startTime:hb||lb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(pb(k,j.opts.specialEasing);g>f;f++)if(d=qb.prefilters[f].call(j,a,k,j.opts))return n.isFunction(d.stop)&&(n._queueHooks(j.elem,j.opts.queue).stop=n.proxy(d.stop,d)),d;return n.map(k,nb,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(qb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return X(c.elem,a,U.exec(b),c),c}]},tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.match(G);for(var c,d=0,e=a.length;e>d;d++)c=a[d],qb.tweeners[c]=qb.tweeners[c]||[],qb.tweeners[c].unshift(b)},prefilters:[ob],prefilter:function(a,b){b?qb.prefilters.unshift(a):qb.prefilters.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(W).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=qb(this,n.extend({},a),f);(e||n._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=n._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&kb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=n._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(mb(b,!0),a,d,e)}}),n.each({slideDown:mb("show"),slideUp:mb("hide"),slideToggle:mb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=n.timers,c=0;for(hb=n.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||n.fx.stop(),hb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){ib||(ib=a.setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){a.clearInterval(ib),ib=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(b,c){return b=n.fx?n.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a,b=d.createElement("input"),c=d.createElement("div"),e=d.createElement("select"),f=e.appendChild(d.createElement("option"));c=d.createElement("div"),c.setAttribute("className","t"),c.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=c.getElementsByTagName("a")[0],b.setAttribute("type","checkbox"),c.appendChild(b),a=c.getElementsByTagName("a")[0],a.style.cssText="top:1px",l.getSetAttribute="t"!==c.className,l.style=/top/.test(a.getAttribute("style")),l.hrefNormalized="/a"===a.getAttribute("href"),l.checkOn=!!b.value,l.optSelected=f.selected,l.enctype=!!d.createElement("form").enctype,e.disabled=!0,l.optDisabled=!f.disabled,b=d.createElement("input"),b.setAttribute("value",""),l.input=""===b.getAttribute("value"),b.value="t",b.setAttribute("type","radio"),l.radioValue="t"===b.value}();var rb=/\r/g,sb=/[\x20\t\r\n\f]+/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a)).replace(sb," ")}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],(c.selected||i===e)&&(l.optDisabled?!c.disabled:null===c.getAttribute("disabled"))&&(!c.parentNode.disabled||!n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)if(d=e[g],n.inArray(n.valHooks.option.get(d),f)>-1)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>-1:void 0}},l.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var tb,ub,vb=n.expr.attrHandle,wb=/^(?:checked|selected)$/i,xb=l.getSetAttribute,yb=l.input;n.fn.extend({attr:function(a,b){return Y(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),e=n.attrHooks[b]||(n.expr.match.bool.test(b)?ub:tb)),void 0!==c?null===c?void n.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=n.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(G);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)?yb&&xb||!wb.test(c)?a[d]=!1:a[n.camelCase("default-"+c)]=a[d]=!1:n.attr(a,c,""),a.removeAttribute(xb?c:d)}}),ub={set:function(a,b,c){return b===!1?n.removeAttr(a,c):yb&&xb||!wb.test(c)?a.setAttribute(!xb&&n.propFix[c]||c,c):a[n.camelCase("default-"+c)]=a[c]=!0,c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=vb[b]||n.find.attr;yb&&xb||!wb.test(b)?vb[b]=function(a,b,d){var e,f;return d||(f=vb[b],vb[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,vb[b]=f),e}:vb[b]=function(a,b,c){return c?void 0:a[n.camelCase("default-"+b)]?b.toLowerCase():null}}),yb&&xb||(n.attrHooks.value={set:function(a,b,c){return n.nodeName(a,"input")?void(a.defaultValue=b):tb&&tb.set(a,b,c)}}),xb||(tb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},vb.id=vb.name=vb.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},n.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:tb.set},n.attrHooks.contenteditable={set:function(a,b,c){tb.set(a,""===b?!1:b,c)}},n.each(["width","height"],function(a,b){n.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),l.style||(n.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var zb=/^(?:input|select|textarea|button|object)$/i,Ab=/^(?:a|area)$/i;n.fn.extend({prop:function(a,b){return Y(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return a=n.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),n.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&n.isXMLDoc(a)||(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=n.find.attr(a,"tabindex");return b?parseInt(b,10):zb.test(a.nodeName)||Ab.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),l.hrefNormalized||n.each(["href","src"],function(a,b){n.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),l.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this}),l.enctype||(n.propFix.enctype="encoding");var Bb=/[\t\r\n\f]/g;function Cb(a){return n.attr(a,"class")||""}n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,Cb(this)))});if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=Cb(c),d=1===c.nodeType&&(" "+e+" ").replace(Bb," ")){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=n.trim(d),e!==h&&n.attr(c,"class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,Cb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=Cb(c),d=1===c.nodeType&&(" "+e+" ").replace(Bb," ")){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=n.trim(d),e!==h&&n.attr(c,"class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):n.isFunction(a)?this.each(function(c){n(this).toggleClass(a.call(this,c,Cb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=n(this),f=a.match(G)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=Cb(this),b&&n._data(this,"__className__",b),n.attr(this,"class",b||a===!1?"":n._data(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+Cb(c)+" ").replace(Bb," ").indexOf(b)>-1)return!0;return!1}}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Db=a.location,Eb=n.now(),Fb=/\?/,Gb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;n.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=n.trim(b+"");return e&&!n.trim(e.replace(Gb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():n.error("Invalid JSON: "+b)},n.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new a.DOMParser,c=d.parseFromString(b,"text/xml")):(c=new a.ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||n.error("Invalid XML: "+b),c};var Hb=/#.*$/,Ib=/([?&])_=[^&]*/,Jb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Kb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Lb=/^(?:GET|HEAD)$/,Mb=/^\/\//,Nb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Ob={},Pb={},Qb="*/".concat("*"),Rb=Db.href,Sb=Nb.exec(Rb.toLowerCase())||[];function Tb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(G)||[];if(n.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Ub(a,b,c,d){var e={},f=a===Pb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Vb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&n.extend(!0,a,c),a}function Wb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Xb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Rb,type:"GET",isLocal:Kb.test(Sb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Qb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Vb(Vb(a,n.ajaxSettings),b):Vb(n.ajaxSettings,a)},ajaxPrefilter:Tb(Ob),ajaxTransport:Tb(Pb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var d,e,f,g,h,i,j,k,l=n.ajaxSetup({},c),m=l.context||l,o=l.context&&(m.nodeType||m.jquery)?n(m):n.event,p=n.Deferred(),q=n.Callbacks("once memory"),r=l.statusCode||{},s={},t={},u=0,v="canceled",w={readyState:0,getResponseHeader:function(a){var b;if(2===u){if(!k){k={};while(b=Jb.exec(g))k[b[1].toLowerCase()]=b[2]}b=k[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===u?g:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return u||(a=t[c]=t[c]||a,s[a]=b),this},overrideMimeType:function(a){return u||(l.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>u)for(b in a)r[b]=[r[b],a[b]];else w.always(a[w.status]);return this},abort:function(a){var b=a||v;return j&&j.abort(b),y(0,b),this}};if(p.promise(w).complete=q.add,w.success=w.done,w.error=w.fail,l.url=((b||l.url||Rb)+"").replace(Hb,"").replace(Mb,Sb[1]+"//"),l.type=c.method||c.type||l.method||l.type,l.dataTypes=n.trim(l.dataType||"*").toLowerCase().match(G)||[""],null==l.crossDomain&&(d=Nb.exec(l.url.toLowerCase()),l.crossDomain=!(!d||d[1]===Sb[1]&&d[2]===Sb[2]&&(d[3]||("http:"===d[1]?"80":"443"))===(Sb[3]||("http:"===Sb[1]?"80":"443")))),l.data&&l.processData&&"string"!=typeof l.data&&(l.data=n.param(l.data,l.traditional)),Ub(Ob,l,c,w),2===u)return w;i=n.event&&l.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),l.type=l.type.toUpperCase(),l.hasContent=!Lb.test(l.type),f=l.url,l.hasContent||(l.data&&(f=l.url+=(Fb.test(f)?"&":"?")+l.data,delete l.data),l.cache===!1&&(l.url=Ib.test(f)?f.replace(Ib,"$1_="+Eb++):f+(Fb.test(f)?"&":"?")+"_="+Eb++)),l.ifModified&&(n.lastModified[f]&&w.setRequestHeader("If-Modified-Since",n.lastModified[f]),n.etag[f]&&w.setRequestHeader("If-None-Match",n.etag[f])),(l.data&&l.hasContent&&l.contentType!==!1||c.contentType)&&w.setRequestHeader("Content-Type",l.contentType),w.setRequestHeader("Accept",l.dataTypes[0]&&l.accepts[l.dataTypes[0]]?l.accepts[l.dataTypes[0]]+("*"!==l.dataTypes[0]?", "+Qb+"; q=0.01":""):l.accepts["*"]);for(e in l.headers)w.setRequestHeader(e,l.headers[e]);if(l.beforeSend&&(l.beforeSend.call(m,w,l)===!1||2===u))return w.abort();v="abort";for(e in{success:1,error:1,complete:1})w[e](l[e]);if(j=Ub(Pb,l,c,w)){if(w.readyState=1,i&&o.trigger("ajaxSend",[w,l]),2===u)return w;l.async&&l.timeout>0&&(h=a.setTimeout(function(){w.abort("timeout")},l.timeout));try{u=1,j.send(s,y)}catch(x){if(!(2>u))throw x;y(-1,x)}}else y(-1,"No Transport");function y(b,c,d,e){var k,s,t,v,x,y=c;2!==u&&(u=2,h&&a.clearTimeout(h),j=void 0,g=e||"",w.readyState=b>0?4:0,k=b>=200&&300>b||304===b,d&&(v=Wb(l,w,d)),v=Xb(l,v,w,k),k?(l.ifModified&&(x=w.getResponseHeader("Last-Modified"),x&&(n.lastModified[f]=x),x=w.getResponseHeader("etag"),x&&(n.etag[f]=x)),204===b||"HEAD"===l.type?y="nocontent":304===b?y="notmodified":(y=v.state,s=v.data,t=v.error,k=!t)):(t=y,!b&&y||(y="error",0>b&&(b=0))),w.status=b,w.statusText=(c||y)+"",k?p.resolveWith(m,[s,y,w]):p.rejectWith(m,[w,y,t]),w.statusCode(r),r=void 0,i&&o.trigger(k?"ajaxSuccess":"ajaxError",[w,l,k?s:t]),q.fireWith(m,[w,y]),i&&(o.trigger("ajaxComplete",[w,l]),--n.active||n.event.trigger("ajaxStop")))}return w},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax(n.extend({url:a,type:b,dataType:e,data:c,success:d},n.isPlainObject(a)&&a))}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){if(n.isFunction(a))return this.each(function(b){n(this).wrapAll(a.call(this,b))});if(this[0]){var b=n(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return n.isFunction(a)?this.each(function(b){n(this).wrapInner(a.call(this,b))}):this.each(function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}});function Yb(a){return a.style&&a.style.display||n.css(a,"display")}function Zb(a){while(a&&1===a.nodeType){if("none"===Yb(a)||"hidden"===a.type)return!0;a=a.parentNode}return!1}n.expr.filters.hidden=function(a){return l.reliableHiddenOffsets()?a.offsetWidth<=0&&a.offsetHeight<=0&&!a.getClientRects().length:Zb(a)},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var $b=/%20/g,_b=/\[\]$/,ac=/\r?\n/g,bc=/^(?:submit|button|image|reset|file)$/i,cc=/^(?:input|select|textarea|keygen)/i;function dc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||_b.test(a)?d(a,e):dc(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)dc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)dc(c,a[c],b,e);return d.join("&").replace($b,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&cc.test(this.nodeName)&&!bc.test(a)&&(this.checked||!Z.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(ac,"\r\n")}}):{name:b.name,value:c.replace(ac,"\r\n")}}).get()}}),n.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return this.isLocal?ic():d.documentMode>8?hc():/^(get|post|head|put|delete|options)$/i.test(this.type)&&hc()||ic()}:hc;var ec=0,fc={},gc=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in fc)fc[a](void 0,!0)}),l.cors=!!gc&&"withCredentials"in gc,gc=l.ajax=!!gc,gc&&n.ajaxTransport(function(b){if(!b.crossDomain||l.cors){var c;return{send:function(d,e){var f,g=b.xhr(),h=++ec;if(g.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(f in b.xhrFields)g[f]=b.xhrFields[f];b.mimeType&&g.overrideMimeType&&g.overrideMimeType(b.mimeType),b.crossDomain||d["X-Requested-With"]||(d["X-Requested-With"]="XMLHttpRequest");for(f in d)void 0!==d[f]&&g.setRequestHeader(f,d[f]+"");g.send(b.hasContent&&b.data||null),c=function(a,d){var f,i,j;if(c&&(d||4===g.readyState))if(delete fc[h],c=void 0,g.onreadystatechange=n.noop,d)4!==g.readyState&&g.abort();else{j={},f=g.status,"string"==typeof g.responseText&&(j.text=g.responseText);try{i=g.statusText}catch(k){i=""}f||!b.isLocal||b.crossDomain?1223===f&&(f=204):f=j.text?200:404}j&&e(f,i,j,g.getAllResponseHeaders())},b.async?4===g.readyState?a.setTimeout(c):g.onreadystatechange=fc[h]=c:c()},abort:function(){c&&c(void 0,!0)}}}});function hc(){try{return new a.XMLHttpRequest}catch(b){}}function ic(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}n.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=d.head||n("head")[0]||d.documentElement;return{send:function(e,f){b=d.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||f(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var jc=[],kc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=jc.pop()||n.expando+"_"+Eb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(kc.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&kc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(kc,"$1"+e):b.jsonp!==!1&&(b.url+=(Fb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?n(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,jc.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||d;var e=x.exec(a),f=!c&&[];return e?[b.createElement(e[1])]:(e=ja([a],b,f),f&&f.length&&n(f).remove(),n.merge([],e.childNodes))};var lc=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&lc)return lc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=n.trim(a.slice(h,a.length)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(g,f||[a.responseText,b,a])})}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};function mc(a){return n.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&n.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,n.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,n.contains(b,e)?("undefined"!=typeof e.getBoundingClientRect&&(d=e.getBoundingClientRect()),c=mc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===n.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(c=a.offset()),c.top+=n.css(a[0],"borderTopWidth",!0),c.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-n.css(d,"marginTop",!0),left:b.left-c.left-n.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Qa})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);n.fn[a]=function(d){return Y(this,function(a,d,e){var f=mc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?n(f).scrollLeft():e,c?e:n(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=Ua(l.pixelPosition,function(a,c){
return c?(c=Sa(a,b),Oa.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return Y(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var nc=a.jQuery,oc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=oc),b&&a.jQuery===n&&(a.jQuery=nc),n},b||(a.jQuery=a.$=n),n});

/*! jQuery UI - v1.11.4 - 2015-04-05
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, draggable.js, droppable.js, resizable.js, selectable.js, sortable.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, menu.js, progressbar.js, selectmenu.js, slider.js, spinner.js, tabs.js, tooltip.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {
/*!
 * jQuery UI Core 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */


// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.11.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	scrollParent: function( includeHidden ) {
		var position = this.css( "position" ),
			excludeStaticParent = position === "absolute",
			overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
			scrollParent = this.parents().filter( function() {
				var parent = $( this );
				if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
					return false;
				}
				return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
			}).eq( 0 );

		return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
	},

	uniqueId: (function() {
		var uuid = 0;

		return function() {
			return this.each(function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			});
		};
	})(),

	removeUniqueId: function() {
		return this.each(function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
		return !!img && visible( img );
	}
	return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}

// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	disableSelection: (function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.bind( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
		};
	})(),

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	}
});

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
$.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};


/*!
 * jQuery UI Widget 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */


var widget_uuid = 0,
	widget_slice = Array.prototype.slice;

$.cleanData = (function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
})( $.cleanData );

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widget_slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = widget_slice.call( arguments, 1 ),
			returnValue = this;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat(args) );
			}

			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widget_uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled", !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}
		}

		return this;
	},

	enable: function() {
		return this._setOptions({ disabled: false });
	},
	disable: function() {
		return this._setOptions({ disabled: true });
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

var widget = $.widget;


/*!
 * jQuery UI Mouse 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */


var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

var mouse = $.widget("ui.mouse", {
	version: "1.11.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown." + this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click." + this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("." + this.widgetName);
		if ( this._mouseMoveDelegate ) {
			this.document
				.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};

		this.document
			.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {
			// IE mouseup check - mouseup happened when mouse was out of window
			if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
				return this._mouseUp(event);

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {
				return this._mouseUp( event );
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		this.document
			.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		mouseHandled = false;
		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});


/*!
 * jQuery UI Position 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

(function() {

$.ui = $.ui || {};

var cachedScrollbarWidth, supportsOffsetFractions,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),

			// support: jQuery 1.6.x
			// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
			width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !supportsOffsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function() {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

})();

var position = $.ui.position;


/*!
 * jQuery UI Draggable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */


$.widget("ui.draggable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {
		var o = this.options;

		this._blurActiveElement( event );

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map(function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		});
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var document = this.document[ 0 ];

		// Only need to blur if the event occurred on the draggable itself, see #10527
		if ( !this.handleElement.is( event.target ) ) {
			return;
		}

		// support: IE9
		// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
		try {

			// Support: IE9, IE10
			// If the <body> is blurred, IE will switch windows, see #9520
			if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {

				// Blur any element that currently has focus, see #4261
				$( document.activeElement ).blur();
			}
		} catch ( error ) {}
	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter(function() {
				return $( this ).css( "position" ) === "fixed";
			}).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if (this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		// Reset helper's right/bottom css if they're set and set explicit width/height instead
		// as this prevents resizing of elements with right/bottom set (see #7772)
		this._normalizeRightBottom();

		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if (this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if (this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if (that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if (this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {
			// The interaction is over; whether or not the click resulted in a drag, focus the element
			this.element.focus();
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if (this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this.handleElement.addClass( "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this.handleElement.removeClass( "ui-draggable-handle" );
	},

	_createHelper: function(event) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if (!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		// http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = { left: +obj[0], top: +obj[1] || 0 };
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"), 10) || 0),
			top: (parseInt(this.element.css("marginTop"), 10) || 0),
			right: (parseInt(this.element.css("marginRight"), 10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function(d, pos) {

		if (!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ){
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if (event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if (event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if (o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	_normalizeRightBottom: function() {
		if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
			this.helper.width( this.helper.width() );
			this.helper.css( "right", "auto" );
		}
		if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
			this.helper.height( this.helper.height() );
			this.helper.css( "bottom", "auto" );
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		});

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each(function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// refreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger("activate", event, uiSortable);
			}
		});
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		});

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop(event);

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {
				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		});
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {
					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				});
			}

			if ( innermostIntersecting ) {
				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					});

					// hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );
					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {
				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					});
				}
			}
		});
	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if (t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if (!o.axis || o.axis !== "x") {
				if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if (!o.axis || o.axis !== "y") {
				if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if (this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left - inst.margins.left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top - inst.margins.top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if (inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if (o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
				}
			}

			first = (ts || bs || ls || rs);

			if (o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
				}
			}

			if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray($(o.stack)).sort(function(a, b) {
				return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if (t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if (o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

var draggable = $.ui.draggable;


/*!
 * jQuery UI Droppable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/droppable/
 */


$.widget( "ui.droppable", {
	version: "1.11.4",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: "default",
		tolerance: "intersect",

		// callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {
				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {
				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this.element.addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {
		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );

		this.element.removeClass( "ui-droppable ui-droppable-disabled" );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.addClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.removeClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {
			var inst = $( this ).droppable( "instance" );
			if (
				inst.options.greedy &&
				!inst.options.disabled &&
				inst.options.scope === draggable.options.scope &&
				inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&
				$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )
			) { childrenIntersection = true; return false; }
		});
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = (function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode, event ) {

		if ( !droppable.offset ) {
			return false;
		}

		var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,
			y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
})();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;
		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		});
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),
				c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {
				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				});

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// we just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[c === "isout" ? "isover" : "isout"] = false;
			this[c === "isover" ? "_over" : "_out"].call( this, event );

			// we just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

var droppable = $.ui.droppable;


/*!
 * jQuery UI Resizable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 */


$.widget("ui.resizable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},

	_num: function( value ) {
		return parseInt( value, 10 ) || 0;
	},

	_isNumber: function( value ) {
		return !isNaN( parseInt( value, 10 ) );
	},

	_hasScroll: function( el, a ) {

		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		});

		// Wrap the element if it cannot hold child nodes
		if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {

			this.element.wrap(
				$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
					position: this.element.css("position"),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css("top"),
					left: this.element.css("left")
				})
			);

			this.element = this.element.parent().data(
				"ui-resizable", this.element.resizable( "instance" )
			);

			this.elementIsWrapper = true;

			this.element.css({
				marginLeft: this.originalElement.css("marginLeft"),
				marginTop: this.originalElement.css("marginTop"),
				marginRight: this.originalElement.css("marginRight"),
				marginBottom: this.originalElement.css("marginBottom")
			});
			this.originalElement.css({
				marginLeft: 0,
				marginTop: 0,
				marginRight: 0,
				marginBottom: 0
			});
			// support: Safari
			// Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css("resize");
			this.originalElement.css("resize", "none");

			this._proportionallyResizeElements.push( this.originalElement.css({
				position: "static",
				zoom: 1,
				display: "block"
			}) );

			// support: IE9
			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css("margin") });

			this._proportionallyResize();
		}

		this.handles = o.handles ||
			( !$(".ui-resizable-handle", this.element).length ?
				"e,s,se" : {
					n: ".ui-resizable-n",
					e: ".ui-resizable-e",
					s: ".ui-resizable-s",
					w: ".ui-resizable-w",
					se: ".ui-resizable-se",
					sw: ".ui-resizable-sw",
					ne: ".ui-resizable-ne",
					nw: ".ui-resizable-nw"
				} );

		this._handles = $();
		if ( this.handles.constructor === String ) {

			if ( this.handles === "all") {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split(",");
			this.handles = {};

			for (i = 0; i < n.length; i++) {

				handle = $.trim(n[i]);
				hname = "ui-resizable-" + handle;
				axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

				axis.css({ zIndex: o.zIndex });

				// TODO : What's going on here?
				if ("se" === handle) {
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
				}

				this.handles[handle] = ".ui-resizable-" + handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for (i in this.handles) {

				if (this.handles[i].constructor === String) {
					this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
				} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
					this.handles[ i ] = $( this.handles[ i ] );
					this._on( this.handles[ i ], { "mousedown": that._mouseDown });
				}

				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {

					axis = $(this.handles[i], this.element);

					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					padPos = [ "padding",
						/ne|nw|n/.test(i) ? "Top" :
						/se|sw|s/.test(i) ? "Bottom" :
						/^e$/.test(i) ? "Right" : "Left" ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();
				}

				this._handles = this._handles.add( this.handles[ i ] );
			}
		};

		// TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
		this._handles.disableSelection();

		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				that.axis = axis && axis[1] ? axis[1] : "se";
			}
		});

		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function() {
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		this._mouseInit();
	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp)
					.removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable")
					.removeData("ui-resizable")
					.unbind(".resizable")
					.find(".ui-resizable-handle")
						.remove();
			};

		// TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css("position"),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css("top"),
				left: wrapper.css("left")
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css("resize", this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			el = this.element;

		this.resizing = true;

		this._renderProxy();

		curleft = this._num(this.helper.css("left"));
		curtop = this._num(this.helper.css("top"));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };

		this.size = this._helper ? {
				width: this.helper.width(),
				height: this.helper.height()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.originalSize = this._helper ? {
				width: el.outerWidth(),
				height: el.outerHeight()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.sizeDiff = {
			width: el.outerWidth() - el.width(),
			height: el.outerHeight() - el.height()
		};

		this.originalPosition = { left: curleft, top: curtop };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		this.aspectRatio = (typeof o.aspectRatio === "number") ?
			o.aspectRatio :
			((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(".ui-resizable-" + this.axis).css("cursor");
		$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		var data, props,
			smp = this.originalMousePosition,
			a = this.axis,
			dx = (event.pageX - smp.left) || 0,
			dy = (event.pageY - smp.top) || 0,
			trigger = this._change[a];

		this._updatePrevProperties();

		if (!trigger) {
			return false;
		}

		data = trigger.apply(this, [ event, dx, dy ]);

		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		this._propagate("resize", event);

		props = this._applyChanges();

		if ( !this._helper && this._proportionallyResizeElements.length ) {
			this._proportionallyResize();
		}

		if ( !$.isEmptyObject( props ) ) {
			this._updatePrevProperties();
			this._trigger( "resize", event, this.ui() );
			this._applyChanges();
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if (this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && (/textarea/i).test(pr[0].nodeName);
			soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = {
				width: (that.helper.width()  - soffsetw),
				height: (that.helper.height() - soffseth)
			};
			left = (parseInt(that.element.css("left"), 10) +
				(that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css("top"), 10) +
				(that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) {
				this._proportionallyResize();
			}
		}

		$("body").css("cursor", "auto");

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updatePrevProperties: function() {
		this.prevPosition = {
			top: this.position.top,
			left: this.position.left
		};
		this.prevSize = {
			width: this.size.width,
			height: this.size.height
		};
	},

	_applyChanges: function() {
		var props = {};

		if ( this.position.top !== this.prevPosition.top ) {
			props.top = this.position.top + "px";
		}
		if ( this.position.left !== this.prevPosition.left ) {
			props.left = this.position.left + "px";
		}
		if ( this.size.width !== this.prevSize.width ) {
			props.width = this.size.width + "px";
		}
		if ( this.size.height !== this.prevSize.height ) {
			props.height = this.size.height + "px";
		}

		this.helper.css( props );

		return props;
	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if (this._aspectRatio || forceAspectRatio) {
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if (pMinWidth > b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if (pMinHeight > b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if (pMaxWidth < b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if (pMaxHeight < b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (this._isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (this._isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (this._isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (this._isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (this._isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (this._isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === "sw") {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === "nw") {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
			ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
			isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
			isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw && cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw && cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh && ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh && ch) {
			data.top = dh - o.maxHeight;
		}

		// Fixing jump error on top/left - bug #2330
		if (!data.width && !data.height && !data.left && data.top) {
			data.top = null;
		} else if (!data.width && !data.height && !data.top && data.left) {
			data.left = null;
		}

		return data;
	},

	_getPaddingPlusBorderDimensions: function( element ) {
		var i = 0,
			widths = [],
			borders = [
				element.css( "borderTopWidth" ),
				element.css( "borderRightWidth" ),
				element.css( "borderBottomWidth" ),
				element.css( "borderLeftWidth" )
			],
			paddings = [
				element.css( "paddingTop" ),
				element.css( "paddingRight" ),
				element.css( "paddingBottom" ),
				element.css( "paddingLeft" )
			];

		for ( ; i < 4; i++ ) {
			widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );
			widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );
		}

		return {
			height: widths[ 0 ] + widths[ 2 ],
			width: widths[ 1 ] + widths[ 3 ]
		};
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var prel,
			i = 0,
			element = this.helper || this.element;

		for ( ; i < this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			// TODO: Seems like a bug to cache this.outerDimensions
			// considering that we are in a loop.
			if (!this.outerDimensions) {
				this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
			}

			prel.css({
				height: (element.height() - this.outerDimensions.height) || 0,
				width: (element.width() - this.outerDimensions.width) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if (this._helper) {

			this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: "absolute",
				left: this.elementOffset.left + "px",
				top: this.elementOffset.top + "px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments),
				this._change.e.apply(this, [ event, dx, dy ]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments),
				this._change.w.apply(this, [ event, dx, dy ]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments),
				this._change.e.apply(this, [ event, dx, dy ]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments),
				this._change.w.apply(this, [ event, dx, dy ]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [ event, this.ui() ]);
		(n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && (/textarea/i).test(pr[0].nodeName),
			soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css("left"), 10) +
				(that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css("top"), 10) +
				(that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css("width"), 10),
						height: parseInt(that.element.css("height"), 10),
						top: parseInt(that.element.css("top"), 10),
						left: parseInt(that.element.css("left"), 10)
					};

					if (pr && pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add( "resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

		if ( !ce ) {
			return;
		}

		that.containerElement = $( ce );

		if ( /document/.test( oc ) || oc === document ) {
			that.containerOffset = {
				left: 0,
				top: 0
			};
			that.containerPosition = {
				left: 0,
				top: 0
			};

			that.parentData = {
				element: $( document ),
				left: 0,
				top: 0,
				width: $( document ).width(),
				height: $( document ).height() || document.body.parentNode.scrollHeight
			};
		} else {
			element = $( ce );
			p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
				p[ i ] = that._num( element.css( "padding" + name ) );
			});

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = {
				height: ( element.innerHeight() - p[ 3 ] ),
				width: ( element.innerWidth() - p[ 1 ] )
			};

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
			height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

			that.parentData = {
				element: ce,
				left: co.left,
				top: co.top,
				width: width,
				height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = {
				top: 0,
				left: 0
			},
			ce = that.containerElement,
			continueResize = true;

		if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
			cop = co;
		}

		if ( cp.left < ( that._helper ? co.left : 0 ) ) {
			that.size.width = that.size.width +
				( that._helper ?
					( that.position.left - co.left ) :
					( that.position.left - cop.left ) );

			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if ( cp.top < ( that._helper ? co.top : 0 ) ) {
			that.size.height = that.size.height +
				( that._helper ?
					( that.position.top - co.top ) :
					that.position.top );

			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
		isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

		if ( isParent && isOffsetRelative ) {
			that.offset.left = that.parentData.left + that.position.left;
			that.offset.top = that.parentData.top + that.position.top;
		} else {
			that.offset.left = that.element.offset().left;
			that.offset.top = that.element.offset().top;
		}

		woset = Math.abs( that.sizeDiff.width +
			(that._helper ?
				that.offset.left - cop.left :
				(that.offset.left - co.left)) );

		hoset = Math.abs( that.sizeDiff.height +
			(that._helper ?
				that.offset.top - cop.top :
				(that.offset.top - co.top)) );

		if ( woset + that.size.width >= that.parentData.width ) {
			that.size.width = that.parentData.width - woset;
			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
		}

		if ( hoset + that.size.height >= that.parentData.height ) {
			that.size.height = that.parentData.height - hoset;
			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
		}

		if ( !continueResize ) {
			that.position.left = that.prevPosition.left;
			that.position.top = that.prevPosition.top;
			that.size.width = that.prevSize.width;
			that.size.height = that.prevSize.height;
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $( that.helper ),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
			$( this ).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});
		}

		if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
			$( this ).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});
		}
	}
});

$.ui.plugin.add("resizable", "alsoResize", {

	start: function() {
		var that = $(this).resizable( "instance" ),
			o = that.options;

		$(o.alsoResize).each(function() {
			var el = $(this);
			el.data("ui-resizable-alsoresize", {
				width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
				left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
			});
		});
	},

	resize: function(event, ui) {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0,
				width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0,
				left: (that.position.left - op.left) || 0
			};

			$(o.alsoResize).each(function() {
				var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
					css = el.parents(ui.originalElement[0]).length ?
							[ "width", "height" ] :
							[ "width", "height", "top", "left" ];

				$.each(css, function(i, prop) {
					var sum = (start[prop] || 0) + (delta[prop] || 0);
					if (sum && sum >= 0) {
						style[prop] = sum || null;
					}
				});

				el.css(style);
			});
	},

	stop: function() {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function() {

		var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({
				opacity: 0.25,
				display: "block",
				position: "relative",
				height: cs.height,
				width: cs.width,
				margin: 0,
				left: 0,
				top: 0
			})
			.addClass("ui-resizable-ghost")
			.addClass(typeof o.ghost === "string" ? o.ghost : "");

		that.ghost.appendTo(that.helper);

	},

	resize: function() {
		var that = $(this).resizable( "instance" );
		if (that.ghost) {
			that.ghost.css({
				position: "relative",
				height: that.size.height,
				width: that.size.width
			});
		}
	},

	stop: function() {
		var that = $(this).resizable( "instance" );
		if (that.ghost && that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function() {
		var outerDimensions,
			that = $(this).resizable( "instance" ),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
			gridX = (grid[0] || 1),
			gridY = (grid[1] || 1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
			isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
			isMinWidth = o.minWidth && (o.minWidth > newWidth),
			isMinHeight = o.minHeight && (o.minHeight > newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth += gridX;
		}
		if (isMinHeight) {
			newHeight += gridY;
		}
		if (isMaxWidth) {
			newWidth -= gridX;
		}
		if (isMaxHeight) {
			newHeight -= gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {
				outerDimensions = that._getPaddingPlusBorderDimensions( this );
			}

			if ( newHeight - gridY > 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				newHeight = gridY - outerDimensions.height;
				that.size.height = newHeight;
				that.position.top = op.top + os.height - newHeight;
			}
			if ( newWidth - gridX > 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				newWidth = gridX - outerDimensions.width;
				that.size.width = newWidth;
				that.position.left = op.left + os.width - newWidth;
			}
		}
	}

});

var resizable = $.ui.resizable;


/*!
 * jQuery UI Selectable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectable/
 */


var selectable = $.widget("ui.selectable", $.ui.mouse, {
	version: "1.11.4",
	options: {
		appendTo: "body",
		autoRefresh: true,
		distance: 0,
		filter: "*",
		tolerance: "touch",

		// callbacks
		selected: null,
		selecting: null,
		start: null,
		stop: null,
		unselected: null,
		unselecting: null
	},
	_create: function() {
		var selectees,
			that = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this),
					pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass("ui-selected"),
					selecting: $this.hasClass("ui-selecting"),
					unselecting: $this.hasClass("ui-unselecting")
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	_destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled");
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this,
			options = this.options;

		this.opos = [ event.pageX, event.pageY ];

		if (this.options.disabled) {
			return;
		}

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.pageX,
			"top": event.pageY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(".ui-selected").each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass("ui-selected");
				selectee.selected = false;
				selectee.$element.addClass("ui-unselecting");
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().addBack().each(function() {
			var doSelect,
				selectee = $.data(this, "selectable-item");
			if (selectee) {
				doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {

		this.dragged = true;

		if (this.options.disabled) {
			return;
		}

		var tmp,
			that = this,
			options = this.options,
			x1 = this.opos[0],
			y1 = this.opos[1],
			x2 = event.pageX,
			y2 = event.pageY;

		if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item"),
				hit = false;

			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element === that.element[0]) {
				return;
			}

			if (options.tolerance === "touch") {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance === "fit") {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass("ui-unselecting");
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass("ui-selecting");
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						selectee.$element.addClass("ui-selected");
						selectee.selected = true;
					} else {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;

						selectee.$element.addClass("ui-unselecting");
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		$(".ui-unselecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-unselecting");
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$(".ui-selecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});


/*!
 * jQuery UI Sortable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/sortable/
 */


var sortable = $.widget("ui.sortable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},

	_isOverAxis: function( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	},

	_isFloating: function( item ) {
		return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
	},

	_create: function() {
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		this._setHandleClassName();

		//We're ready to go
		this.ready = true;

	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_setHandleClassName: function() {
		this.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );
		$.each( this.items, function() {
			( this.instance.options.handle ?
				this.item.find( this.instance.options.handle ) : this.item )
				.addClass( "ui-sortable-handle" );
		});
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-sortable ui-sortable-disabled" )
			.find( ".ui-sortable-handle" )
				.removeClass( "ui-sortable-handle" );
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[i].item.removeData(this.widgetName + "-item");
		}

		return this;
	},

	_mouseCapture: function(event, overrideHandle) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type === "static") {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$(event.target).parents().each(function() {
			if($.data(this, that.widgetName + "-item") === that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + "-item") === that) {
			currentItem = $(event.target);
		}

		if(!currentItem) {
			return false;
		}
		if(this.options.handle && !overrideHandle) {
			$(this.options.handle, currentItem).find("*").addBack().each(function() {
				if(this === event.target) {
					validHandle = true;
				}
			});
			if(!validHandle) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] !== this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment) {
			this._setContainment();
		}

		if( o.cursor && o.cursor !== "auto" ) { // cursor option
			body = this.document.find( "body" );

			// support: IE
			this.storedCursor = body.css( "cursor" );
			body.css( "cursor", o.cursor );

			this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) {
				this._storedOpacity = this.helper.css("opacity");
			}
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) {
				this._storedZIndex = this.helper.css("zIndex");
			}
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions) {
			this._cacheHelperProportions();
		}


		//Post "activate" events to possible containers
		if( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
				}

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				}

			} else {

				if(event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
					scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
				} else if(this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
					scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
				}

				if(event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
					scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
				} else if(this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
					scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
				}

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}

		//Rearrange
		for (i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[i];
			itemElement = item.item[0];
			intersection = this._intersectsWithPointer(item);
			if (!intersection) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items from other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this, moving items in "sub-sortables" can cause
			// the placeholder to jitter between the outer and inner container.
			if (item.instance !== this.currentContainer) {
				continue;
			}

			// cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if (itemElement !== this.currentItem[0] &&
				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
				!$.contains(this.placeholder[0], itemElement) &&
				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		//Call callbacks
		this._trigger("sort", event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			$.ui.ddmanager.drop(this, event);
		}

		if(this.options.revert) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === "x" ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
			}
			if ( !axis || axis === "y" ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
			}
			this.reverting = true;
			$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper === "original") {
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) {
				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			}
			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
				this.helper.remove();
			}

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			str = [];
		o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
			if (res) {
				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
			}
		});

		if(!str.length && o.key) {
			str.push(o.key + "=");
		}

		return str.join("&");

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			ret = [];

		o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
				x2 - (this.helperProportions.width / 2) < r && // Left Half
				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
				y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement) {
			return false;
		}

		return this.floating ?
			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this._setHandleClassName();
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if(connectWith && connected) {
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i], this.document[0]);
				for ( j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
					}
				}
			}
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

		function addItems() {
			items.push( this );
		}
		for (i = queries.length - 1; i >= 0; i--){
			queries[i][0].each( addItems );
		}

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j < list.length; j++) {
				if(list[j] === item.item[0]) {
					return false;
				}
			}
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
			connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i], this.document[0]);
				for (j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				}
			}
		}

		for (i = queries.length - 1; i >= 0; i--) {
			targetData = queries[i][1];
			_queries = queries[i][0];

			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				item = $(_queries[j]);

				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			}
		}

	},

	refreshPositions: function(fast) {

		// Determine whether items are being displayed horizontally
		this.floating = this.items.length ?
			this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
			false;

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for (i = this.items.length - 1; i >= 0; i--){
			item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
				continue;
			}

			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (i = this.containers.length - 1; i >= 0; i--){
				p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var className,
			o = that.options;

		if(!o.placeholder || o.placeholder.constructor === String) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var nodeName = that.currentItem[0].nodeName.toLowerCase(),
						element = $( "<" + nodeName + ">", that.document[0] )
							.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
							.removeClass("ui-sortable-helper");

					if ( nodeName === "tbody" ) {
						that._createTrPlaceholder(
							that.currentItem.find( "tr" ).eq( 0 ),
							$( "<tr>", that.document[ 0 ] ).appendTo( element )
						);
					} else if ( nodeName === "tr" ) {
						that._createTrPlaceholder( that.currentItem, element );
					} else if ( nodeName === "img" ) {
						element.attr( "src", that.currentItem.attr( "src" ) );
					}

					if ( !className ) {
						element.css( "visibility", "hidden" );
					}

					return element;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_createTrPlaceholder: function( sourceTr, targetTr ) {
		var that = this;

		sourceTr.children().each(function() {
			$( "<td>&#160;</td>", that.document[ 0 ] )
				.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
				.appendTo( targetTr );
		});
	},

	_contactContainers: function(event) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,
			innermostContainer = null,
			innermostIndex = null;

		// get innermost container that intersects with item
		for (i = this.containers.length - 1; i >= 0; i--) {

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
				continue;
			}

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
					continue;
				}

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) {
			return;
		}

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			if (!this.containers[innermostIndex].containerCache.over) {
				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || this._isFloating(this.currentItem);
			posProperty = floating ? "left" : "top";
			sizeProperty = floating ? "width" : "height";
			axis = floating ? "clientX" : "clientY";

			for (j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
					continue;
				}
				if(this.items[j].item[0] === this.currentItem[0]) {
					continue;
				}

				cur = this.items[j].item.offset()[posProperty];
				nearBottom = false;
				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
					nearBottom = true;
				}

				if ( Math.abs( event[ axis ] - cur ) < dist ) {
					dist = Math.abs( event[ axis ] - cur );
					itemWithLeastDistance = this.items[ j ];
					this.direction = nearBottom ? "up": "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
				return;
			}

			if(this.currentContainer === this.containers[innermostIndex]) {
				if ( !this.currentContainer.containerCache.over ) {
					this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
					this.currentContainer.containerCache.over = 1;
				}
				return;
			}

			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
			this.currentContainer = this.containers[innermostIndex];

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

		//Add the helper to the DOM if that didn't happen already
		if(!helper.parents("body").length) {
			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
		}

		if(helper[0] === this.currentItem[0]) {
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
		}

		if(!helper[0].style.width || o.forceHelperSize) {
			helper.width(this.currentItem.width());
		}
		if(!helper[0].style.height || o.forceHelperSize) {
			helper.height(this.currentItem.height());
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this information
		// with an ugly IE fix
		if( this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if(o.containment === "parent") {
			o.containment = this.helper[0].parentNode;
		}
		if(o.containment === "document" || o.containment === "window") {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,
				(o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
			];
		}

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			ce = $(o.containment)[0];
			co = $(o.containment).offset();
			over = ($(ce).css("overflow") !== "hidden");

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) {
					pageX = this.containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < this.containment[1]) {
					pageY = this.containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > this.containment[2]) {
					pageX = this.containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > this.containment[3]) {
					pageY = this.containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																// The absolute mouse position
				this.offset.click.top -													// Click offset (relative to the element)
				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX -																// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter === this.counter) {
				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
			}
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) {
			this.placeholder.before(this.currentItem);
		}
		this._noFinalSort = null;

		if(this.helper[0] === this.currentItem[0]) {
			for(i in this._storedCSS) {
				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
					this._storedCSS[i] = "";
				}
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		}
		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		function delayEvent( type, instance, container ) {
			return function( event ) {
				container._trigger( type, event, instance._uiHash( instance ) );
			};
		}
		for (i = this.containers.length - 1; i >= 0; i--){
			if (!noPropagation) {
				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
			}
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this.storedCursor ) {
			this.document.find( "body" ).css( "cursor", this.storedCursor );
			this.storedStylesheet.remove();
		}
		if(this._storedOpacity) {
			this.helper.css("opacity", this._storedOpacity);
		}
		if(this._storedZIndex) {
			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
		}

		this.dragging = false;

		if(!noPropagation) {
			this._trigger("beforeStop", event, this._uiHash());
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if ( !this.cancelHelperRemoval ) {
			if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
				this.helper.remove();
			}
			this.helper = null;
		}

		if(!noPropagation) {
			for (i=0; i < delayedTriggers.length; i++) {
				delayedTriggers[i].call(this, event);
			} //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return !this.cancelHelperRemoval;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});


/*!
 * jQuery UI Accordion 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 */


var accordion = $.widget( "ui.accordion", {
	version: "1.11.4",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	hideProps: {
		borderTopWidth: "hide",
		borderBottomWidth: "hide",
		paddingTop: "hide",
		paddingBottom: "hide",
		height: "hide"
	},

	showProps: {
		borderTopWidth: "show",
		borderBottomWidth: "show",
		paddingTop: "show",
		paddingBottom: "show",
		height: "show"
	},

	_create: function() {
		var options = this.options;
		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
			// ARIA
			.attr( "role", "tablist" );

		// don't allow collapsible: false and active: false / null
		if ( !options.collapsible && (options.active === false || options.active == null) ) {
			options.active = 0;
		}

		this._processPanels();
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this._refresh();
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			panel: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-state-default " +
				"ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom " +
				"ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeUniqueId();

		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown: function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var options = this.options;
		this._processPanels();

		// was collapsed or no panel
		if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
			options.active = false;
			this.active = $();
		// active false only when collapsible is true
		} else if ( options.active === false ) {
			this._activate( 0 );
		// was active, but active panel is gone
		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			// all remaining panel are disabled
			if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
				options.active = false;
				this.active = $();
			// activate previous panel
			} else {
				this._activate( Math.max( 0, options.active - 1 ) );
			}
		// was active, active panel still exists
		} else {
			// make sure active index is correct
			options.active = this.headers.index( this.active );
		}

		this._destroyIcons();

		this._refresh();
	},

	_processPanels: function() {
		var prevHeaders = this.headers,
			prevPanels = this.panels;

		this.headers = this.element.find( this.options.header )
			.addClass( "ui-accordion-header ui-state-default ui-corner-all" );

		this.panels = this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.filter( ":not(.ui-accordion-content-active)" )
			.hide();

		// Avoid memory leaks (#10056)
		if ( prevPanels ) {
			this._off( prevHeaders.not( this.headers ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	_refresh: function() {
		var maxHeight,
			options = this.options,
			heightStyle = options.heightStyle,
			parent = this.element.parent();

		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
			.removeClass( "ui-corner-all" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this.headers
			.attr( "role", "tab" )
			.each(function() {
				var header = $( this ),
					headerId = header.uniqueId().attr( "id" ),
					panel = header.next(),
					panelId = panel.uniqueId().attr( "id" );
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				"aria-expanded": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-hidden": "false"
				});
		}

		this._createIcons();

		this._setupEvents( options.event );

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {
			keydown: "_keydown"
		};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.headers.add( this.headers.next() ) );
		this._on( this.headers, events );
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._hoverable( this.headers );
		this._focusable( this.headers );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-hidden": "true"
		});
		toHide.prev().attr({
			"aria-selected": "false",
			"aria-expanded": "false"
		});
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr({
				"tabIndex": -1,
				"aria-expanded": "false"
			});
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr( "aria-hidden", "false" )
			.prev()
				.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			boxSizing = toShow.css( "box-sizing" ),
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( this.showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( this.hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( this.hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( this.showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						if ( boxSizing === "content-box" ) {
							adjust += fx.now;
						}
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
		}
		this._trigger( "activate", null, data );
	}
});


/*!
 * jQuery UI Menu 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 */


var menu = $.widget( "ui.menu", {
	version: "1.11.4",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-carat-1-e"
		},
		items: "> *",
		menus: "ul",
		position: {
			my: "left-1 top",
			at: "right top"
		},
		role: "menu",

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;

		// Flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.element
			.uniqueId()
			.addClass( "ui-menu ui-widget ui-widget-content" )
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			});

		if ( this.options.disabled ) {
			this.element
				.addClass( "ui-state-disabled" )
				.attr( "aria-disabled", "true" );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item": function( event ) {
				var target = $( event.target );
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					this.select( event );

					// Only set the mouseHandled flag if the event will bubble, see #9469.
					if ( !event.isPropagationStopped() ) {
						this.mouseHandled = true;
					}

					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {

						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {
				// Ignore mouse events while typeahead is active, see #10458.
				// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
				// is over an item in the menu
				if ( this.previousFilter ) {
					return;
				}
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings( ".ui-state-active" ).removeClass( "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {
				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.find( this.options.items ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: "_keydown"
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( this._closeOnDocumentClick( event ) ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).addBack()
				.removeClass( "ui-menu ui-widget ui-widget-content ui-menu-icons ui-front" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeAttr( "aria-labelledby" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( ".ui-menu-item" )
			.removeClass( "ui-menu-item" )
			.removeAttr( "role" )
			.removeAttr( "aria-disabled" )
			.removeUniqueId()
			.removeClass( "ui-state-hover" )
			.removeAttr( "tabIndex" )
			.removeAttr( "role" )
			.removeAttr( "aria-haspopup" )
			.children().each( function() {
				var elem = $( this );
				if ( elem.data( "ui-menu-submenu-carat" ) ) {
					elem.remove();
				}
			});

		// Destroy menu dividers
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
	},

	_keydown: function( event ) {
		var match, prev, character, skip,
			preventDefault = true;

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			match = this._filterMenuItems( character );
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				match = this._filterMenuItems( character );
			}

			if ( match.length ) {
				this.focus( event, match );
				this.previousFilter = character;
				this.filterTimer = this._delay(function() {
					delete this.previousFilter;
				}, 1000 );
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.is( "[aria-haspopup='true']" ) ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus, items,
			that = this,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		this.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );

		// Initialize nested menus
		submenus.filter( ":not(.ui-menu)" )
			.addClass( "ui-menu ui-widget ui-widget-content ui-front" )
			.hide()
			.attr({
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			})
			.each(function() {
				var menu = $( this ),
					item = menu.parent(),
					submenuCarat = $( "<span>" )
						.addClass( "ui-menu-icon ui-icon " + icon )
						.data( "ui-menu-submenu-carat", true );

				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCarat );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			});

		menus = submenus.add( this.element );
		items = menus.find( this.options.items );

		// Initialize menu-items containing spaces and/or dashes only as dividers
		items.not( ".ui-menu-item" ).each(function() {
			var item = $( this );
			if ( that._isDivider( item ) ) {
				item.addClass( "ui-widget-content ui-menu-divider" );
			}
		});

		// Don't refresh list items that are already adapted
		items.not( ".ui-menu-item, .ui-menu-divider" )
			.addClass( "ui-menu-item" )
			.uniqueId()
			.attr({
				tabIndex: -1,
				role: this._itemRole()
			});

		// Add aria-disabled attribute to any disabled menu item
		items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			this.element.find( ".ui-menu-icon" )
				.removeClass( this.options.icons.submenu )
				.addClass( value.submenu );
		}
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
		}
		this._super( key, value );
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.addClass( "ui-state-focus" ).removeClass( "ui-state-active" );
		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( ".ui-menu-item" )
			.addClass( "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.outerHeight();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.removeClass( "ui-state-focus" );
		this.active = null;

		this._trigger( "blur", event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" )
			.end()
			.find( ".ui-state-active" ).not( ".ui-state-focus" )
				.removeClass( "ui-state-active" );
	},

	_closeOnDocumentClick: function( event ) {
		return !$( event.target ).closest( ".ui-menu" ).length;
	},

	_isDivider: function( item ) {

		// Match hyphen, em dash, en dash
		return !/[^\-\u2014\u2013\s]/.test( item.text() );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
				.find( this.options.items )
				.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.find( this.options.items )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	},

	_filterMenuItems: function(character) {
		var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
			regex = new RegExp( "^" + escapedCharacter, "i" );

		return this.activeMenu
			.find( this.options.items )

			// Only match on items, not dividers or other content (#10571)
			.filter( ".ui-menu-item" )
			.filter(function() {
				return regex.test( $.trim( $( this ).text() ) );
			});
	}
});


/*!
 * jQuery UI Autocomplete 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/autocomplete/
 */


$.widget( "ui.autocomplete", {
	version: "1.11.4",
	defaultElement: "<input>",
	options: {
		appendTo: null,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	requestIndex: 0,
	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
			nodeName = this.element[ 0 ].nodeName.toLowerCase(),
			isTextarea = nodeName === "textarea",
			isInput = nodeName === "input";

		this.isMultiLine =
			// Textareas are always multi-line
			isTextarea ? true :
			// Inputs are always single-line, even if inside a contentEditable element
			// IE also treats inputs as contentEditable
			isInput ? false :
			// All other element types are determined by whether or not they're contentEditable
			this.element.prop( "isContentEditable" );

		this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
		this.isNewMenu = true;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						if ( !this.isMultiLine ) {
							this._value( this.term );
						}
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
						event.preventDefault();
					}
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( "<ul>" )
			.addClass( "ui-autocomplete ui-front" )
			.appendTo( this._appendTo() )
			.menu({
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.hide()
			.menu( "instance" );

		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( "mousedown", function( event ) {
							if ( event.target !== that.element[ 0 ] &&
									event.target !== menuElement &&
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				var label, item;
				// support: Firefox
				// Prevent accidental activation of menu items in Firefox (#7024 #9118)
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				item = ui.item.data( "ui-autocomplete-item" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				}

				// Announce the value in the liveRegion
				label = ui.item.attr( "aria-label" ) || item.value;
				if ( label && $.trim( label ).length ) {
					this.liveRegion.children().hide();
					$( "<div>" ).text( label ).appendTo( this.liveRegion );
				}
			},
			menuselect: function( event, ui ) {
				var item = ui.item.data( "ui-autocomplete-item" ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[ 0 ] !== this.document[ 0 ].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( "<span>", {
				role: "status",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.appendTo( this.document[ 0 ].body );

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this._appendTo() );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray( this.options.source ) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response([]);
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {

			// Search if the value has changed, or if the user retypes the same value (see #7434)
			var equalValues = this.term === this._value(),
				menuVisible = this.menu.element.is( ":visible" ),
				modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

			if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var index = ++this.requestIndex;

		return $.proxy(function( content ) {
			if ( index === this.requestIndex ) {
				this.__response( content );
			}

			this.pending--;
			if ( !this.pending ) {
				this.element.removeClass( "ui-autocomplete-loading" );
			}
		}, this );
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {
			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend( {}, item, {
				label: item.label || item.value,
				value: item.value || item.label
			});
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element.empty();
		this._renderMenu( ul, items );
		this.isNewMenu = true;
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ) );

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" ).text( item.label ).appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {

			if ( !this.isMultiLine ) {
				this._value( this.term );
			}

			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
	},
	filter: function( array, term ) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
		return $.grep( array, function( value ) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.children().hide();
		$( "<div>" ).text( message ).appendTo( this.liveRegion );
	}
});

var autocomplete = $.ui.autocomplete;


/*!
 * jQuery UI Button 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/button/
 */


var lastActive,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var form = $( this );
		setTimeout(function() {
			form.find( ":ui-button" ).button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			name = name.replace( /'/g, "\\'" );
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "'][type=radio]" );
			} else {
				radios = $( "[name='" + name + "'][type=radio]", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "1.11.4",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			activeClass = !toggleButton ? "ui-state-active" : "";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		// Can't use _focusable() because the element that receives focus
		// and the element that gets the ui-state-focus class are different
		this._on({
			focus: function() {
				this.buttonElement.addClass( "ui-state-focus" );
			},
			blur: function() {
				this.buttonElement.removeClass( "ui-state-focus" );
			}
		});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				that.refresh();
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return false;
				}
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				// see #8559, we bind to blur here in case the button element loses
				// focus between keydown and keyup, it would be left in an "active" state
				.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " ui-state-active " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			this.widget().toggleClass( "ui-state-disabled", !!value );
			this.element.prop( "disabled", !!value );
			if ( value ) {
				if ( this.type === "checkbox" || this.type === "radio" ) {
					this.buttonElement.removeClass( "ui-state-focus" );
				} else {
					this.buttonElement.removeClass( "ui-state-focus ui-state-active" );
				}
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 & #8828
		var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "1.11.4",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl",
			allButtons = this.element.find( this.options.items ),
			existingButtons = allButtons.filter( ":ui-button" );

		// Initialize new buttons
		allButtons.not( ":ui-button" ).button();

		// Refresh existing buttons
		existingButtons.button( "refresh" );

		this.buttons = allButtons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

var button = $.ui.button;


/*!
 * jQuery UI Datepicker 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 */


$.extend($.ui, { datepicker: { version: "1.11.4" } });

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {
		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {
			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.regional.en = $.extend( true, {}, this.regional[ "" ]);
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		datepicker_extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, "datepicker", inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, "datepicker", inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], "datepicker", inst);
		}
		datepicker_extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], "datepicker", inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, "datepicker");
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}

		if ( datepicker_instActive === inst ) {
			datepicker_instActive = null;
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, "datepicker");
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			datepicker_extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		datepicker_extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17,
			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );

		if ( activeCell.length > 0 ) {
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );
		}

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, "datepicker"))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					minSize = (match === "y" ? size : 1),
					digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate( selector, "mouseover", datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
	if (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
		$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
		$(this).addClass("ui-state-hover");
		if (this.className.indexOf("ui-datepicker-prev") !== -1) {
			$(this).addClass("ui-datepicker-prev-hover");
		}
		if (this.className.indexOf("ui-datepicker-next") !== -1) {
			$(this).addClass("ui-datepicker-next-hover");
		}
	}
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.11.4";

var datepicker = $.datepicker;


/*!
 * jQuery UI Dialog 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/dialog/
 */


var dialog = $.widget( "ui.dialog", {
	version: "1.11.4",
	options: {
		appendTo: "body",
		autoOpen: true,
		buttons: [],
		closeOnEscape: true,
		closeText: "Close",
		dialogClass: "",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: null,
		maxWidth: null,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",
			// Ensure the titlebar is always visible
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		title: null,
		width: 300,

		// callbacks
		beforeClose: null,
		close: null,
		drag: null,
		dragStart: null,
		dragStop: null,
		focus: null,
		open: null,
		resize: null,
		resizeStart: null,
		resizeStop: null
	},

	sizeRelatedOptions: {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},

	resizableRelatedOptions: {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},

	_create: function() {
		this.originalCss = {
			display: this.element[ 0 ].style.display,
			width: this.element[ 0 ].style.width,
			minHeight: this.element[ 0 ].style.minHeight,
			maxHeight: this.element[ 0 ].style.maxHeight,
			height: this.element[ 0 ].style.height
		};
		this.originalPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.originalTitle = this.element.attr( "title" );
		this.options.title = this.options.title || this.originalTitle;

		this._createWrapper();

		this.element
			.show()
			.removeAttr( "title" )
			.addClass( "ui-dialog-content ui-widget-content" )
			.appendTo( this.uiDialog );

		this._createTitlebar();
		this._createButtonPane();

		if ( this.options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( this.options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._isOpen = false;

		this._trackFocus();
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;
		if ( element && (element.jquery || element.nodeType) ) {
			return $( element );
		}
		return this.document.find( element || "body" ).eq( 0 );
	},

	_destroy: function() {
		var next,
			originalPosition = this.originalPosition;

		this._untrackInstance();
		this._destroyOverlay();

		this.element
			.removeUniqueId()
			.removeClass( "ui-dialog-content ui-widget-content" )
			.css( this.originalCss )
			// Without detaching first, the following becomes really slow
			.detach();

		this.uiDialog.stop( true, true ).remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = originalPosition.parent.children().eq( originalPosition.index );
		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			originalPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	close: function( event ) {
		var activeElement,
			that = this;

		if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
			return;
		}

		this._isOpen = false;
		this._focusedElement = null;
		this._destroyOverlay();
		this._untrackInstance();

		if ( !this.opener.filter( ":focusable" ).focus().length ) {

			// support: IE9
			// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
			try {
				activeElement = this.document[ 0 ].activeElement;

				// Support: IE9, IE10
				// If the <body> is blurred, IE will switch windows, see #4520
				if ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {

					// Hiding a focused element doesn't trigger blur in WebKit
					// so in case we have nothing to focus on, explicitly blur the active element
					// https://bugs.webkit.org/show_bug.cgi?id=47182
					$( activeElement ).blur();
				}
			} catch ( error ) {}
		}

		this._hide( this.uiDialog, this.options.hide, function() {
			that._trigger( "close", event );
		});
	},

	isOpen: function() {
		return this._isOpen;
	},

	moveToTop: function() {
		this._moveToTop();
	},

	_moveToTop: function( event, silent ) {
		var moved = false,
			zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map(function() {
				return +$( this ).css( "z-index" );
			}).get(),
			zIndexMax = Math.max.apply( null, zIndices );

		if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
			this.uiDialog.css( "z-index", zIndexMax + 1 );
			moved = true;
		}

		if ( moved && !silent ) {
			this._trigger( "focus", event );
		}
		return moved;
	},

	open: function() {
		var that = this;
		if ( this._isOpen ) {
			if ( this._moveToTop() ) {
				this._focusTabbable();
			}
			return;
		}

		this._isOpen = true;
		this.opener = $( this.document[ 0 ].activeElement );

		this._size();
		this._position();
		this._createOverlay();
		this._moveToTop( null, true );

		// Ensure the overlay is moved to the top with the dialog, but only when
		// opening. The overlay shouldn't move after the dialog is open so that
		// modeless dialogs opened after the modal dialog stack properly.
		if ( this.overlay ) {
			this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
		}

		this._show( this.uiDialog, this.options.show, function() {
			that._focusTabbable();
			that._trigger( "focus" );
		});

		// Track the dialog immediately upon openening in case a focus event
		// somehow occurs outside of the dialog before an element inside the
		// dialog is focused (#10152)
		this._makeFocusTarget();

		this._trigger( "open" );
	},

	_focusTabbable: function() {
		// Set focus to the first match:
		// 1. An element that was focused previously
		// 2. First element inside the dialog matching [autofocus]
		// 3. Tabbable element inside the content element
		// 4. Tabbable element inside the buttonpane
		// 5. The close button
		// 6. The dialog itself
		var hasFocus = this._focusedElement;
		if ( !hasFocus ) {
			hasFocus = this.element.find( "[autofocus]" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.element.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialog;
		}
		hasFocus.eq( 0 ).focus();
	},

	_keepFocus: function( event ) {
		function checkFocus() {
			var activeElement = this.document[0].activeElement,
				isActive = this.uiDialog[0] === activeElement ||
					$.contains( this.uiDialog[0], activeElement );
			if ( !isActive ) {
				this._focusTabbable();
			}
		}
		event.preventDefault();
		checkFocus.call( this );
		// support: IE
		// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
		// so we check again later
		this._delay( checkFocus );
	},

	_createWrapper: function() {
		this.uiDialog = $("<div>")
			.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
				this.options.dialogClass )
			.hide()
			.attr({
				// Setting tabIndex makes the div focusable
				tabIndex: -1,
				role: "dialog"
			})
			.appendTo( this._appendTo() );

		this._on( this.uiDialog, {
			keydown: function( event ) {
				if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE ) {
					event.preventDefault();
					this.close( event );
					return;
				}

				// prevent tabbing out of dialogs
				if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
					return;
				}
				var tabbables = this.uiDialog.find( ":tabbable" ),
					first = tabbables.filter( ":first" ),
					last = tabbables.filter( ":last" );

				if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
					this._delay(function() {
						first.focus();
					});
					event.preventDefault();
				} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
					this._delay(function() {
						last.focus();
					});
					event.preventDefault();
				}
			},
			mousedown: function( event ) {
				if ( this._moveToTop( event ) ) {
					this._focusTabbable();
				}
			}
		});

		// We assume that any existing aria-describedby attribute means
		// that the dialog content is marked up properly
		// otherwise we brute force the content as the description
		if ( !this.element.find( "[aria-describedby]" ).length ) {
			this.uiDialog.attr({
				"aria-describedby": this.element.uniqueId().attr( "id" )
			});
		}
	},

	_createTitlebar: function() {
		var uiDialogTitle;

		this.uiDialogTitlebar = $( "<div>" )
			.addClass( "ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix" )
			.prependTo( this.uiDialog );
		this._on( this.uiDialogTitlebar, {
			mousedown: function( event ) {
				// Don't prevent click on close button (#8838)
				// Focusing a dialog that is partially scrolled out of view
				// causes the browser to scroll it into view, preventing the click event
				if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {
					// Dialog isn't getting focus when dragging (#8063)
					this.uiDialog.focus();
				}
			}
		});

		// support: IE
		// Use type="button" to prevent enter keypresses in textboxes from closing the
		// dialog in IE (#9312)
		this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
			.button({
				label: this.options.closeText,
				icons: {
					primary: "ui-icon-closethick"
				},
				text: false
			})
			.addClass( "ui-dialog-titlebar-close" )
			.appendTo( this.uiDialogTitlebar );
		this._on( this.uiDialogTitlebarClose, {
			click: function( event ) {
				event.preventDefault();
				this.close( event );
			}
		});

		uiDialogTitle = $( "<span>" )
			.uniqueId()
			.addClass( "ui-dialog-title" )
			.prependTo( this.uiDialogTitlebar );
		this._title( uiDialogTitle );

		this.uiDialog.attr({
			"aria-labelledby": uiDialogTitle.attr( "id" )
		});
	},

	_title: function( title ) {
		if ( !this.options.title ) {
			title.html( "&#160;" );
		}
		title.text( this.options.title );
	},

	_createButtonPane: function() {
		this.uiDialogButtonPane = $( "<div>" )
			.addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" );

		this.uiButtonSet = $( "<div>" )
			.addClass( "ui-dialog-buttonset" )
			.appendTo( this.uiDialogButtonPane );

		this._createButtons();
	},

	_createButtons: function() {
		var that = this,
			buttons = this.options.buttons;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
			this.uiDialog.removeClass( "ui-dialog-buttons" );
			return;
		}

		$.each( buttons, function( name, props ) {
			var click, buttonOptions;
			props = $.isFunction( props ) ?
				{ click: props, text: name } :
				props;
			// Default to a non-submitting button
			props = $.extend( { type: "button" }, props );
			// Change the context for the click callback to be the main element
			click = props.click;
			props.click = function() {
				click.apply( that.element[ 0 ], arguments );
			};
			buttonOptions = {
				icons: props.icons,
				text: props.showText
			};
			delete props.icons;
			delete props.showText;
			$( "<button></button>", props )
				.button( buttonOptions )
				.appendTo( that.uiButtonSet );
		});
		this.uiDialog.addClass( "ui-dialog-buttons" );
		this.uiDialogButtonPane.appendTo( this.uiDialog );
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-dragging" );
				that._blockFrames();
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var left = ui.offset.left - that.document.scrollLeft(),
					top = ui.offset.top - that.document.scrollTop();

				options.position = {
					my: "left top",
					at: "left" + (left >= 0 ? "+" : "") + left + " " +
						"top" + (top >= 0 ? "+" : "") + top,
					of: that.window
				};
				$( this ).removeClass( "ui-dialog-dragging" );
				that._unblockFrames();
				that._trigger( "dragStop", event, filteredUi( ui ) );
			}
		});
	},

	_makeResizable: function() {
		var that = this,
			options = this.options,
			handles = options.resizable,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css("position"),
			resizeHandles = typeof handles === "string" ?
				handles	:
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-resizing" );
				that._blockFrames();
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var offset = that.uiDialog.offset(),
					left = offset.left - that.document.scrollLeft(),
					top = offset.top - that.document.scrollTop();

				options.height = that.uiDialog.height();
				options.width = that.uiDialog.width();
				options.position = {
					my: "left top",
					at: "left" + (left >= 0 ? "+" : "") + left + " " +
						"top" + (top >= 0 ? "+" : "") + top,
					of: that.window
				};
				$( this ).removeClass( "ui-dialog-resizing" );
				that._unblockFrames();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
			}
		})
		.css( "position", position );
	},

	_trackFocus: function() {
		this._on( this.widget(), {
			focusin: function( event ) {
				this._makeFocusTarget();
				this._focusedElement = $( event.target );
			}
		});
	},

	_makeFocusTarget: function() {
		this._untrackInstance();
		this._trackingInstances().unshift( this );
	},

	_untrackInstance: function() {
		var instances = this._trackingInstances(),
			exists = $.inArray( this, instances );
		if ( exists !== -1 ) {
			instances.splice( exists, 1 );
		}
	},

	_trackingInstances: function() {
		var instances = this.document.data( "ui-dialog-instances" );
		if ( !instances ) {
			instances = [];
			this.document.data( "ui-dialog-instances", instances );
		}
		return instances;
	},

	_minHeight: function() {
		var options = this.options;

		return options.height === "auto" ?
			options.minHeight :
			Math.min( options.minHeight, options.height );
	},

	_position: function() {
		// Need to show the dialog to get the actual offset in the position plugin
		var isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( this.options.position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resize = false,
			resizableOptions = {};

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in that.sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in that.resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
			this._position();
		}
		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		if ( key === "dialogClass" ) {
			uiDialog
				.removeClass( this.options.dialogClass )
				.addClass( value );
		}

		if ( key === "disabled" ) {
			return;
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.uiDialog.appendTo( this._appendTo() );
		}

		if ( key === "buttons" ) {
			this._createButtons();
		}

		if ( key === "closeText" ) {
			this.uiDialogTitlebarClose.button({
				// Ensure that we always pass a string
				label: "" + value
			});
		}

		if ( key === "draggable" ) {
			isDraggable = uiDialog.is( ":data(ui-draggable)" );
			if ( isDraggable && !value ) {
				uiDialog.draggable( "destroy" );
			}

			if ( !isDraggable && value ) {
				this._makeDraggable();
			}
		}

		if ( key === "position" ) {
			this._position();
		}

		if ( key === "resizable" ) {
			// currently resizable, becoming non-resizable
			isResizable = uiDialog.is( ":data(ui-resizable)" );
			if ( isResizable && !value ) {
				uiDialog.resizable( "destroy" );
			}

			// currently resizable, changing handles
			if ( isResizable && typeof value === "string" ) {
				uiDialog.resizable( "option", "handles", value );
			}

			// currently non-resizable, becoming resizable
			if ( !isResizable && value !== false ) {
				this._makeResizable();
			}
		}

		if ( key === "title" ) {
			this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
		}
	},

	_size: function() {
		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		// divs will both have width and height set, so we need to reset them
		var nonContentHeight, minContentHeight, maxContentHeight,
			options = this.options;

		// Reset content sizing
		this.element.show().css({
			width: "auto",
			minHeight: 0,
			maxHeight: "none",
			height: 0
		});

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: "auto",
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		maxContentHeight = typeof options.maxHeight === "number" ?
			Math.max( 0, options.maxHeight - nonContentHeight ) :
			"none";

		if ( options.height === "auto" ) {
			this.element.css({
				minHeight: minContentHeight,
				maxHeight: maxContentHeight,
				height: "auto"
			});
		} else {
			this.element.height( Math.max( 0, options.height - nonContentHeight ) );
		}

		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	},

	_blockFrames: function() {
		this.iframeBlocks = this.document.find( "iframe" ).map(function() {
			var iframe = $( this );

			return $( "<div>" )
				.css({
					position: "absolute",
					width: iframe.outerWidth(),
					height: iframe.outerHeight()
				})
				.appendTo( iframe.parent() )
				.offset( iframe.offset() )[0];
		});
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_allowInteraction: function( event ) {
		if ( $( event.target ).closest( ".ui-dialog" ).length ) {
			return true;
		}

		// TODO: Remove hack when datepicker implements
		// the .ui-front logic (#8989)
		return !!$( event.target ).closest( ".ui-datepicker" ).length;
	},

	_createOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		// We use a delay in case the overlay is created from an
		// event that we're going to be cancelling (#2804)
		var isOpening = true;
		this._delay(function() {
			isOpening = false;
		});

		if ( !this.document.data( "ui-dialog-overlays" ) ) {

			// Prevent use of anchors and inputs
			// Using _on() for an event handler shared across many instances is
			// safe because the dialogs stack and must be closed in reverse order
			this._on( this.document, {
				focusin: function( event ) {
					if ( isOpening ) {
						return;
					}

					if ( !this._allowInteraction( event ) ) {
						event.preventDefault();
						this._trackingInstances()[ 0 ]._focusTabbable();
					}
				}
			});
		}

		this.overlay = $( "<div>" )
			.addClass( "ui-widget-overlay ui-front" )
			.appendTo( this._appendTo() );
		this._on( this.overlay, {
			mousedown: "_keepFocus"
		});
		this.document.data( "ui-dialog-overlays",
			(this.document.data( "ui-dialog-overlays" ) || 0) + 1 );
	},

	_destroyOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		if ( this.overlay ) {
			var overlays = this.document.data( "ui-dialog-overlays" ) - 1;

			if ( !overlays ) {
				this.document
					.unbind( "focusin" )
					.removeData( "ui-dialog-overlays" );
			} else {
				this.document.data( "ui-dialog-overlays", overlays );
			}

			this.overlay.remove();
			this.overlay = null;
		}
	}
});


/*!
 * jQuery UI Progressbar 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/progressbar/
 */


var progressbar = $.widget( "ui.progressbar", {
	version: "1.11.4",
	options: {
		max: 100,
		value: 0,

		change: null,
		complete: null
	},

	min: 0,

	_create: function() {
		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				// Only set static values, aria-valuenow and aria-valuemax are
				// set inside _refreshValue()
				role: "progressbar",
				"aria-valuemin": this.min
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );
		this._refreshValue();
	},

	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}

		this.indeterminate = newValue === false;

		// sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = 0;
		}

		return this.indeterminate ? false :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},

	_setOptions: function( options ) {
		// Ensure "value" option is set after other values (like max)
		var value = options.value;
		delete options.value;

		this._super( options );

		this.options.value = this._constrainedValue( value );
		this._refreshValue();
	},

	_setOption: function( key, value ) {
		if ( key === "max" ) {
			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
		}
		this._super( key, value );
	},

	_percentage: function() {
		return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this.indeterminate || value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );

		this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );

		if ( this.indeterminate ) {
			this.element.removeAttr( "aria-valuenow" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
			}
		} else {
			this.element.attr({
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			});
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}
		if ( value === this.options.max ) {
			this._trigger( "complete" );
		}
	}
});


/*!
 * jQuery UI Selectmenu 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectmenu
 */


var selectmenu = $.widget( "ui.selectmenu", {
	version: "1.11.4",
	defaultElement: "<select>",
	options: {
		appendTo: null,
		disabled: null,
		icons: {
			button: "ui-icon-triangle-1-s"
		},
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		width: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		select: null
	},

	_create: function() {
		var selectmenuId = this.element.uniqueId().attr( "id" );
		this.ids = {
			element: selectmenuId,
			button: selectmenuId + "-button",
			menu: selectmenuId + "-menu"
		};

		this._drawButton();
		this._drawMenu();

		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_drawButton: function() {
		var that = this;

		// Associate existing label with the new button
		this.label = $( "label[for='" + this.ids.element + "']" ).attr( "for", this.ids.button );
		this._on( this.label, {
			click: function( event ) {
				this.button.focus();
				event.preventDefault();
			}
		});

		// Hide original select element
		this.element.hide();

		// Create button
		this.button = $( "<span>", {
			"class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
			tabindex: this.options.disabled ? -1 : 0,
			id: this.ids.button,
			role: "combobox",
			"aria-expanded": "false",
			"aria-autocomplete": "list",
			"aria-owns": this.ids.menu,
			"aria-haspopup": "true"
		})
			.insertAfter( this.element );

		$( "<span>", {
			"class": "ui-icon " + this.options.icons.button
		})
			.prependTo( this.button );

		this.buttonText = $( "<span>", {
			"class": "ui-selectmenu-text"
		})
			.appendTo( this.button );

		this._setText( this.buttonText, this.element.find( "option:selected" ).text() );
		this._resizeButton();

		this._on( this.button, this._buttonEvents );
		this.button.one( "focusin", function() {

			// Delay rendering the menu items until the button receives focus.
			// The menu may have already been rendered via a programmatic open.
			if ( !that.menuItems ) {
				that._refreshMenu();
			}
		});
		this._hoverable( this.button );
		this._focusable( this.button );
	},

	_drawMenu: function() {
		var that = this;

		// Create menu
		this.menu = $( "<ul>", {
			"aria-hidden": "true",
			"aria-labelledby": this.ids.button,
			id: this.ids.menu
		});

		// Wrap menu
		this.menuWrap = $( "<div>", {
			"class": "ui-selectmenu-menu ui-front"
		})
			.append( this.menu )
			.appendTo( this._appendTo() );

		// Initialize menu widget
		this.menuInstance = this.menu
			.menu({
				role: "listbox",
				select: function( event, ui ) {
					event.preventDefault();

					// support: IE8
					// If the item was selected via a click, the text selection
					// will be destroyed in IE
					that._setSelection();

					that._select( ui.item.data( "ui-selectmenu-item" ), event );
				},
				focus: function( event, ui ) {
					var item = ui.item.data( "ui-selectmenu-item" );

					// Prevent inital focus from firing and check if its a newly focused item
					if ( that.focusIndex != null && item.index !== that.focusIndex ) {
						that._trigger( "focus", event, { item: item } );
						if ( !that.isOpen ) {
							that._select( item, event );
						}
					}
					that.focusIndex = item.index;

					that.button.attr( "aria-activedescendant",
						that.menuItems.eq( item.index ).attr( "id" ) );
				}
			})
			.menu( "instance" );

		// Adjust menu styles to dropdown
		this.menu
			.addClass( "ui-corner-bottom" )
			.removeClass( "ui-corner-all" );

		// Don't close the menu on mouseleave
		this.menuInstance._off( this.menu, "mouseleave" );

		// Cancel the menu's collapseAll on document click
		this.menuInstance._closeOnDocumentClick = function() {
			return false;
		};

		// Selects often contain empty items, but never contain dividers
		this.menuInstance._isDivider = function() {
			return false;
		};
	},

	refresh: function() {
		this._refreshMenu();
		this._setText( this.buttonText, this._getSelectedItem().text() );
		if ( !this.options.width ) {
			this._resizeButton();
		}
	},

	_refreshMenu: function() {
		this.menu.empty();

		var item,
			options = this.element.find( "option" );

		if ( !options.length ) {
			return;
		}

		this._parseOptions( options );
		this._renderMenu( this.menu, this.items );

		this.menuInstance.refresh();
		this.menuItems = this.menu.find( "li" ).not( ".ui-selectmenu-optgroup" );

		item = this._getSelectedItem();

		// Update the menu to have the correct item focused
		this.menuInstance.focus( null, item );
		this._setAria( item.data( "ui-selectmenu-item" ) );

		// Set disabled state
		this._setOption( "disabled", this.element.prop( "disabled" ) );
	},

	open: function( event ) {
		if ( this.options.disabled ) {
			return;
		}

		// If this is the first time the menu is being opened, render the items
		if ( !this.menuItems ) {
			this._refreshMenu();
		} else {

			// Menu clears focus on close, reset focus to selected item
			this.menu.find( ".ui-state-focus" ).removeClass( "ui-state-focus" );
			this.menuInstance.focus( null, this._getSelectedItem() );
		}

		this.isOpen = true;
		this._toggleAttr();
		this._resizeMenu();
		this._position();

		this._on( this.document, this._documentClick );

		this._trigger( "open", event );
	},

	_position: function() {
		this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
	},

	close: function( event ) {
		if ( !this.isOpen ) {
			return;
		}

		this.isOpen = false;
		this._toggleAttr();

		this.range = null;
		this._off( this.document );

		this._trigger( "close", event );
	},

	widget: function() {
		return this.button;
	},

	menuWidget: function() {
		return this.menu;
	},

	_renderMenu: function( ul, items ) {
		var that = this,
			currentOptgroup = "";

		$.each( items, function( index, item ) {
			if ( item.optgroup !== currentOptgroup ) {
				$( "<li>", {
					"class": "ui-selectmenu-optgroup ui-menu-divider" +
						( item.element.parent( "optgroup" ).prop( "disabled" ) ?
							" ui-state-disabled" :
							"" ),
					text: item.optgroup
				})
					.appendTo( ul );

				currentOptgroup = item.optgroup;
			}

			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
	},

	_renderItem: function( ul, item ) {
		var li = $( "<li>" );

		if ( item.disabled ) {
			li.addClass( "ui-state-disabled" );
		}
		this._setText( li, item.label );

		return li.appendTo( ul );
	},

	_setText: function( element, value ) {
		if ( value ) {
			element.text( value );
		} else {
			element.html( "&#160;" );
		}
	},

	_move: function( direction, event ) {
		var item, next,
			filter = ".ui-menu-item";

		if ( this.isOpen ) {
			item = this.menuItems.eq( this.focusIndex );
		} else {
			item = this.menuItems.eq( this.element[ 0 ].selectedIndex );
			filter += ":not(.ui-state-disabled)";
		}

		if ( direction === "first" || direction === "last" ) {
			next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
		} else {
			next = item[ direction + "All" ]( filter ).eq( 0 );
		}

		if ( next.length ) {
			this.menuInstance.focus( event, next );
		}
	},

	_getSelectedItem: function() {
		return this.menuItems.eq( this.element[ 0 ].selectedIndex );
	},

	_toggle: function( event ) {
		this[ this.isOpen ? "close" : "open" ]( event );
	},

	_setSelection: function() {
		var selection;

		if ( !this.range ) {
			return;
		}

		if ( window.getSelection ) {
			selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange( this.range );

		// support: IE8
		} else {
			this.range.select();
		}

		// support: IE
		// Setting the text selection kills the button focus in IE, but
		// restoring the focus doesn't kill the selection.
		this.button.focus();
	},

	_documentClick: {
		mousedown: function( event ) {
			if ( !this.isOpen ) {
				return;
			}

			if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" + this.ids.button ).length ) {
				this.close( event );
			}
		}
	},

	_buttonEvents: {

		// Prevent text selection from being reset when interacting with the selectmenu (#10144)
		mousedown: function() {
			var selection;

			if ( window.getSelection ) {
				selection = window.getSelection();
				if ( selection.rangeCount ) {
					this.range = selection.getRangeAt( 0 );
				}

			// support: IE8
			} else {
				this.range = document.selection.createRange();
			}
		},

		click: function( event ) {
			this._setSelection();
			this._toggle( event );
		},

		keydown: function( event ) {
			var preventDefault = true;
			switch ( event.keyCode ) {
				case $.ui.keyCode.TAB:
				case $.ui.keyCode.ESCAPE:
					this.close( event );
					preventDefault = false;
					break;
				case $.ui.keyCode.ENTER:
					if ( this.isOpen ) {
						this._selectFocusedItem( event );
					}
					break;
				case $.ui.keyCode.UP:
					if ( event.altKey ) {
						this._toggle( event );
					} else {
						this._move( "prev", event );
					}
					break;
				case $.ui.keyCode.DOWN:
					if ( event.altKey ) {
						this._toggle( event );
					} else {
						this._move( "next", event );
					}
					break;
				case $.ui.keyCode.SPACE:
					if ( this.isOpen ) {
						this._selectFocusedItem( event );
					} else {
						this._toggle( event );
					}
					break;
				case $.ui.keyCode.LEFT:
					this._move( "prev", event );
					break;
				case $.ui.keyCode.RIGHT:
					this._move( "next", event );
					break;
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.PAGE_UP:
					this._move( "first", event );
					break;
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_DOWN:
					this._move( "last", event );
					break;
				default:
					this.menu.trigger( event );
					preventDefault = false;
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		}
	},

	_selectFocusedItem: function( event ) {
		var item = this.menuItems.eq( this.focusIndex );
		if ( !item.hasClass( "ui-state-disabled" ) ) {
			this._select( item.data( "ui-selectmenu-item" ), event );
		}
	},

	_select: function( item, event ) {
		var oldIndex = this.element[ 0 ].selectedIndex;

		// Change native select element
		this.element[ 0 ].selectedIndex = item.index;
		this._setText( this.buttonText, item.label );
		this._setAria( item );
		this._trigger( "select", event, { item: item } );

		if ( item.index !== oldIndex ) {
			this._trigger( "change", event, { item: item } );
		}

		this.close( event );
	},

	_setAria: function( item ) {
		var id = this.menuItems.eq( item.index ).attr( "id" );

		this.button.attr({
			"aria-labelledby": id,
			"aria-activedescendant": id
		});
		this.menu.attr( "aria-activedescendant", id );
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			this.button.find( "span.ui-icon" )
				.removeClass( this.options.icons.button )
				.addClass( value.button );
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.menuWrap.appendTo( this._appendTo() );
		}

		if ( key === "disabled" ) {
			this.menuInstance.option( "disabled", value );
			this.button
				.toggleClass( "ui-state-disabled", value )
				.attr( "aria-disabled", value );

			this.element.prop( "disabled", value );
			if ( value ) {
				this.button.attr( "tabindex", -1 );
				this.close();
			} else {
				this.button.attr( "tabindex", 0 );
			}
		}

		if ( key === "width" ) {
			this._resizeButton();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_toggleAttr: function() {
		this.button
			.toggleClass( "ui-corner-top", this.isOpen )
			.toggleClass( "ui-corner-all", !this.isOpen )
			.attr( "aria-expanded", this.isOpen );
		this.menuWrap.toggleClass( "ui-selectmenu-open", this.isOpen );
		this.menu.attr( "aria-hidden", !this.isOpen );
	},

	_resizeButton: function() {
		var width = this.options.width;

		if ( !width ) {
			width = this.element.show().outerWidth();
			this.element.hide();
		}

		this.button.outerWidth( width );
	},

	_resizeMenu: function() {
		this.menu.outerWidth( Math.max(
			this.button.outerWidth(),

			// support: IE10
			// IE10 wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping
			this.menu.width( "" ).outerWidth() + 1
		) );
	},

	_getCreateOptions: function() {
		return { disabled: this.element.prop( "disabled" ) };
	},

	_parseOptions: function( options ) {
		var data = [];
		options.each(function( index, item ) {
			var option = $( item ),
				optgroup = option.parent( "optgroup" );
			data.push({
				element: option,
				index: index,
				value: option.val(),
				label: option.text(),
				optgroup: optgroup.attr( "label" ) || "",
				disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
			});
		});
		this.items = data;
	},

	_destroy: function() {
		this.menuWrap.remove();
		this.button.remove();
		this.element.show();
		this.element.removeUniqueId();
		this.label.attr( "for", this.ids.element );
	}
});


/*!
 * jQuery UI Slider 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slider/
 */


var slider = $.widget( "ui.slider", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	// number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	numPages: 5,

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();
		this._calculateNewMax();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all");

		this._refresh();
		this._setOption( "disabled", this.options.disabled );

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});
	},

	_createRange: function() {
		var options = this.options,
			classes = "";

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[0], options.values[0] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice(0);
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div></div>" )
					.appendTo( this.element );

				classes = "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header ui-corner-all";
			} else {
				this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
					// Handle range switching from true to min/max
					.css({
						"left": "",
						"bottom": ""
					});
			}

			this.range.addClass( classes +
				( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
		} else {
			if ( this.range ) {
				this.range.remove();
			}
			this.range = null;
		}
	},

	_setupEvents: function() {
		this._off( this.handles );
		this._on( this.handles, this._handleEvents );
		this._hoverable( this.handles );
		this._focusable( this.handles );
	},

	_destroy: function() {
		this.handles.remove();
		if ( this.range ) {
			this.range.remove();
		}

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if (( distance > thisDistance ) ||
				( distance === thisDistance &&
					(i === that._lastChangedValue || that.values(i) === o.min ))) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length - 1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		if ( key === "disabled" ) {
			this.element.toggleClass( "ui-state-disabled", !!value );
		}

		this._super( key, value );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();

				// Reset positioning from previous orientation
				this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "step":
			case "min":
			case "max":
				this._animateOff = true;
				this._calculateNewMax();
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this.options.values && this.options.values.length ) {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i += 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_calculateNewMax: function() {
		var max = this.options.max,
			min = this._valueMin(),
			step = this.options.step,
			aboveMin = Math.floor( ( +( max - min ).toFixed( this._precision() ) ) / step ) * step;
		max = aboveMin + min;
		this.max = parseFloat( max.toFixed( this._precision() ) );
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						$( event.target ).addClass( "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this.options.values && this.options.values.length ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue(
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
					);
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue(
						curVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				$( event.target ).removeClass( "ui-state-active" );
			}
		}
	}
});


/*!
 * jQuery UI Spinner 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/spinner/
 */


function spinner_modifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

var spinner = $.widget( "ui.spinner", {
	version: "1.11.4",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {
		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// Only format if there is a value, prevents the field from being marked
		// as invalid in Firefox, see #9573.
		if ( this.value() !== "" ) {
			// Format the value, but don't constrain.
			this._value( this.element.val(), true );
		}

		this._draw();
		this._on( this._events );
		this._refresh();

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_getCreateOptions: function() {
		var options = {},
			element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value !== undefined && value.length ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._stop();
			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay(function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[0] === this.document[0].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[0] === this.document[0].activeElement;
				if ( !isActive ) {
					this.element.focus();
					this.previous = previous;
					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay(function() {
						this.previous = previous;
					});
				}
			}

			// ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay(function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			});

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {
			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	_draw: function() {
		var uiSpinner = this.uiSpinner = this.element
			.addClass( "ui-spinner-input" )
			.attr( "autocomplete", "off" )
			.wrap( this._uiSpinnerHtml() )
			.parent()
				// add buttons
				.append( this._buttonHtml() );

		this.element.attr( "role", "spinbutton" );

		// button bindings
		this.buttons = uiSpinner.find( ".ui-spinner-button" )
			.attr( "tabIndex", -1 )
			.button()
			.removeClass( "ui-corner-all" );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
				uiSpinner.height() > 0 ) {
			uiSpinner.height( uiSpinner.height() );
		}

		// disable spinner if element was already disabled
		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_uiSpinnerHtml: function() {
		return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
	},

	_buttonHtml: function() {
		return "" +
			"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
				"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
			"</a>" +
			"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
				"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
			"</a>";
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;
		// - round to the nearest step
		aboveMin = Math.round(aboveMin / options.step) * options.step;
		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// clamp the value
		if ( options.max !== null && value > options.max) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		if ( key === "culture" || key === "numberFormat" ) {
			var prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}
		if ( key === "icons" ) {
			this.buttons.first().find( ".ui-icon" )
				.removeClass( this.options.icons.up )
				.addClass( value.up );
			this.buttons.last().find( ".ui-icon" )
				.removeClass( this.options.icons.down )
				.addClass( value.down );
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this.widget().toggleClass( "ui-state-disabled", !!value );
			this.element.prop( "disabled", !!value );
			this.buttons.button( value ? "disable" : "enable" );
		}
	},

	_setOptions: spinner_modifier(function( options ) {
		this._super( options );
	}),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr({
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,
			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		});
	},

	isValid: function() {
		var value = this.value();

		// null is invalid
		if ( value === null ) {
			return false;
		}

		// if value gets adjusted, it's invalid
		return value === this._adjustValue( value );
	},

	// update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-spinner-input" )
			.prop( "disabled", false )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );
		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: spinner_modifier(function( steps ) {
		this._stepUp( steps );
	}),
	_stepUp: function( steps ) {
		if ( this._start() ) {
			this._spin( (steps || 1) * this.options.step );
			this._stop();
		}
	},

	stepDown: spinner_modifier(function( steps ) {
		this._stepDown( steps );
	}),
	_stepDown: function( steps ) {
		if ( this._start() ) {
			this._spin( (steps || 1) * -this.options.step );
			this._stop();
		}
	},

	pageUp: spinner_modifier(function( pages ) {
		this._stepUp( (pages || 1) * this.options.page );
	}),

	pageDown: spinner_modifier(function( pages ) {
		this._stepDown( (pages || 1) * this.options.page );
	}),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		spinner_modifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
});


/*!
 * jQuery UI Tabs 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 */


var tabs = $.widget( "ui.tabs", {
	version: "1.11.4",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_isLocal: (function() {
		var rhash = /#.*$/;

		return function( anchor ) {
			var anchorUrl, locationUrl;

			// support: IE7
			// IE7 doesn't normalize the href property when set via script (#9317)
			anchor = anchor.cloneNode( false );

			anchorUrl = anchor.href.replace( rhash, "" );
			locationUrl = location.href.replace( rhash, "" );

			// decoding may throw an error if the URL isn't UTF-8 (#9518)
			try {
				anchorUrl = decodeURIComponent( anchorUrl );
			} catch ( error ) {}
			try {
				locationUrl = decodeURIComponent( locationUrl );
			} catch ( error ) {}

			return anchor.hash.length > 1 && anchorUrl === locationUrl;
		};
	})(),

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible );

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control/command key will prevent automatic activation
		if ( !event.ctrlKey && !event.metaKey ) {

			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			"aria-expanded": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this,
			prevTabs = this.tabs,
			prevAnchors = this.anchors,
			prevPanels = this.panels;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" )

			// Prevent users from focusing disabled tabs via click
			.delegate( "> li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})

			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( that._isLocal( anchor ) ) {
				selector = anchor.hash;
				panelId = selector.substring( 1 );
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				// If the tab doesn't already have aria-controls,
				// generate an id by using a throw-away element
				panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": panelId,
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );

		// Avoid memory leaks (#10056)
		if ( prevTabs ) {
			this._off( prevTabs.not( this.tabs ) );
			this._off( prevAnchors.not( this.anchors ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.tablist || this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		// Always prevent the default action, even when disabled
		this._on( true, this.anchors, {
			click: function( event ) {
				event.preventDefault();
			}
		});
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr( "aria-hidden", "true" );
		eventData.oldTab.attr({
			"aria-selected": "false",
			"aria-expanded": "false"
		});
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr( "aria-hidden", "false" );
		eventData.newTab.attr({
			"aria-selected": "true",
			"aria-expanded": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this.tablist.unbind( this.eventNamespace );

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			},
			complete = function( jqXHR, status ) {
				if ( status === "abort" ) {
					that.panels.stop( false, true );
				}

				tab.removeClass( "ui-tabs-loading" );
				panel.removeAttr( "aria-busy" );

				if ( jqXHR === that.xhr ) {
					delete that.xhr;
				}
			};

		// not remote
		if ( this._isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.done(function( response, status, jqXHR ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );

						complete( jqXHR, status );
					}, 1 );
				})
				.fail(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						complete( jqXHR, status );
					}, 1 );
				});
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});


/*!
 * jQuery UI Tooltip 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tooltip/
 */


var tooltip = $.widget( "ui.tooltip", {
	version: "1.11.4",
	options: {
		content: function() {
			// support: IE<9, Opera in jQuery <1.7
			// .text() can't accept undefined, so coerce to a string
			var title = $( this ).attr( "title" ) || "";
			// Escape title, since we're going from an attribute to raw HTML
			return $( "<a>" ).text( title ).html();
		},
		hide: true,
		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		tooltipClass: null,
		track: false,

		// callbacks
		close: null,
		open: null
	},

	_addDescribedBy: function( elem, id ) {
		var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	},

	_removeDescribedBy: function( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
			index = $.inArray( id, describedby );

		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}

		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	},

	_create: function() {
		this._on({
			mouseover: "open",
			focusin: "open"
		});

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};

		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		if ( this.options.disabled ) {
			this._disable();
		}

		// Append the aria-live region so tooltips announce correctly
		this.liveRegion = $( "<div>" )
			.attr({
				role: "log",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.appendTo( this.document[ 0 ].body );
	},

	_setOption: function( key, value ) {
		var that = this;

		if ( key === "disabled" ) {
			this[ value ? "_disable" : "_enable" ]();
			this.options[ key ] = value;
			// disable element style changes
			return;
		}

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, tooltipData ) {
				that._updateContent( tooltipData.element );
			});
		}
	},

	_disable: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = tooltipData.element[ 0 ];
			that.close( event, true );
		});

		// remove title attributes to prevent native tooltips
		this.element.find( this.options.items ).addBack().each(function() {
			var element = $( this );
			if ( element.is( "[title]" ) ) {
				element
					.data( "ui-tooltip-title", element.attr( "title" ) )
					.removeAttr( "title" );
			}
		});
	},

	_enable: function() {
		// restore title attributes
		this.element.find( this.options.items ).addBack().each(function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		});
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )
				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each(function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			});
		}

		this._registerCloseHandlers( event, target );
		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[0], function( response ) {

			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay(function() {

				// Ignore async response if tooltip was closed already
				if ( !target.data( "ui-tooltip-open" ) ) {
					return;
				}

				// jQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			});
		});
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltipData, tooltip, delayedShow, a11yContent,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltipData = this._find( target );
		if ( tooltipData ) {
			tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// if we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltipData = this._tooltip( target );
		tooltip = tooltipData.tooltip;
		this._addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		// Support: Voiceover on OS X, JAWS on IE <= 9
		// JAWS announces deletions even when aria-relevant="additions"
		// Voiceover will sometimes re-read the entire log region's contents from the beginning
		this.liveRegion.children().hide();
		if ( content.clone ) {
			a11yContent = content.clone();
			a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
		} else {
			a11yContent = content;
		}
		$( "<div>" ).html( a11yContent ).appendTo( this.liveRegion );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			});
			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend({
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );
		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		if ( this.options.show && this.options.show.delay ) {
			delayedShow = this.delayedShow = setInterval(function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );
	},

	_registerCloseHandlers: function( event, target ) {
		var events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event(event);
					fakeEvent.currentTarget = target[0];
					this.close( fakeEvent, true );
				}
			}
		};

		// Only bind remove handler for delegated targets. Non-delegated
		// tooltips will handle this in destroy.
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			events.remove = function() {
				this._removeTooltip( this._find( target ).tooltip );
			};
		}

		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var tooltip,
			that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltipData = this._find( target );

		// The tooltip may already be closed
		if ( !tooltipData ) {

			// We set ui-tooltip-open immediately upon open (in open()), but only set the
			// additional data once there's actually content to show (in _open()). So even if the
			// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
			// the period between open() and _open().
			target.removeData( "ui-tooltip-open" );
			return;
		}

		tooltip = tooltipData.tooltip;

		// disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( tooltipData.closing ) {
			return;
		}

		// Clear the interval for delayed tracking tooltips
		clearInterval( this.delayedShow );

		// only set title if we had one before (see comment in _open())
		// If the title attribute has changed since open(), don't restore
		if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		this._removeDescribedBy( target );

		tooltipData.hiding = true;
		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		});

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );

		// Remove 'remove' binding only on delegated targets
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			});
		}

		tooltipData.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		if ( !tooltipData.hiding ) {
			tooltipData.closing = false;
		}
	},

	_tooltip: function( element ) {
		var tooltip = $( "<div>" )
				.attr( "role", "tooltip" )
				.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
					( this.options.tooltipClass || "" ) ),
			id = tooltip.uniqueId().attr( "id" );

		$( "<div>" )
			.addClass( "ui-tooltip-content" )
			.appendTo( tooltip );

		tooltip.appendTo( this.document[0].body );

		return this.tooltips[ id ] = {
			element: element,
			tooltip: tooltip
		};
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? this.tooltips[ id ] : null;
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_destroy: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {
			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" ),
				element = tooltipData.element;
			event.target = event.currentTarget = element[ 0 ];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {
				// If the title attribute has changed since open(), don't restore
				if ( !element.attr( "title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
				element.removeData( "ui-tooltip-title" );
			}
		});
		this.liveRegion.remove();
	}
});


/*!
 * jQuery UI Effects 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/effects-core/
 */


var dataSpace = "ui-effects-",

	// Create a local jQuery because jQuery Color relies on it and the
	// global may not exist with AMD and a custom build (#10199)
	jQuery = $;

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [ {
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		} ],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + ( q - p ) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
	}
	return p;
}

spaces.hsla.to = function( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};

each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							(backgroundColor === "" || backgroundColor === "transparent") &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch ( e ) {
					// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	});

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );

/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}
	// support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}

function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, "" );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	addClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.addClass ),

	removeClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.removeClass ),

	toggleClass: (function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {
					// without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						(force ? { add: classNames } : { remove: classNames }),
						speed, easing, callback );
				}
			} else {
				// without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	})( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.11.4",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for ( var i = 0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for ( i = 0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch ( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}

		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {
	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// If the element already has the correct final state, delegate to
			// the core methods so the internal tracking of "olddisplay" works.
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				elem[ mode ]();
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
	},

	show: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.show ),

	hide: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.hide ),

	toggle: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.toggle ),

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

var effect = $.effects;


/*!
 * jQuery UI Effects Blind 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/blind-effect/
 */


var effectBlind = $.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		rvertical = /up|down|vertical/,
		rpositivemotion = /up|left|vertical|horizontal/,
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( !motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};


/*!
 * jQuery UI Effects Bounce 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/bounce-effect/
 */


var effectBounce = $.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};


/*!
 * jQuery UI Effects Clip 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/clip-effect/
 */


var effectClip = $.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};


/*!
 * jQuery UI Effects Drop 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/drop-effect/
 */


var effectDrop = $.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};


/*!
 * jQuery UI Effects Explode 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/explode-effect/
 */


var effectExplode = $.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for ( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for ( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};


/*!
 * jQuery UI Effects Fade 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fade-effect/
 */


var effectFade = $.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};


/*!
 * jQuery UI Effects Fold 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fold-effect/
 */


var effectFold = $.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};


/*!
 * jQuery UI Effects Highlight 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/highlight-effect/
 */


var effectHighlight = $.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};


/*!
 * jQuery UI Effects Size 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/size-effect/
 */


var effectSize = $.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function() {
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};


/*!
 * jQuery UI Effects Scale 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/scale-effect/
 */


var effectScale = $.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || [ "middle", "center" ];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};


/*!
 * jQuery UI Effects Puff 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/puff-effect/
 */


var effectPuff = $.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};


/*!
 * jQuery UI Effects Pulsate 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/pulsate-effect/
 */


var effectPulsate = $.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};


/*!
 * jQuery UI Effects Shake 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/shake-effect/
 */


var effectShake = $.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round( o.duration / anims ),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};


/*!
 * jQuery UI Effects Slide 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slide-effect/
 */


var effectSlide = $.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};


/*!
 * jQuery UI Effects Transfer 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/transfer-effect/
 */


var effectTransfer = $.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop,
			left: endPosition.left - fixLeft,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( "<div class='ui-effects-transfer'></div>" )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop,
				left: startPosition.left - fixLeft,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};



}));

/*!
 * Bootstrap v3.3.5 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

/*!
 * Generated using the Bootstrap Customizer (http://getbootstrap.com/customize/?id=927c006634d10dfcf22b6c87f0302d0e)
 * Config saved to config.json and https://gist.github.com/927c006634d10dfcf22b6c87f0302d0e
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(t){"use strict";var e=t.fn.jquery.split(" ")[0].split(".");if(e[0]<2&&e[1]<9||1==e[0]&&9==e[1]&&e[2]<1||e[0]>2)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3")}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var i=t(this),n=i.data("bs.alert");n||i.data("bs.alert",n=new o(this)),"string"==typeof e&&n[e].call(i)})}var i='[data-dismiss="alert"]',o=function(e){t(e).on("click",i,this.close)};o.VERSION="3.3.6",o.TRANSITION_DURATION=150,o.prototype.close=function(e){function i(){a.detach().trigger("closed.bs.alert").remove()}var n=t(this),s=n.attr("data-target");s||(s=n.attr("href"),s=s&&s.replace(/.*(?=#[^\s]*$)/,""));var a=t(s);e&&e.preventDefault(),a.length||(a=n.closest(".alert")),a.trigger(e=t.Event("close.bs.alert")),e.isDefaultPrevented()||(a.removeClass("in"),t.support.transition&&a.hasClass("fade")?a.one("bsTransitionEnd",i).emulateTransitionEnd(o.TRANSITION_DURATION):i())};var n=t.fn.alert;t.fn.alert=e,t.fn.alert.Constructor=o,t.fn.alert.noConflict=function(){return t.fn.alert=n,this},t(document).on("click.bs.alert.data-api",i,o.prototype.close)}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var o=t(this),n=o.data("bs.button"),s="object"==typeof e&&e;n||o.data("bs.button",n=new i(this,s)),"toggle"==e?n.toggle():e&&n.setState(e)})}var i=function(e,o){this.$element=t(e),this.options=t.extend({},i.DEFAULTS,o),this.isLoading=!1};i.VERSION="3.3.6",i.DEFAULTS={loadingText:"loading..."},i.prototype.setState=function(e){var i="disabled",o=this.$element,n=o.is("input")?"val":"html",s=o.data();e+="Text",null==s.resetText&&o.data("resetText",o[n]()),setTimeout(t.proxy(function(){o[n](null==s[e]?this.options[e]:s[e]),"loadingText"==e?(this.isLoading=!0,o.addClass(i).attr(i,i)):this.isLoading&&(this.isLoading=!1,o.removeClass(i).removeAttr(i))},this),0)},i.prototype.toggle=function(){var t=!0,e=this.$element.closest('[data-toggle="buttons"]');if(e.length){var i=this.$element.find("input");"radio"==i.prop("type")?(i.prop("checked")&&(t=!1),e.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==i.prop("type")&&(i.prop("checked")!==this.$element.hasClass("active")&&(t=!1),this.$element.toggleClass("active")),i.prop("checked",this.$element.hasClass("active")),t&&i.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var o=t.fn.button;t.fn.button=e,t.fn.button.Constructor=i,t.fn.button.noConflict=function(){return t.fn.button=o,this},t(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(i){var o=t(i.target);o.hasClass("btn")||(o=o.closest(".btn")),e.call(o,"toggle"),t(i.target).is('input[type="radio"]')||t(i.target).is('input[type="checkbox"]')||i.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(e){t(e.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(e.type))})}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var o=t(this),n=o.data("bs.carousel"),s=t.extend({},i.DEFAULTS,o.data(),"object"==typeof e&&e),a="string"==typeof e?e:s.slide;n||o.data("bs.carousel",n=new i(this,s)),"number"==typeof e?n.to(e):a?n[a]():s.interval&&n.pause().cycle()})}var i=function(e,i){this.$element=t(e),this.$indicators=this.$element.find(".carousel-indicators"),this.options=i,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",t.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",t.proxy(this.pause,this)).on("mouseleave.bs.carousel",t.proxy(this.cycle,this))};i.VERSION="3.3.6",i.TRANSITION_DURATION=600,i.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},i.prototype.keydown=function(t){if(!/input|textarea/i.test(t.target.tagName)){switch(t.which){case 37:this.prev();break;case 39:this.next();break;default:return}t.preventDefault()}},i.prototype.cycle=function(e){return e||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(t.proxy(this.next,this),this.options.interval)),this},i.prototype.getItemIndex=function(t){return this.$items=t.parent().children(".item"),this.$items.index(t||this.$active)},i.prototype.getItemForDirection=function(t,e){var i=this.getItemIndex(e),o="prev"==t&&0===i||"next"==t&&i==this.$items.length-1;if(o&&!this.options.wrap)return e;var n="prev"==t?-1:1,s=(i+n)%this.$items.length;return this.$items.eq(s)},i.prototype.to=function(t){var e=this,i=this.getItemIndex(this.$active=this.$element.find(".item.active"));return t>this.$items.length-1||0>t?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){e.to(t)}):i==t?this.pause().cycle():this.slide(t>i?"next":"prev",this.$items.eq(t))},i.prototype.pause=function(e){return e||(this.paused=!0),this.$element.find(".next, .prev").length&&t.support.transition&&(this.$element.trigger(t.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},i.prototype.next=function(){return this.sliding?void 0:this.slide("next")},i.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},i.prototype.slide=function(e,o){var n=this.$element.find(".item.active"),s=o||this.getItemForDirection(e,n),a=this.interval,r="next"==e?"left":"right",l=this;if(s.hasClass("active"))return this.sliding=!1;var h=s[0],d=t.Event("slide.bs.carousel",{relatedTarget:h,direction:r});if(this.$element.trigger(d),!d.isDefaultPrevented()){if(this.sliding=!0,a&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var p=t(this.$indicators.children()[this.getItemIndex(s)]);p&&p.addClass("active")}var c=t.Event("slid.bs.carousel",{relatedTarget:h,direction:r});return t.support.transition&&this.$element.hasClass("slide")?(s.addClass(e),s[0].offsetWidth,n.addClass(r),s.addClass(r),n.one("bsTransitionEnd",function(){s.removeClass([e,r].join(" ")).addClass("active"),n.removeClass(["active",r].join(" ")),l.sliding=!1,setTimeout(function(){l.$element.trigger(c)},0)}).emulateTransitionEnd(i.TRANSITION_DURATION)):(n.removeClass("active"),s.addClass("active"),this.sliding=!1,this.$element.trigger(c)),a&&this.cycle(),this}};var o=t.fn.carousel;t.fn.carousel=e,t.fn.carousel.Constructor=i,t.fn.carousel.noConflict=function(){return t.fn.carousel=o,this};var n=function(i){var o,n=t(this),s=t(n.attr("data-target")||(o=n.attr("href"))&&o.replace(/.*(?=#[^\s]+$)/,""));if(s.hasClass("carousel")){var a=t.extend({},s.data(),n.data()),r=n.attr("data-slide-to");r&&(a.interval=!1),e.call(s,a),r&&s.data("bs.carousel").to(r),i.preventDefault()}};t(document).on("click.bs.carousel.data-api","[data-slide]",n).on("click.bs.carousel.data-api","[data-slide-to]",n),t(window).on("load",function(){t('[data-ride="carousel"]').each(function(){var i=t(this);e.call(i,i.data())})})}(jQuery),+function(t){"use strict";function e(e){var i=e.attr("data-target");i||(i=e.attr("href"),i=i&&/#[A-Za-z]/.test(i)&&i.replace(/.*(?=#[^\s]*$)/,""));var o=i&&t(i);return o&&o.length?o:e.parent()}function i(i){i&&3===i.which||(t(n).remove(),t(s).each(function(){var o=t(this),n=e(o),s={relatedTarget:this};n.hasClass("open")&&(i&&"click"==i.type&&/input|textarea/i.test(i.target.tagName)&&t.contains(n[0],i.target)||(n.trigger(i=t.Event("hide.bs.dropdown",s)),i.isDefaultPrevented()||(o.attr("aria-expanded","false"),n.removeClass("open").trigger(t.Event("hidden.bs.dropdown",s)))))}))}function o(e){return this.each(function(){var i=t(this),o=i.data("bs.dropdown");o||i.data("bs.dropdown",o=new a(this)),"string"==typeof e&&o[e].call(i)})}var n=".dropdown-backdrop",s='[data-toggle="dropdown"]',a=function(e){t(e).on("click.bs.dropdown",this.toggle)};a.VERSION="3.3.6",a.prototype.toggle=function(o){var n=t(this);if(!n.is(".disabled, :disabled")){var s=e(n),a=s.hasClass("open");if(i(),!a){"ontouchstart"in document.documentElement&&!s.closest(".navbar-nav").length&&t(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(t(this)).on("click",i);var r={relatedTarget:this};if(s.trigger(o=t.Event("show.bs.dropdown",r)),o.isDefaultPrevented())return;n.trigger("focus").attr("aria-expanded","true"),s.toggleClass("open").trigger(t.Event("shown.bs.dropdown",r))}return!1}},a.prototype.keydown=function(i){if(/(38|40|27|32)/.test(i.which)&&!/input|textarea/i.test(i.target.tagName)){var o=t(this);if(i.preventDefault(),i.stopPropagation(),!o.is(".disabled, :disabled")){var n=e(o),a=n.hasClass("open");if(!a&&27!=i.which||a&&27==i.which)return 27==i.which&&n.find(s).trigger("focus"),o.trigger("click");var r=" li:not(.disabled):visible a",l=n.find(".dropdown-menu"+r);if(l.length){var h=l.index(i.target);38==i.which&&h>0&&h--,40==i.which&&h<l.length-1&&h++,~h||(h=0),l.eq(h).trigger("focus")}}}};var r=t.fn.dropdown;t.fn.dropdown=o,t.fn.dropdown.Constructor=a,t.fn.dropdown.noConflict=function(){return t.fn.dropdown=r,this},t(document).on("click.bs.dropdown.data-api",i).on("click.bs.dropdown.data-api",".dropdown form",function(t){t.stopPropagation()}).on("click.bs.dropdown.data-api",s,a.prototype.toggle).on("keydown.bs.dropdown.data-api",s,a.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",a.prototype.keydown)}(jQuery),+function(t){"use strict";function e(e,o){return this.each(function(){var n=t(this),s=n.data("bs.modal"),a=t.extend({},i.DEFAULTS,n.data(),"object"==typeof e&&e);s||n.data("bs.modal",s=new i(this,a)),"string"==typeof e?s[e](o):a.show&&s.show(o)})}var i=function(e,i){this.options=i,this.$body=t(document.body),this.$element=t(e),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,t.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};i.VERSION="3.3.6",i.TRANSITION_DURATION=300,i.BACKDROP_TRANSITION_DURATION=150,i.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},i.prototype.toggle=function(t){return this.isShown?this.hide():this.show(t)},i.prototype.show=function(e){var o=this,n=t.Event("show.bs.modal",{relatedTarget:e});this.$element.trigger(n),this.isShown||n.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',t.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){o.$element.one("mouseup.dismiss.bs.modal",function(e){t(e.target).is(o.$element)&&(o.ignoreBackdropClick=!0)})}),this.backdrop(function(){var n=t.support.transition&&o.$element.hasClass("fade");o.$element.parent().length||o.$element.appendTo(o.$body),o.$element.show().scrollTop(0),o.adjustDialog(),n&&o.$element[0].offsetWidth,o.$element.addClass("in"),o.enforceFocus();var s=t.Event("shown.bs.modal",{relatedTarget:e});n?o.$dialog.one("bsTransitionEnd",function(){o.$element.trigger("focus").trigger(s)}).emulateTransitionEnd(i.TRANSITION_DURATION):o.$element.trigger("focus").trigger(s)}))},i.prototype.hide=function(e){e&&e.preventDefault(),e=t.Event("hide.bs.modal"),this.$element.trigger(e),this.isShown&&!e.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),t(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),t.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",t.proxy(this.hideModal,this)).emulateTransitionEnd(i.TRANSITION_DURATION):this.hideModal())},i.prototype.enforceFocus=function(){t(document).off("focusin.bs.modal").on("focusin.bs.modal",t.proxy(function(t){this.$element[0]===t.target||this.$element.has(t.target).length||this.$element.trigger("focus")},this))},i.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",t.proxy(function(t){27==t.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},i.prototype.resize=function(){this.isShown?t(window).on("resize.bs.modal",t.proxy(this.handleUpdate,this)):t(window).off("resize.bs.modal")},i.prototype.hideModal=function(){var t=this;this.$element.hide(),this.backdrop(function(){t.$body.removeClass("modal-open"),t.resetAdjustments(),t.resetScrollbar(),t.$element.trigger("hidden.bs.modal")})},i.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},i.prototype.backdrop=function(e){var o=this,n=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var s=t.support.transition&&n;if(this.$backdrop=t(document.createElement("div")).addClass("modal-backdrop "+n).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",t.proxy(function(t){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(t.target===t.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),s&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!e)return;s?this.$backdrop.one("bsTransitionEnd",e).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION):e()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var a=function(){o.removeBackdrop(),e&&e()};t.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",a).emulateTransitionEnd(i.BACKDROP_TRANSITION_DURATION):a()}else e&&e()},i.prototype.handleUpdate=function(){this.adjustDialog()},i.prototype.adjustDialog=function(){var t=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&t?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!t?this.scrollbarWidth:""})},i.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},i.prototype.checkScrollbar=function(){var t=window.innerWidth;if(!t){var e=document.documentElement.getBoundingClientRect();t=e.right-Math.abs(e.left)}this.bodyIsOverflowing=document.body.clientWidth<t,this.scrollbarWidth=this.measureScrollbar()},i.prototype.setScrollbar=function(){var t=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",t+this.scrollbarWidth)},i.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},i.prototype.measureScrollbar=function(){var t=document.createElement("div");t.className="modal-scrollbar-measure",this.$body.append(t);var e=t.offsetWidth-t.clientWidth;return this.$body[0].removeChild(t),e};var o=t.fn.modal;t.fn.modal=e,t.fn.modal.Constructor=i,t.fn.modal.noConflict=function(){return t.fn.modal=o,this},t(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(i){var o=t(this),n=o.attr("href"),s=t(o.attr("data-target")||n&&n.replace(/.*(?=#[^\s]+$)/,"")),a=s.data("bs.modal")?"toggle":t.extend({remote:!/#/.test(n)&&n},s.data(),o.data());o.is("a")&&i.preventDefault(),s.one("show.bs.modal",function(t){t.isDefaultPrevented()||s.one("hidden.bs.modal",function(){o.is(":visible")&&o.trigger("focus")})}),e.call(s,a,this)})}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var o=t(this),n=o.data("bs.tooltip"),s="object"==typeof e&&e;(n||!/destroy|hide/.test(e))&&(n||o.data("bs.tooltip",n=new i(this,s)),"string"==typeof e&&n[e]())})}var i=function(t,e){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",t,e)};i.VERSION="3.3.6",i.TRANSITION_DURATION=150,i.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},i.prototype.init=function(e,i,o){if(this.enabled=!0,this.type=e,this.$element=t(i),this.options=this.getOptions(o),this.$viewport=this.options.viewport&&t(t.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var n=this.options.trigger.split(" "),s=n.length;s--;){var a=n[s];if("click"==a)this.$element.on("click."+this.type,this.options.selector,t.proxy(this.toggle,this));else if("manual"!=a){var r="hover"==a?"mouseenter":"focusin",l="hover"==a?"mouseleave":"focusout";this.$element.on(r+"."+this.type,this.options.selector,t.proxy(this.enter,this)),this.$element.on(l+"."+this.type,this.options.selector,t.proxy(this.leave,this))}}this.options.selector?this._options=t.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},i.prototype.getDefaults=function(){return i.DEFAULTS},i.prototype.getOptions=function(e){return e=t.extend({},this.getDefaults(),this.$element.data(),e),e.delay&&"number"==typeof e.delay&&(e.delay={show:e.delay,hide:e.delay}),e},i.prototype.getDelegateOptions=function(){var e={},i=this.getDefaults();return this._options&&t.each(this._options,function(t,o){i[t]!=o&&(e[t]=o)}),e},i.prototype.enter=function(e){var i=e instanceof this.constructor?e:t(e.currentTarget).data("bs."+this.type);return i||(i=new this.constructor(e.currentTarget,this.getDelegateOptions()),t(e.currentTarget).data("bs."+this.type,i)),e instanceof t.Event&&(i.inState["focusin"==e.type?"focus":"hover"]=!0),i.tip().hasClass("in")||"in"==i.hoverState?void(i.hoverState="in"):(clearTimeout(i.timeout),i.hoverState="in",i.options.delay&&i.options.delay.show?void(i.timeout=setTimeout(function(){"in"==i.hoverState&&i.show()},i.options.delay.show)):i.show())},i.prototype.isInStateTrue=function(){for(var t in this.inState)if(this.inState[t])return!0;return!1},i.prototype.leave=function(e){var i=e instanceof this.constructor?e:t(e.currentTarget).data("bs."+this.type);return i||(i=new this.constructor(e.currentTarget,this.getDelegateOptions()),t(e.currentTarget).data("bs."+this.type,i)),e instanceof t.Event&&(i.inState["focusout"==e.type?"focus":"hover"]=!1),i.isInStateTrue()?void 0:(clearTimeout(i.timeout),i.hoverState="out",i.options.delay&&i.options.delay.hide?void(i.timeout=setTimeout(function(){"out"==i.hoverState&&i.hide()},i.options.delay.hide)):i.hide())},i.prototype.show=function(){var e=t.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(e);var o=t.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(e.isDefaultPrevented()||!o)return;var n=this,s=this.tip(),a=this.getUID(this.type);this.setContent(),s.attr("id",a),this.$element.attr("aria-describedby",a),this.options.animation&&s.addClass("fade");var r="function"==typeof this.options.placement?this.options.placement.call(this,s[0],this.$element[0]):this.options.placement,l=/\s?auto?\s?/i,h=l.test(r);h&&(r=r.replace(l,"")||"top"),s.detach().css({top:0,left:0,display:"block"}).addClass(r).data("bs."+this.type,this),this.options.container?s.appendTo(this.options.container):s.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var d=this.getPosition(),p=s[0].offsetWidth,c=s[0].offsetHeight;if(h){var f=r,u=this.getPosition(this.$viewport);r="bottom"==r&&d.bottom+c>u.bottom?"top":"top"==r&&d.top-c<u.top?"bottom":"right"==r&&d.right+p>u.width?"left":"left"==r&&d.left-p<u.left?"right":r,s.removeClass(f).addClass(r)}var g=this.getCalculatedOffset(r,d,p,c);this.applyPlacement(g,r);var v=function(){var t=n.hoverState;n.$element.trigger("shown.bs."+n.type),n.hoverState=null,"out"==t&&n.leave(n)};t.support.transition&&this.$tip.hasClass("fade")?s.one("bsTransitionEnd",v).emulateTransitionEnd(i.TRANSITION_DURATION):v()}},i.prototype.applyPlacement=function(e,i){var o=this.tip(),n=o[0].offsetWidth,s=o[0].offsetHeight,a=parseInt(o.css("margin-top"),10),r=parseInt(o.css("margin-left"),10);isNaN(a)&&(a=0),isNaN(r)&&(r=0),e.top+=a,e.left+=r,t.offset.setOffset(o[0],t.extend({using:function(t){o.css({top:Math.round(t.top),left:Math.round(t.left)})}},e),0),o.addClass("in");var l=o[0].offsetWidth,h=o[0].offsetHeight;"top"==i&&h!=s&&(e.top=e.top+s-h);var d=this.getViewportAdjustedDelta(i,e,l,h);d.left?e.left+=d.left:e.top+=d.top;var p=/top|bottom/.test(i),c=p?2*d.left-n+l:2*d.top-s+h,f=p?"offsetWidth":"offsetHeight";o.offset(e),this.replaceArrow(c,o[0][f],p)},i.prototype.replaceArrow=function(t,e,i){this.arrow().css(i?"left":"top",50*(1-t/e)+"%").css(i?"top":"left","")},i.prototype.setContent=function(){var t=this.tip(),e=this.getTitle();t.find(".tooltip-inner")[this.options.html?"html":"text"](e),t.removeClass("fade in top bottom left right")},i.prototype.hide=function(e){function o(){"in"!=n.hoverState&&s.detach(),n.$element.removeAttr("aria-describedby").trigger("hidden.bs."+n.type),e&&e()}var n=this,s=t(this.$tip),a=t.Event("hide.bs."+this.type);return this.$element.trigger(a),a.isDefaultPrevented()?void 0:(s.removeClass("in"),t.support.transition&&s.hasClass("fade")?s.one("bsTransitionEnd",o).emulateTransitionEnd(i.TRANSITION_DURATION):o(),this.hoverState=null,this)},i.prototype.fixTitle=function(){var t=this.$element;(t.attr("title")||"string"!=typeof t.attr("data-original-title"))&&t.attr("data-original-title",t.attr("title")||"").attr("title","")},i.prototype.hasContent=function(){return this.getTitle()},i.prototype.getPosition=function(e){e=e||this.$element;var i=e[0],o="BODY"==i.tagName,n=i.getBoundingClientRect();null==n.width&&(n=t.extend({},n,{width:n.right-n.left,height:n.bottom-n.top}));var s=o?{top:0,left:0}:e.offset(),a={scroll:o?document.documentElement.scrollTop||document.body.scrollTop:e.scrollTop()},r=o?{width:t(window).width(),height:t(window).height()}:null;return t.extend({},n,a,r,s)},i.prototype.getCalculatedOffset=function(t,e,i,o){return"bottom"==t?{top:e.top+e.height,left:e.left+e.width/2-i/2}:"top"==t?{top:e.top-o,left:e.left+e.width/2-i/2}:"left"==t?{top:e.top+e.height/2-o/2,left:e.left-i}:{top:e.top+e.height/2-o/2,left:e.left+e.width}},i.prototype.getViewportAdjustedDelta=function(t,e,i,o){var n={top:0,left:0};if(!this.$viewport)return n;var s=this.options.viewport&&this.options.viewport.padding||0,a=this.getPosition(this.$viewport);if(/right|left/.test(t)){var r=e.top-s-a.scroll,l=e.top+s-a.scroll+o;r<a.top?n.top=a.top-r:l>a.top+a.height&&(n.top=a.top+a.height-l)}else{var h=e.left-s,d=e.left+s+i;h<a.left?n.left=a.left-h:d>a.right&&(n.left=a.left+a.width-d)}return n},i.prototype.getTitle=function(){var t,e=this.$element,i=this.options;return t=e.attr("data-original-title")||("function"==typeof i.title?i.title.call(e[0]):i.title)},i.prototype.getUID=function(t){do t+=~~(1e6*Math.random());while(document.getElementById(t));return t},i.prototype.tip=function(){if(!this.$tip&&(this.$tip=t(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},i.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},i.prototype.enable=function(){this.enabled=!0},i.prototype.disable=function(){this.enabled=!1},i.prototype.toggleEnabled=function(){this.enabled=!this.enabled},i.prototype.toggle=function(e){var i=this;e&&(i=t(e.currentTarget).data("bs."+this.type),i||(i=new this.constructor(e.currentTarget,this.getDelegateOptions()),t(e.currentTarget).data("bs."+this.type,i))),e?(i.inState.click=!i.inState.click,i.isInStateTrue()?i.enter(i):i.leave(i)):i.tip().hasClass("in")?i.leave(i):i.enter(i)},i.prototype.destroy=function(){var t=this;clearTimeout(this.timeout),this.hide(function(){t.$element.off("."+t.type).removeData("bs."+t.type),t.$tip&&t.$tip.detach(),t.$tip=null,t.$arrow=null,t.$viewport=null})};var o=t.fn.tooltip;t.fn.tooltip=e,t.fn.tooltip.Constructor=i,t.fn.tooltip.noConflict=function(){return t.fn.tooltip=o,this}}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var o=t(this),n=o.data("bs.popover"),s="object"==typeof e&&e;(n||!/destroy|hide/.test(e))&&(n||o.data("bs.popover",n=new i(this,s)),"string"==typeof e&&n[e]())})}var i=function(t,e){this.init("popover",t,e)};if(!t.fn.tooltip)throw new Error("Popover requires tooltip.js");i.VERSION="3.3.6",i.DEFAULTS=t.extend({},t.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),i.prototype=t.extend({},t.fn.tooltip.Constructor.prototype),i.prototype.constructor=i,i.prototype.getDefaults=function(){return i.DEFAULTS},i.prototype.setContent=function(){var t=this.tip(),e=this.getTitle(),i=this.getContent();t.find(".popover-title")[this.options.html?"html":"text"](e),t.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof i?"html":"append":"text"](i),t.removeClass("fade top bottom left right in"),t.find(".popover-title").html()||t.find(".popover-title").hide()},i.prototype.hasContent=function(){return this.getTitle()||this.getContent()},i.prototype.getContent=function(){var t=this.$element,e=this.options;return t.attr("data-content")||("function"==typeof e.content?e.content.call(t[0]):e.content)},i.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var o=t.fn.popover;t.fn.popover=e,t.fn.popover.Constructor=i,t.fn.popover.noConflict=function(){return t.fn.popover=o,this}}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var o=t(this),n=o.data("bs.tab");n||o.data("bs.tab",n=new i(this)),"string"==typeof e&&n[e]()})}var i=function(e){this.element=t(e)};i.VERSION="3.3.6",i.TRANSITION_DURATION=150,i.prototype.show=function(){var e=this.element,i=e.closest("ul:not(.dropdown-menu)"),o=e.data("target");if(o||(o=e.attr("href"),o=o&&o.replace(/.*(?=#[^\s]*$)/,"")),!e.parent("li").hasClass("active")){var n=i.find(".active:last a"),s=t.Event("hide.bs.tab",{relatedTarget:e[0]}),a=t.Event("show.bs.tab",{relatedTarget:n[0]});if(n.trigger(s),e.trigger(a),!a.isDefaultPrevented()&&!s.isDefaultPrevented()){var r=t(o);this.activate(e.closest("li"),i),this.activate(r,r.parent(),function(){n.trigger({type:"hidden.bs.tab",relatedTarget:e[0]}),e.trigger({type:"shown.bs.tab",relatedTarget:n[0]})})}}},i.prototype.activate=function(e,o,n){function s(){a.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),e.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),r?(e[0].offsetWidth,e.addClass("in")):e.removeClass("fade"),e.parent(".dropdown-menu").length&&e.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),n&&n()}var a=o.find("> .active"),r=n&&t.support.transition&&(a.length&&a.hasClass("fade")||!!o.find("> .fade").length);a.length&&r?a.one("bsTransitionEnd",s).emulateTransitionEnd(i.TRANSITION_DURATION):s(),a.removeClass("in")};var o=t.fn.tab;t.fn.tab=e,t.fn.tab.Constructor=i,t.fn.tab.noConflict=function(){return t.fn.tab=o,this};var n=function(i){i.preventDefault(),e.call(t(this),"show")};t(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',n).on("click.bs.tab.data-api",'[data-toggle="pill"]',n)}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var o=t(this),n=o.data("bs.affix"),s="object"==typeof e&&e;n||o.data("bs.affix",n=new i(this,s)),"string"==typeof e&&n[e]()})}var i=function(e,o){this.options=t.extend({},i.DEFAULTS,o),this.$target=t(this.options.target).on("scroll.bs.affix.data-api",t.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",t.proxy(this.checkPositionWithEventLoop,this)),this.$element=t(e),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};i.VERSION="3.3.6",i.RESET="affix affix-top affix-bottom",i.DEFAULTS={offset:0,target:window},i.prototype.getState=function(t,e,i,o){var n=this.$target.scrollTop(),s=this.$element.offset(),a=this.$target.height();if(null!=i&&"top"==this.affixed)return i>n?"top":!1;if("bottom"==this.affixed)return null!=i?n+this.unpin<=s.top?!1:"bottom":t-o>=n+a?!1:"bottom";var r=null==this.affixed,l=r?n:s.top,h=r?a:e;return null!=i&&i>=n?"top":null!=o&&l+h>=t-o?"bottom":!1},i.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(i.RESET).addClass("affix");var t=this.$target.scrollTop(),e=this.$element.offset();return this.pinnedOffset=e.top-t},i.prototype.checkPositionWithEventLoop=function(){setTimeout(t.proxy(this.checkPosition,this),1)},i.prototype.checkPosition=function(){if(this.$element.is(":visible")){var e=this.$element.height(),o=this.options.offset,n=o.top,s=o.bottom,a=Math.max(t(document).height(),t(document.body).height());"object"!=typeof o&&(s=n=o),"function"==typeof n&&(n=o.top(this.$element)),"function"==typeof s&&(s=o.bottom(this.$element));var r=this.getState(a,e,n,s);if(this.affixed!=r){null!=this.unpin&&this.$element.css("top","");var l="affix"+(r?"-"+r:""),h=t.Event(l+".bs.affix");if(this.$element.trigger(h),h.isDefaultPrevented())return;this.affixed=r,this.unpin="bottom"==r?this.getPinnedOffset():null,this.$element.removeClass(i.RESET).addClass(l).trigger(l.replace("affix","affixed")+".bs.affix")}"bottom"==r&&this.$element.offset({top:a-e-s})}};var o=t.fn.affix;t.fn.affix=e,t.fn.affix.Constructor=i,t.fn.affix.noConflict=function(){return t.fn.affix=o,this},t(window).on("load",function(){t('[data-spy="affix"]').each(function(){var i=t(this),o=i.data();o.offset=o.offset||{},null!=o.offsetBottom&&(o.offset.bottom=o.offsetBottom),null!=o.offsetTop&&(o.offset.top=o.offsetTop),e.call(i,o)})})}(jQuery),+function(t){"use strict";function e(e){var i,o=e.attr("data-target")||(i=e.attr("href"))&&i.replace(/.*(?=#[^\s]+$)/,"");return t(o)}function i(e){return this.each(function(){var i=t(this),n=i.data("bs.collapse"),s=t.extend({},o.DEFAULTS,i.data(),"object"==typeof e&&e);!n&&s.toggle&&/show|hide/.test(e)&&(s.toggle=!1),n||i.data("bs.collapse",n=new o(this,s)),"string"==typeof e&&n[e]()})}var o=function(e,i){this.$element=t(e),this.options=t.extend({},o.DEFAULTS,i),this.$trigger=t('[data-toggle="collapse"][href="#'+e.id+'"],[data-toggle="collapse"][data-target="#'+e.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};o.VERSION="3.3.6",o.TRANSITION_DURATION=350,o.DEFAULTS={toggle:!0},o.prototype.dimension=function(){var t=this.$element.hasClass("width");return t?"width":"height"},o.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var e,n=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(n&&n.length&&(e=n.data("bs.collapse"),e&&e.transitioning))){var s=t.Event("show.bs.collapse");if(this.$element.trigger(s),!s.isDefaultPrevented()){n&&n.length&&(i.call(n,"hide"),e||n.data("bs.collapse",null));var a=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[a](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var r=function(){this.$element.removeClass("collapsing").addClass("collapse in")[a](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!t.support.transition)return r.call(this);var l=t.camelCase(["scroll",a].join("-"));this.$element.one("bsTransitionEnd",t.proxy(r,this)).emulateTransitionEnd(o.TRANSITION_DURATION)[a](this.$element[0][l]);
}}}},o.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var e=t.Event("hide.bs.collapse");if(this.$element.trigger(e),!e.isDefaultPrevented()){var i=this.dimension();this.$element[i](this.$element[i]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var n=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return t.support.transition?void this.$element[i](0).one("bsTransitionEnd",t.proxy(n,this)).emulateTransitionEnd(o.TRANSITION_DURATION):n.call(this)}}},o.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},o.prototype.getParent=function(){return t(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(t.proxy(function(i,o){var n=t(o);this.addAriaAndCollapsedClass(e(n),n)},this)).end()},o.prototype.addAriaAndCollapsedClass=function(t,e){var i=t.hasClass("in");t.attr("aria-expanded",i),e.toggleClass("collapsed",!i).attr("aria-expanded",i)};var n=t.fn.collapse;t.fn.collapse=i,t.fn.collapse.Constructor=o,t.fn.collapse.noConflict=function(){return t.fn.collapse=n,this},t(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(o){var n=t(this);n.attr("data-target")||o.preventDefault();var s=e(n),a=s.data("bs.collapse"),r=a?"toggle":n.data();i.call(s,r)})}(jQuery),+function(t){"use strict";function e(i,o){this.$body=t(document.body),this.$scrollElement=t(t(i).is(document.body)?window:i),this.options=t.extend({},e.DEFAULTS,o),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",t.proxy(this.process,this)),this.refresh(),this.process()}function i(i){return this.each(function(){var o=t(this),n=o.data("bs.scrollspy"),s="object"==typeof i&&i;n||o.data("bs.scrollspy",n=new e(this,s)),"string"==typeof i&&n[i]()})}e.VERSION="3.3.6",e.DEFAULTS={offset:10},e.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},e.prototype.refresh=function(){var e=this,i="offset",o=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),t.isWindow(this.$scrollElement[0])||(i="position",o=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var e=t(this),n=e.data("target")||e.attr("href"),s=/^#./.test(n)&&t(n);return s&&s.length&&s.is(":visible")&&[[s[i]().top+o,n]]||null}).sort(function(t,e){return t[0]-e[0]}).each(function(){e.offsets.push(this[0]),e.targets.push(this[1])})},e.prototype.process=function(){var t,e=this.$scrollElement.scrollTop()+this.options.offset,i=this.getScrollHeight(),o=this.options.offset+i-this.$scrollElement.height(),n=this.offsets,s=this.targets,a=this.activeTarget;if(this.scrollHeight!=i&&this.refresh(),e>=o)return a!=(t=s[s.length-1])&&this.activate(t);if(a&&e<n[0])return this.activeTarget=null,this.clear();for(t=n.length;t--;)a!=s[t]&&e>=n[t]&&(void 0===n[t+1]||e<n[t+1])&&this.activate(s[t])},e.prototype.activate=function(e){this.activeTarget=e,this.clear();var i=this.selector+'[data-target="'+e+'"],'+this.selector+'[href="'+e+'"]',o=t(i).parents("li").addClass("active");o.parent(".dropdown-menu").length&&(o=o.closest("li.dropdown").addClass("active")),o.trigger("activate.bs.scrollspy")},e.prototype.clear=function(){t(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var o=t.fn.scrollspy;t.fn.scrollspy=i,t.fn.scrollspy.Constructor=e,t.fn.scrollspy.noConflict=function(){return t.fn.scrollspy=o,this},t(window).on("load.bs.scrollspy.data-api",function(){t('[data-spy="scroll"]').each(function(){var e=t(this);i.call(e,e.data())})})}(jQuery),+function(t){"use strict";function e(){var t=document.createElement("bootstrap"),e={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var i in e)if(void 0!==t.style[i])return{end:e[i]};return!1}t.fn.emulateTransitionEnd=function(e){var i=!1,o=this;t(this).one("bsTransitionEnd",function(){i=!0});var n=function(){i||t(o).trigger(t.support.transition.end)};return setTimeout(n,e),this},t(function(){t.support.transition=e(),t.support.transition&&(t.event.special.bsTransitionEnd={bindType:t.support.transition.end,delegateType:t.support.transition.end,handle:function(e){return t(e.target).is(this)?e.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery);
/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
!function(a){"use strict";"function"==typeof define&&define.amd?define(["jquery"],a):"undefined"!=typeof exports?module.exports=a(require("jquery")):a(jQuery)}(function(a){"use strict";var b=window.Slick||{};b=function(){function c(c,d){var f,e=this;e.defaults={accessibility:!0,adaptiveHeight:!1,appendArrows:a(c),appendDots:a(c),arrows:!0,asNavFor:null,prevArrow:'<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',nextArrow:'<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',autoplay:!1,autoplaySpeed:3e3,centerMode:!1,centerPadding:"50px",cssEase:"ease",customPaging:function(b,c){return a('<button type="button" data-role="none" role="button" tabindex="0" />').text(c+1)},dots:!1,dotsClass:"slick-dots",draggable:!0,easing:"linear",edgeFriction:.35,fade:!1,focusOnSelect:!1,infinite:!0,initialSlide:0,lazyLoad:"ondemand",mobileFirst:!1,pauseOnHover:!0,pauseOnFocus:!0,pauseOnDotsHover:!1,respondTo:"window",responsive:null,rows:1,rtl:!1,slide:"",slidesPerRow:1,slidesToShow:1,slidesToScroll:1,speed:500,swipe:!0,swipeToSlide:!1,touchMove:!0,touchThreshold:5,useCSS:!0,useTransform:!0,variableWidth:!1,vertical:!1,verticalSwiping:!1,waitForAnimate:!0,zIndex:1e3},e.initials={animating:!1,dragging:!1,autoPlayTimer:null,currentDirection:0,currentLeft:null,currentSlide:0,direction:1,$dots:null,listWidth:null,listHeight:null,loadIndex:0,$nextArrow:null,$prevArrow:null,slideCount:null,slideWidth:null,$slideTrack:null,$slides:null,sliding:!1,slideOffset:0,swipeLeft:null,$list:null,touchObject:{},transformsEnabled:!1,unslicked:!1},a.extend(e,e.initials),e.activeBreakpoint=null,e.animType=null,e.animProp=null,e.breakpoints=[],e.breakpointSettings=[],e.cssTransitions=!1,e.focussed=!1,e.interrupted=!1,e.hidden="hidden",e.paused=!0,e.positionProp=null,e.respondTo=null,e.rowCount=1,e.shouldClick=!0,e.$slider=a(c),e.$slidesCache=null,e.transformType=null,e.transitionType=null,e.visibilityChange="visibilitychange",e.windowWidth=0,e.windowTimer=null,f=a(c).data("slick")||{},e.options=a.extend({},e.defaults,d,f),e.currentSlide=e.options.initialSlide,e.originalSettings=e.options,"undefined"!=typeof document.mozHidden?(e.hidden="mozHidden",e.visibilityChange="mozvisibilitychange"):"undefined"!=typeof document.webkitHidden&&(e.hidden="webkitHidden",e.visibilityChange="webkitvisibilitychange"),e.autoPlay=a.proxy(e.autoPlay,e),e.autoPlayClear=a.proxy(e.autoPlayClear,e),e.autoPlayIterator=a.proxy(e.autoPlayIterator,e),e.changeSlide=a.proxy(e.changeSlide,e),e.clickHandler=a.proxy(e.clickHandler,e),e.selectHandler=a.proxy(e.selectHandler,e),e.setPosition=a.proxy(e.setPosition,e),e.swipeHandler=a.proxy(e.swipeHandler,e),e.dragHandler=a.proxy(e.dragHandler,e),e.keyHandler=a.proxy(e.keyHandler,e),e.instanceUid=b++,e.htmlExpr=/^(?:\s*(<[\w\W]+>)[^>]*)$/,e.registerBreakpoints(),e.init(!0)}var b=0;return c}(),b.prototype.activateADA=function(){var a=this;a.$slideTrack.find(".slick-active").attr({"aria-hidden":"false"}).find("a, input, button, select").attr({tabindex:"0"})},b.prototype.addSlide=b.prototype.slickAdd=function(b,c,d){var e=this;if("boolean"==typeof c)d=c,c=null;else if(0>c||c>=e.slideCount)return!1;e.unload(),"number"==typeof c?0===c&&0===e.$slides.length?a(b).appendTo(e.$slideTrack):d?a(b).insertBefore(e.$slides.eq(c)):a(b).insertAfter(e.$slides.eq(c)):d===!0?a(b).prependTo(e.$slideTrack):a(b).appendTo(e.$slideTrack),e.$slides=e.$slideTrack.children(this.options.slide),e.$slideTrack.children(this.options.slide).detach(),e.$slideTrack.append(e.$slides),e.$slides.each(function(b,c){a(c).attr("data-slick-index",b)}),e.$slidesCache=e.$slides,e.reinit()},b.prototype.animateHeight=function(){var a=this;if(1===a.options.slidesToShow&&a.options.adaptiveHeight===!0&&a.options.vertical===!1){var b=a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.animate({height:b},a.options.speed)}},b.prototype.animateSlide=function(b,c){var d={},e=this;e.animateHeight(),e.options.rtl===!0&&e.options.vertical===!1&&(b=-b),e.transformsEnabled===!1?e.options.vertical===!1?e.$slideTrack.animate({left:b},e.options.speed,e.options.easing,c):e.$slideTrack.animate({top:b},e.options.speed,e.options.easing,c):e.cssTransitions===!1?(e.options.rtl===!0&&(e.currentLeft=-e.currentLeft),a({animStart:e.currentLeft}).animate({animStart:b},{duration:e.options.speed,easing:e.options.easing,step:function(a){a=Math.ceil(a),e.options.vertical===!1?(d[e.animType]="translate("+a+"px, 0px)",e.$slideTrack.css(d)):(d[e.animType]="translate(0px,"+a+"px)",e.$slideTrack.css(d))},complete:function(){c&&c.call()}})):(e.applyTransition(),b=Math.ceil(b),e.options.vertical===!1?d[e.animType]="translate3d("+b+"px, 0px, 0px)":d[e.animType]="translate3d(0px,"+b+"px, 0px)",e.$slideTrack.css(d),c&&setTimeout(function(){e.disableTransition(),c.call()},e.options.speed))},b.prototype.getNavTarget=function(){var b=this,c=b.options.asNavFor;return c&&null!==c&&(c=a(c).not(b.$slider)),c},b.prototype.asNavFor=function(b){var c=this,d=c.getNavTarget();null!==d&&"object"==typeof d&&d.each(function(){var c=a(this).slick("getSlick");c.unslicked||c.slideHandler(b,!0)})},b.prototype.applyTransition=function(a){var b=this,c={};b.options.fade===!1?c[b.transitionType]=b.transformType+" "+b.options.speed+"ms "+b.options.cssEase:c[b.transitionType]="opacity "+b.options.speed+"ms "+b.options.cssEase,b.options.fade===!1?b.$slideTrack.css(c):b.$slides.eq(a).css(c)},b.prototype.autoPlay=function(){var a=this;a.autoPlayClear(),a.slideCount>a.options.slidesToShow&&(a.autoPlayTimer=setInterval(a.autoPlayIterator,a.options.autoplaySpeed))},b.prototype.autoPlayClear=function(){var a=this;a.autoPlayTimer&&clearInterval(a.autoPlayTimer)},b.prototype.autoPlayIterator=function(){var a=this,b=a.currentSlide+a.options.slidesToScroll;a.paused||a.interrupted||a.focussed||(a.options.infinite===!1&&(1===a.direction&&a.currentSlide+1===a.slideCount-1?a.direction=0:0===a.direction&&(b=a.currentSlide-a.options.slidesToScroll,a.currentSlide-1===0&&(a.direction=1))),a.slideHandler(b))},b.prototype.buildArrows=function(){var b=this;b.options.arrows===!0&&(b.$prevArrow=a(b.options.prevArrow).addClass("slick-arrow"),b.$nextArrow=a(b.options.nextArrow).addClass("slick-arrow"),b.slideCount>b.options.slidesToShow?(b.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"),b.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"),b.htmlExpr.test(b.options.prevArrow)&&b.$prevArrow.prependTo(b.options.appendArrows),b.htmlExpr.test(b.options.nextArrow)&&b.$nextArrow.appendTo(b.options.appendArrows),b.options.infinite!==!0&&b.$prevArrow.addClass("slick-disabled").attr("aria-disabled","true")):b.$prevArrow.add(b.$nextArrow).addClass("slick-hidden").attr({"aria-disabled":"true",tabindex:"-1"}))},b.prototype.buildDots=function(){var c,d,b=this;if(b.options.dots===!0&&b.slideCount>b.options.slidesToShow){for(b.$slider.addClass("slick-dotted"),d=a("<ul />").addClass(b.options.dotsClass),c=0;c<=b.getDotCount();c+=1)d.append(a("<li />").append(b.options.customPaging.call(this,b,c)));b.$dots=d.appendTo(b.options.appendDots),b.$dots.find("li").first().addClass("slick-active").attr("aria-hidden","false")}},b.prototype.buildOut=function(){var b=this;b.$slides=b.$slider.children(b.options.slide+":not(.slick-cloned)").addClass("slick-slide"),b.slideCount=b.$slides.length,b.$slides.each(function(b,c){a(c).attr("data-slick-index",b).data("originalStyling",a(c).attr("style")||"")}),b.$slider.addClass("slick-slider"),b.$slideTrack=0===b.slideCount?a('<div class="slick-track"/>').appendTo(b.$slider):b.$slides.wrapAll('<div class="slick-track"/>').parent(),b.$list=b.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent(),b.$slideTrack.css("opacity",0),(b.options.centerMode===!0||b.options.swipeToSlide===!0)&&(b.options.slidesToScroll=1),a("img[data-lazy]",b.$slider).not("[src]").addClass("slick-loading"),b.setupInfinite(),b.buildArrows(),b.buildDots(),b.updateDots(),b.setSlideClasses("number"==typeof b.currentSlide?b.currentSlide:0),b.options.draggable===!0&&b.$list.addClass("draggable")},b.prototype.buildRows=function(){var b,c,d,e,f,g,h,a=this;if(e=document.createDocumentFragment(),g=a.$slider.children(),a.options.rows>1){for(h=a.options.slidesPerRow*a.options.rows,f=Math.ceil(g.length/h),b=0;f>b;b++){var i=document.createElement("div");for(c=0;c<a.options.rows;c++){var j=document.createElement("div");for(d=0;d<a.options.slidesPerRow;d++){var k=b*h+(c*a.options.slidesPerRow+d);g.get(k)&&j.appendChild(g.get(k))}i.appendChild(j)}e.appendChild(i)}a.$slider.empty().append(e),a.$slider.children().children().children().css({width:100/a.options.slidesPerRow+"%",display:"inline-block"})}},b.prototype.checkResponsive=function(b,c){var e,f,g,d=this,h=!1,i=d.$slider.width(),j=window.innerWidth||a(window).width();if("window"===d.respondTo?g=j:"slider"===d.respondTo?g=i:"min"===d.respondTo&&(g=Math.min(j,i)),d.options.responsive&&d.options.responsive.length&&null!==d.options.responsive){f=null;for(e in d.breakpoints)d.breakpoints.hasOwnProperty(e)&&(d.originalSettings.mobileFirst===!1?g<d.breakpoints[e]&&(f=d.breakpoints[e]):g>d.breakpoints[e]&&(f=d.breakpoints[e]));null!==f?null!==d.activeBreakpoint?(f!==d.activeBreakpoint||c)&&(d.activeBreakpoint=f,"unslick"===d.breakpointSettings[f]?d.unslick(f):(d.options=a.extend({},d.originalSettings,d.breakpointSettings[f]),b===!0&&(d.currentSlide=d.options.initialSlide),d.refresh(b)),h=f):(d.activeBreakpoint=f,"unslick"===d.breakpointSettings[f]?d.unslick(f):(d.options=a.extend({},d.originalSettings,d.breakpointSettings[f]),b===!0&&(d.currentSlide=d.options.initialSlide),d.refresh(b)),h=f):null!==d.activeBreakpoint&&(d.activeBreakpoint=null,d.options=d.originalSettings,b===!0&&(d.currentSlide=d.options.initialSlide),d.refresh(b),h=f),b||h===!1||d.$slider.trigger("breakpoint",[d,h])}},b.prototype.changeSlide=function(b,c){var f,g,h,d=this,e=a(b.currentTarget);switch(e.is("a")&&b.preventDefault(),e.is("li")||(e=e.closest("li")),h=d.slideCount%d.options.slidesToScroll!==0,f=h?0:(d.slideCount-d.currentSlide)%d.options.slidesToScroll,b.data.message){case"previous":g=0===f?d.options.slidesToScroll:d.options.slidesToShow-f,d.slideCount>d.options.slidesToShow&&d.slideHandler(d.currentSlide-g,!1,c);break;case"next":g=0===f?d.options.slidesToScroll:f,d.slideCount>d.options.slidesToShow&&d.slideHandler(d.currentSlide+g,!1,c);break;case"index":var i=0===b.data.index?0:b.data.index||e.index()*d.options.slidesToScroll;d.slideHandler(d.checkNavigable(i),!1,c),e.children().trigger("focus");break;default:return}},b.prototype.checkNavigable=function(a){var c,d,b=this;if(c=b.getNavigableIndexes(),d=0,a>c[c.length-1])a=c[c.length-1];else for(var e in c){if(a<c[e]){a=d;break}d=c[e]}return a},b.prototype.cleanUpEvents=function(){var b=this;b.options.dots&&null!==b.$dots&&a("li",b.$dots).off("click.slick",b.changeSlide).off("mouseenter.slick",a.proxy(b.interrupt,b,!0)).off("mouseleave.slick",a.proxy(b.interrupt,b,!1)),b.$slider.off("focus.slick blur.slick"),b.options.arrows===!0&&b.slideCount>b.options.slidesToShow&&(b.$prevArrow&&b.$prevArrow.off("click.slick",b.changeSlide),b.$nextArrow&&b.$nextArrow.off("click.slick",b.changeSlide)),b.$list.off("touchstart.slick mousedown.slick",b.swipeHandler),b.$list.off("touchmove.slick mousemove.slick",b.swipeHandler),b.$list.off("touchend.slick mouseup.slick",b.swipeHandler),b.$list.off("touchcancel.slick mouseleave.slick",b.swipeHandler),b.$list.off("click.slick",b.clickHandler),a(document).off(b.visibilityChange,b.visibility),b.cleanUpSlideEvents(),b.options.accessibility===!0&&b.$list.off("keydown.slick",b.keyHandler),b.options.focusOnSelect===!0&&a(b.$slideTrack).children().off("click.slick",b.selectHandler),a(window).off("orientationchange.slick.slick-"+b.instanceUid,b.orientationChange),a(window).off("resize.slick.slick-"+b.instanceUid,b.resize),a("[draggable!=true]",b.$slideTrack).off("dragstart",b.preventDefault),a(window).off("load.slick.slick-"+b.instanceUid,b.setPosition),a(document).off("ready.slick.slick-"+b.instanceUid,b.setPosition)},b.prototype.cleanUpSlideEvents=function(){var b=this;b.$list.off("mouseenter.slick",a.proxy(b.interrupt,b,!0)),b.$list.off("mouseleave.slick",a.proxy(b.interrupt,b,!1))},b.prototype.cleanUpRows=function(){var b,a=this;a.options.rows>1&&(b=a.$slides.children().children(),b.removeAttr("style"),a.$slider.empty().append(b))},b.prototype.clickHandler=function(a){var b=this;b.shouldClick===!1&&(a.stopImmediatePropagation(),a.stopPropagation(),a.preventDefault())},b.prototype.destroy=function(b){var c=this;c.autoPlayClear(),c.touchObject={},c.cleanUpEvents(),a(".slick-cloned",c.$slider).detach(),c.$dots&&c.$dots.remove(),c.$prevArrow&&c.$prevArrow.length&&(c.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display",""),c.htmlExpr.test(c.options.prevArrow)&&c.$prevArrow.remove()),c.$nextArrow&&c.$nextArrow.length&&(c.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display",""),c.htmlExpr.test(c.options.nextArrow)&&c.$nextArrow.remove()),c.$slides&&(c.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function(){a(this).attr("style",a(this).data("originalStyling"))}),c.$slideTrack.children(this.options.slide).detach(),c.$slideTrack.detach(),c.$list.detach(),c.$slider.append(c.$slides)),c.cleanUpRows(),c.$slider.removeClass("slick-slider"),c.$slider.removeClass("slick-initialized"),c.$slider.removeClass("slick-dotted"),c.unslicked=!0,b||c.$slider.trigger("destroy",[c])},b.prototype.disableTransition=function(a){var b=this,c={};c[b.transitionType]="",b.options.fade===!1?b.$slideTrack.css(c):b.$slides.eq(a).css(c)},b.prototype.fadeSlide=function(a,b){var c=this;c.cssTransitions===!1?(c.$slides.eq(a).css({zIndex:c.options.zIndex}),c.$slides.eq(a).animate({opacity:1},c.options.speed,c.options.easing,b)):(c.applyTransition(a),c.$slides.eq(a).css({opacity:1,zIndex:c.options.zIndex}),b&&setTimeout(function(){c.disableTransition(a),b.call()},c.options.speed))},b.prototype.fadeSlideOut=function(a){var b=this;b.cssTransitions===!1?b.$slides.eq(a).animate({opacity:0,zIndex:b.options.zIndex-2},b.options.speed,b.options.easing):(b.applyTransition(a),b.$slides.eq(a).css({opacity:0,zIndex:b.options.zIndex-2}))},b.prototype.filterSlides=b.prototype.slickFilter=function(a){var b=this;null!==a&&(b.$slidesCache=b.$slides,b.unload(),b.$slideTrack.children(this.options.slide).detach(),b.$slidesCache.filter(a).appendTo(b.$slideTrack),b.reinit())},b.prototype.focusHandler=function(){var b=this;b.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick","*:not(.slick-arrow)",function(c){c.stopImmediatePropagation();var d=a(this);setTimeout(function(){b.options.pauseOnFocus&&(b.focussed=d.is(":focus"),b.autoPlay())},0)})},b.prototype.getCurrent=b.prototype.slickCurrentSlide=function(){var a=this;return a.currentSlide},b.prototype.getDotCount=function(){var a=this,b=0,c=0,d=0;if(a.options.infinite===!0)for(;b<a.slideCount;)++d,b=c+a.options.slidesToScroll,c+=a.options.slidesToScroll<=a.options.slidesToShow?a.options.slidesToScroll:a.options.slidesToShow;else if(a.options.centerMode===!0)d=a.slideCount;else if(a.options.asNavFor)for(;b<a.slideCount;)++d,b=c+a.options.slidesToScroll,c+=a.options.slidesToScroll<=a.options.slidesToShow?a.options.slidesToScroll:a.options.slidesToShow;else d=1+Math.ceil((a.slideCount-a.options.slidesToShow)/a.options.slidesToScroll);return d-1},b.prototype.getLeft=function(a){var c,d,f,b=this,e=0;return b.slideOffset=0,d=b.$slides.first().outerHeight(!0),b.options.infinite===!0?(b.slideCount>b.options.slidesToShow&&(b.slideOffset=b.slideWidth*b.options.slidesToShow*-1,e=d*b.options.slidesToShow*-1),b.slideCount%b.options.slidesToScroll!==0&&a+b.options.slidesToScroll>b.slideCount&&b.slideCount>b.options.slidesToShow&&(a>b.slideCount?(b.slideOffset=(b.options.slidesToShow-(a-b.slideCount))*b.slideWidth*-1,e=(b.options.slidesToShow-(a-b.slideCount))*d*-1):(b.slideOffset=b.slideCount%b.options.slidesToScroll*b.slideWidth*-1,e=b.slideCount%b.options.slidesToScroll*d*-1))):a+b.options.slidesToShow>b.slideCount&&(b.slideOffset=(a+b.options.slidesToShow-b.slideCount)*b.slideWidth,e=(a+b.options.slidesToShow-b.slideCount)*d),b.slideCount<=b.options.slidesToShow&&(b.slideOffset=0,e=0),b.options.centerMode===!0&&b.options.infinite===!0?b.slideOffset+=b.slideWidth*Math.floor(b.options.slidesToShow/2)-b.slideWidth:b.options.centerMode===!0&&(b.slideOffset=0,b.slideOffset+=b.slideWidth*Math.floor(b.options.slidesToShow/2)),c=b.options.vertical===!1?a*b.slideWidth*-1+b.slideOffset:a*d*-1+e,b.options.variableWidth===!0&&(f=b.slideCount<=b.options.slidesToShow||b.options.infinite===!1?b.$slideTrack.children(".slick-slide").eq(a):b.$slideTrack.children(".slick-slide").eq(a+b.options.slidesToShow),c=b.options.rtl===!0?f[0]?-1*(b.$slideTrack.width()-f[0].offsetLeft-f.width()):0:f[0]?-1*f[0].offsetLeft:0,b.options.centerMode===!0&&(f=b.slideCount<=b.options.slidesToShow||b.options.infinite===!1?b.$slideTrack.children(".slick-slide").eq(a):b.$slideTrack.children(".slick-slide").eq(a+b.options.slidesToShow+1),c=b.options.rtl===!0?f[0]?-1*(b.$slideTrack.width()-f[0].offsetLeft-f.width()):0:f[0]?-1*f[0].offsetLeft:0,c+=(b.$list.width()-f.outerWidth())/2)),c},b.prototype.getOption=b.prototype.slickGetOption=function(a){var b=this;return b.options[a]},b.prototype.getNavigableIndexes=function(){var e,a=this,b=0,c=0,d=[];for(a.options.infinite===!1?e=a.slideCount:(b=-1*a.options.slidesToScroll,c=-1*a.options.slidesToScroll,e=2*a.slideCount);e>b;)d.push(b),b=c+a.options.slidesToScroll,c+=a.options.slidesToScroll<=a.options.slidesToShow?a.options.slidesToScroll:a.options.slidesToShow;return d},b.prototype.getSlick=function(){return this},b.prototype.getSlideCount=function(){var c,d,e,b=this;return e=b.options.centerMode===!0?b.slideWidth*Math.floor(b.options.slidesToShow/2):0,b.options.swipeToSlide===!0?(b.$slideTrack.find(".slick-slide").each(function(c,f){return f.offsetLeft-e+a(f).outerWidth()/2>-1*b.swipeLeft?(d=f,!1):void 0}),c=Math.abs(a(d).attr("data-slick-index")-b.currentSlide)||1):b.options.slidesToScroll},b.prototype.goTo=b.prototype.slickGoTo=function(a,b){var c=this;c.changeSlide({data:{message:"index",index:parseInt(a)}},b)},b.prototype.init=function(b){var c=this;a(c.$slider).hasClass("slick-initialized")||(a(c.$slider).addClass("slick-initialized"),c.buildRows(),c.buildOut(),c.setProps(),c.startLoad(),c.loadSlider(),c.initializeEvents(),c.updateArrows(),c.updateDots(),c.checkResponsive(!0),c.focusHandler()),b&&c.$slider.trigger("init",[c]),c.options.accessibility===!0&&c.initADA(),c.options.autoplay&&(c.paused=!1,c.autoPlay())},b.prototype.initADA=function(){var b=this;b.$slides.add(b.$slideTrack.find(".slick-cloned")).attr({"aria-hidden":"true",tabindex:"-1"}).find("a, input, button, select").attr({tabindex:"-1"}),b.$slideTrack.attr("role","listbox"),b.$slides.not(b.$slideTrack.find(".slick-cloned")).each(function(c){a(this).attr({role:"option","aria-describedby":"slick-slide"+b.instanceUid+c})}),null!==b.$dots&&b.$dots.attr("role","tablist").find("li").each(function(c){a(this).attr({role:"presentation","aria-selected":"false","aria-controls":"navigation"+b.instanceUid+c,id:"slick-slide"+b.instanceUid+c})}).first().attr("aria-selected","true").end().find("button").attr("role","button").end().closest("div").attr("role","toolbar"),b.activateADA()},b.prototype.initArrowEvents=function(){var a=this;a.options.arrows===!0&&a.slideCount>a.options.slidesToShow&&(a.$prevArrow.off("click.slick").on("click.slick",{message:"previous"},a.changeSlide),a.$nextArrow.off("click.slick").on("click.slick",{message:"next"},a.changeSlide))},b.prototype.initDotEvents=function(){var b=this;b.options.dots===!0&&b.slideCount>b.options.slidesToShow&&a("li",b.$dots).on("click.slick",{message:"index"},b.changeSlide),b.options.dots===!0&&b.options.pauseOnDotsHover===!0&&a("li",b.$dots).on("mouseenter.slick",a.proxy(b.interrupt,b,!0)).on("mouseleave.slick",a.proxy(b.interrupt,b,!1))},b.prototype.initSlideEvents=function(){var b=this;b.options.pauseOnHover&&(b.$list.on("mouseenter.slick",a.proxy(b.interrupt,b,!0)),b.$list.on("mouseleave.slick",a.proxy(b.interrupt,b,!1)))},b.prototype.initializeEvents=function(){var b=this;b.initArrowEvents(),b.initDotEvents(),b.initSlideEvents(),b.$list.on("touchstart.slick mousedown.slick",{action:"start"},b.swipeHandler),b.$list.on("touchmove.slick mousemove.slick",{action:"move"},b.swipeHandler),b.$list.on("touchend.slick mouseup.slick",{action:"end"},b.swipeHandler),b.$list.on("touchcancel.slick mouseleave.slick",{action:"end"},b.swipeHandler),b.$list.on("click.slick",b.clickHandler),a(document).on(b.visibilityChange,a.proxy(b.visibility,b)),b.options.accessibility===!0&&b.$list.on("keydown.slick",b.keyHandler),b.options.focusOnSelect===!0&&a(b.$slideTrack).children().on("click.slick",b.selectHandler),a(window).on("orientationchange.slick.slick-"+b.instanceUid,a.proxy(b.orientationChange,b)),a(window).on("resize.slick.slick-"+b.instanceUid,a.proxy(b.resize,b)),a("[draggable!=true]",b.$slideTrack).on("dragstart",b.preventDefault),a(window).on("load.slick.slick-"+b.instanceUid,b.setPosition),a(document).on("ready.slick.slick-"+b.instanceUid,b.setPosition)},b.prototype.initUI=function(){var a=this;a.options.arrows===!0&&a.slideCount>a.options.slidesToShow&&(a.$prevArrow.show(),a.$nextArrow.show()),a.options.dots===!0&&a.slideCount>a.options.slidesToShow&&a.$dots.show()},b.prototype.keyHandler=function(a){var b=this;a.target.tagName.match("TEXTAREA|INPUT|SELECT")||(37===a.keyCode&&b.options.accessibility===!0?b.changeSlide({data:{message:b.options.rtl===!0?"next":"previous"}}):39===a.keyCode&&b.options.accessibility===!0&&b.changeSlide({data:{message:b.options.rtl===!0?"previous":"next"}}))},b.prototype.lazyLoad=function(){function g(c){a("img[data-lazy]",c).each(function(){var c=a(this),d=a(this).attr("data-lazy"),e=document.createElement("img");e.onload=function(){c.animate({opacity:0},100,function(){c.attr("src",d).animate({opacity:1},200,function(){c.removeAttr("data-lazy").removeClass("slick-loading")}),b.$slider.trigger("lazyLoaded",[b,c,d])})},e.onerror=function(){c.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"),b.$slider.trigger("lazyLoadError",[b,c,d])},e.src=d})}var c,d,e,f,b=this;b.options.centerMode===!0?b.options.infinite===!0?(e=b.currentSlide+(b.options.slidesToShow/2+1),f=e+b.options.slidesToShow+2):(e=Math.max(0,b.currentSlide-(b.options.slidesToShow/2+1)),f=2+(b.options.slidesToShow/2+1)+b.currentSlide):(e=b.options.infinite?b.options.slidesToShow+b.currentSlide:b.currentSlide,f=Math.ceil(e+b.options.slidesToShow),b.options.fade===!0&&(e>0&&e--,f<=b.slideCount&&f++)),c=b.$slider.find(".slick-slide").slice(e,f),g(c),b.slideCount<=b.options.slidesToShow?(d=b.$slider.find(".slick-slide"),g(d)):b.currentSlide>=b.slideCount-b.options.slidesToShow?(d=b.$slider.find(".slick-cloned").slice(0,b.options.slidesToShow),g(d)):0===b.currentSlide&&(d=b.$slider.find(".slick-cloned").slice(-1*b.options.slidesToShow),g(d))},b.prototype.loadSlider=function(){var a=this;a.setPosition(),a.$slideTrack.css({opacity:1}),a.$slider.removeClass("slick-loading"),a.initUI(),"progressive"===a.options.lazyLoad&&a.progressiveLazyLoad()},b.prototype.next=b.prototype.slickNext=function(){var a=this;a.changeSlide({data:{message:"next"}})},b.prototype.orientationChange=function(){var a=this;a.checkResponsive(),a.setPosition()},b.prototype.pause=b.prototype.slickPause=function(){var a=this;a.autoPlayClear(),a.paused=!0},b.prototype.play=b.prototype.slickPlay=function(){var a=this;a.autoPlay(),a.options.autoplay=!0,a.paused=!1,a.focussed=!1,a.interrupted=!1},b.prototype.postSlide=function(a){var b=this;b.unslicked||(b.$slider.trigger("afterChange",[b,a]),b.animating=!1,b.setPosition(),b.swipeLeft=null,b.options.autoplay&&b.autoPlay(),b.options.accessibility===!0&&b.initADA())},b.prototype.prev=b.prototype.slickPrev=function(){var a=this;a.changeSlide({data:{message:"previous"}})},b.prototype.preventDefault=function(a){a.preventDefault()},b.prototype.progressiveLazyLoad=function(b){b=b||1;var e,f,g,c=this,d=a("img[data-lazy]",c.$slider);d.length?(e=d.first(),f=e.attr("data-lazy"),g=document.createElement("img"),g.onload=function(){e.attr("src",f).removeAttr("data-lazy").removeClass("slick-loading"),c.options.adaptiveHeight===!0&&c.setPosition(),c.$slider.trigger("lazyLoaded",[c,e,f]),c.progressiveLazyLoad()},g.onerror=function(){3>b?setTimeout(function(){c.progressiveLazyLoad(b+1)},500):(e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"),c.$slider.trigger("lazyLoadError",[c,e,f]),c.progressiveLazyLoad())},g.src=f):c.$slider.trigger("allImagesLoaded",[c])},b.prototype.refresh=function(b){var d,e,c=this;e=c.slideCount-c.options.slidesToShow,!c.options.infinite&&c.currentSlide>e&&(c.currentSlide=e),c.slideCount<=c.options.slidesToShow&&(c.currentSlide=0),d=c.currentSlide,c.destroy(!0),a.extend(c,c.initials,{currentSlide:d}),c.init(),b||c.changeSlide({data:{message:"index",index:d}},!1)},b.prototype.registerBreakpoints=function(){var c,d,e,b=this,f=b.options.responsive||null;if("array"===a.type(f)&&f.length){b.respondTo=b.options.respondTo||"window";for(c in f)if(e=b.breakpoints.length-1,d=f[c].breakpoint,f.hasOwnProperty(c)){for(;e>=0;)b.breakpoints[e]&&b.breakpoints[e]===d&&b.breakpoints.splice(e,1),e--;b.breakpoints.push(d),b.breakpointSettings[d]=f[c].settings}b.breakpoints.sort(function(a,c){return b.options.mobileFirst?a-c:c-a})}},b.prototype.reinit=function(){var b=this;b.$slides=b.$slideTrack.children(b.options.slide).addClass("slick-slide"),b.slideCount=b.$slides.length,b.currentSlide>=b.slideCount&&0!==b.currentSlide&&(b.currentSlide=b.currentSlide-b.options.slidesToScroll),b.slideCount<=b.options.slidesToShow&&(b.currentSlide=0),b.registerBreakpoints(),b.setProps(),b.setupInfinite(),b.buildArrows(),b.updateArrows(),b.initArrowEvents(),b.buildDots(),b.updateDots(),b.initDotEvents(),b.cleanUpSlideEvents(),b.initSlideEvents(),b.checkResponsive(!1,!0),b.options.focusOnSelect===!0&&a(b.$slideTrack).children().on("click.slick",b.selectHandler),b.setSlideClasses("number"==typeof b.currentSlide?b.currentSlide:0),b.setPosition(),b.focusHandler(),b.paused=!b.options.autoplay,b.autoPlay(),b.$slider.trigger("reInit",[b])},b.prototype.resize=function(){var b=this;a(window).width()!==b.windowWidth&&(clearTimeout(b.windowDelay),b.windowDelay=window.setTimeout(function(){b.windowWidth=a(window).width(),b.checkResponsive(),b.unslicked||b.setPosition()},50))},b.prototype.removeSlide=b.prototype.slickRemove=function(a,b,c){var d=this;return"boolean"==typeof a?(b=a,a=b===!0?0:d.slideCount-1):a=b===!0?--a:a,d.slideCount<1||0>a||a>d.slideCount-1?!1:(d.unload(),c===!0?d.$slideTrack.children().remove():d.$slideTrack.children(this.options.slide).eq(a).remove(),d.$slides=d.$slideTrack.children(this.options.slide),d.$slideTrack.children(this.options.slide).detach(),d.$slideTrack.append(d.$slides),d.$slidesCache=d.$slides,void d.reinit())},b.prototype.setCSS=function(a){var d,e,b=this,c={};b.options.rtl===!0&&(a=-a),d="left"==b.positionProp?Math.ceil(a)+"px":"0px",e="top"==b.positionProp?Math.ceil(a)+"px":"0px",c[b.positionProp]=a,b.transformsEnabled===!1?b.$slideTrack.css(c):(c={},b.cssTransitions===!1?(c[b.animType]="translate("+d+", "+e+")",b.$slideTrack.css(c)):(c[b.animType]="translate3d("+d+", "+e+", 0px)",b.$slideTrack.css(c)))},b.prototype.setDimensions=function(){var a=this;a.options.vertical===!1?a.options.centerMode===!0&&a.$list.css({padding:"0px "+a.options.centerPadding}):(a.$list.height(a.$slides.first().outerHeight(!0)*a.options.slidesToShow),a.options.centerMode===!0&&a.$list.css({padding:a.options.centerPadding+" 0px"})),a.listWidth=a.$list.width(),a.listHeight=a.$list.height(),a.options.vertical===!1&&a.options.variableWidth===!1?(a.slideWidth=Math.ceil(a.listWidth/a.options.slidesToShow),a.$slideTrack.width(Math.ceil(a.slideWidth*a.$slideTrack.children(".slick-slide").length))):a.options.variableWidth===!0?a.$slideTrack.width(5e3*a.slideCount):(a.slideWidth=Math.ceil(a.listWidth),a.$slideTrack.height(Math.ceil(a.$slides.first().outerHeight(!0)*a.$slideTrack.children(".slick-slide").length)));var b=a.$slides.first().outerWidth(!0)-a.$slides.first().width();a.options.variableWidth===!1&&a.$slideTrack.children(".slick-slide").width(a.slideWidth-b)},b.prototype.setFade=function(){var c,b=this;b.$slides.each(function(d,e){c=b.slideWidth*d*-1,b.options.rtl===!0?a(e).css({position:"relative",right:c,top:0,zIndex:b.options.zIndex-2,opacity:0}):a(e).css({position:"relative",left:c,top:0,zIndex:b.options.zIndex-2,opacity:0})}),b.$slides.eq(b.currentSlide).css({zIndex:b.options.zIndex-1,opacity:1})},b.prototype.setHeight=function(){var a=this;if(1===a.options.slidesToShow&&a.options.adaptiveHeight===!0&&a.options.vertical===!1){var b=a.$slides.eq(a.currentSlide).outerHeight(!0);a.$list.css("height",b)}},b.prototype.setOption=b.prototype.slickSetOption=function(){var c,d,e,f,h,b=this,g=!1;if("object"===a.type(arguments[0])?(e=arguments[0],g=arguments[1],h="multiple"):"string"===a.type(arguments[0])&&(e=arguments[0],f=arguments[1],g=arguments[2],"responsive"===arguments[0]&&"array"===a.type(arguments[1])?h="responsive":"undefined"!=typeof arguments[1]&&(h="single")),"single"===h)b.options[e]=f;else if("multiple"===h)a.each(e,function(a,c){b.options[a]=c});else if("responsive"===h)for(d in f)if("array"!==a.type(b.options.responsive))b.options.responsive=[f[d]];else{for(c=b.options.responsive.length-1;c>=0;)b.options.responsive[c].breakpoint===f[d].breakpoint&&b.options.responsive.splice(c,1),c--;b.options.responsive.push(f[d])}g&&(b.unload(),b.reinit())},b.prototype.setPosition=function(){var a=this;a.setDimensions(),a.setHeight(),a.options.fade===!1?a.setCSS(a.getLeft(a.currentSlide)):a.setFade(),a.$slider.trigger("setPosition",[a])},b.prototype.setProps=function(){var a=this,b=document.body.style;a.positionProp=a.options.vertical===!0?"top":"left","top"===a.positionProp?a.$slider.addClass("slick-vertical"):a.$slider.removeClass("slick-vertical"),(void 0!==b.WebkitTransition||void 0!==b.MozTransition||void 0!==b.msTransition)&&a.options.useCSS===!0&&(a.cssTransitions=!0),a.options.fade&&("number"==typeof a.options.zIndex?a.options.zIndex<3&&(a.options.zIndex=3):a.options.zIndex=a.defaults.zIndex),void 0!==b.OTransform&&(a.animType="OTransform",a.transformType="-o-transform",a.transitionType="OTransition",void 0===b.perspectiveProperty&&void 0===b.webkitPerspective&&(a.animType=!1)),void 0!==b.MozTransform&&(a.animType="MozTransform",a.transformType="-moz-transform",a.transitionType="MozTransition",void 0===b.perspectiveProperty&&void 0===b.MozPerspective&&(a.animType=!1)),void 0!==b.webkitTransform&&(a.animType="webkitTransform",a.transformType="-webkit-transform",a.transitionType="webkitTransition",void 0===b.perspectiveProperty&&void 0===b.webkitPerspective&&(a.animType=!1)),void 0!==b.msTransform&&(a.animType="msTransform",a.transformType="-ms-transform",a.transitionType="msTransition",void 0===b.msTransform&&(a.animType=!1)),void 0!==b.transform&&a.animType!==!1&&(a.animType="transform",a.transformType="transform",a.transitionType="transition"),a.transformsEnabled=a.options.useTransform&&null!==a.animType&&a.animType!==!1},b.prototype.setSlideClasses=function(a){var c,d,e,f,b=this;d=b.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden","true"),b.$slides.eq(a).addClass("slick-current"),b.options.centerMode===!0?(c=Math.floor(b.options.slidesToShow/2),b.options.infinite===!0&&(a>=c&&a<=b.slideCount-1-c?b.$slides.slice(a-c,a+c+1).addClass("slick-active").attr("aria-hidden","false"):(e=b.options.slidesToShow+a,
d.slice(e-c+1,e+c+2).addClass("slick-active").attr("aria-hidden","false")),0===a?d.eq(d.length-1-b.options.slidesToShow).addClass("slick-center"):a===b.slideCount-1&&d.eq(b.options.slidesToShow).addClass("slick-center")),b.$slides.eq(a).addClass("slick-center")):a>=0&&a<=b.slideCount-b.options.slidesToShow?b.$slides.slice(a,a+b.options.slidesToShow).addClass("slick-active").attr("aria-hidden","false"):d.length<=b.options.slidesToShow?d.addClass("slick-active").attr("aria-hidden","false"):(f=b.slideCount%b.options.slidesToShow,e=b.options.infinite===!0?b.options.slidesToShow+a:a,b.options.slidesToShow==b.options.slidesToScroll&&b.slideCount-a<b.options.slidesToShow?d.slice(e-(b.options.slidesToShow-f),e+f).addClass("slick-active").attr("aria-hidden","false"):d.slice(e,e+b.options.slidesToShow).addClass("slick-active").attr("aria-hidden","false")),"ondemand"===b.options.lazyLoad&&b.lazyLoad()},b.prototype.setupInfinite=function(){var c,d,e,b=this;if(b.options.fade===!0&&(b.options.centerMode=!1),b.options.infinite===!0&&b.options.fade===!1&&(d=null,b.slideCount>b.options.slidesToShow)){for(e=b.options.centerMode===!0?b.options.slidesToShow+1:b.options.slidesToShow,c=b.slideCount;c>b.slideCount-e;c-=1)d=c-1,a(b.$slides[d]).clone(!0).attr("id","").attr("data-slick-index",d-b.slideCount).prependTo(b.$slideTrack).addClass("slick-cloned");for(c=0;e>c;c+=1)d=c,a(b.$slides[d]).clone(!0).attr("id","").attr("data-slick-index",d+b.slideCount).appendTo(b.$slideTrack).addClass("slick-cloned");b.$slideTrack.find(".slick-cloned").find("[id]").each(function(){a(this).attr("id","")})}},b.prototype.interrupt=function(a){var b=this;a||b.autoPlay(),b.interrupted=a},b.prototype.selectHandler=function(b){var c=this,d=a(b.target).is(".slick-slide")?a(b.target):a(b.target).parents(".slick-slide"),e=parseInt(d.attr("data-slick-index"));return e||(e=0),c.slideCount<=c.options.slidesToShow?(c.setSlideClasses(e),void c.asNavFor(e)):void c.slideHandler(e)},b.prototype.slideHandler=function(a,b,c){var d,e,f,g,j,h=null,i=this;return b=b||!1,i.animating===!0&&i.options.waitForAnimate===!0||i.options.fade===!0&&i.currentSlide===a||i.slideCount<=i.options.slidesToShow?void 0:(b===!1&&i.asNavFor(a),d=a,h=i.getLeft(d),g=i.getLeft(i.currentSlide),i.currentLeft=null===i.swipeLeft?g:i.swipeLeft,i.options.infinite===!1&&i.options.centerMode===!1&&(0>a||a>i.getDotCount()*i.options.slidesToScroll)?void(i.options.fade===!1&&(d=i.currentSlide,c!==!0?i.animateSlide(g,function(){i.postSlide(d)}):i.postSlide(d))):i.options.infinite===!1&&i.options.centerMode===!0&&(0>a||a>i.slideCount-i.options.slidesToScroll)?void(i.options.fade===!1&&(d=i.currentSlide,c!==!0?i.animateSlide(g,function(){i.postSlide(d)}):i.postSlide(d))):(i.options.autoplay&&clearInterval(i.autoPlayTimer),e=0>d?i.slideCount%i.options.slidesToScroll!==0?i.slideCount-i.slideCount%i.options.slidesToScroll:i.slideCount+d:d>=i.slideCount?i.slideCount%i.options.slidesToScroll!==0?0:d-i.slideCount:d,i.animating=!0,i.$slider.trigger("beforeChange",[i,i.currentSlide,e]),f=i.currentSlide,i.currentSlide=e,i.setSlideClasses(i.currentSlide),i.options.asNavFor&&(j=i.getNavTarget(),j=j.slick("getSlick"),j.slideCount<=j.options.slidesToShow&&j.setSlideClasses(i.currentSlide)),i.updateDots(),i.updateArrows(),i.options.fade===!0?(c!==!0?(i.fadeSlideOut(f),i.fadeSlide(e,function(){i.postSlide(e)})):i.postSlide(e),void i.animateHeight()):void(c!==!0?i.animateSlide(h,function(){i.postSlide(e)}):i.postSlide(e))))},b.prototype.startLoad=function(){var a=this;a.options.arrows===!0&&a.slideCount>a.options.slidesToShow&&(a.$prevArrow.hide(),a.$nextArrow.hide()),a.options.dots===!0&&a.slideCount>a.options.slidesToShow&&a.$dots.hide(),a.$slider.addClass("slick-loading")},b.prototype.swipeDirection=function(){var a,b,c,d,e=this;return a=e.touchObject.startX-e.touchObject.curX,b=e.touchObject.startY-e.touchObject.curY,c=Math.atan2(b,a),d=Math.round(180*c/Math.PI),0>d&&(d=360-Math.abs(d)),45>=d&&d>=0?e.options.rtl===!1?"left":"right":360>=d&&d>=315?e.options.rtl===!1?"left":"right":d>=135&&225>=d?e.options.rtl===!1?"right":"left":e.options.verticalSwiping===!0?d>=35&&135>=d?"down":"up":"vertical"},b.prototype.swipeEnd=function(a){var c,d,b=this;if(b.dragging=!1,b.interrupted=!1,b.shouldClick=b.touchObject.swipeLength>10?!1:!0,void 0===b.touchObject.curX)return!1;if(b.touchObject.edgeHit===!0&&b.$slider.trigger("edge",[b,b.swipeDirection()]),b.touchObject.swipeLength>=b.touchObject.minSwipe){switch(d=b.swipeDirection()){case"left":case"down":c=b.options.swipeToSlide?b.checkNavigable(b.currentSlide+b.getSlideCount()):b.currentSlide+b.getSlideCount(),b.currentDirection=0;break;case"right":case"up":c=b.options.swipeToSlide?b.checkNavigable(b.currentSlide-b.getSlideCount()):b.currentSlide-b.getSlideCount(),b.currentDirection=1}"vertical"!=d&&(b.slideHandler(c),b.touchObject={},b.$slider.trigger("swipe",[b,d]))}else b.touchObject.startX!==b.touchObject.curX&&(b.slideHandler(b.currentSlide),b.touchObject={})},b.prototype.swipeHandler=function(a){var b=this;if(!(b.options.swipe===!1||"ontouchend"in document&&b.options.swipe===!1||b.options.draggable===!1&&-1!==a.type.indexOf("mouse")))switch(b.touchObject.fingerCount=a.originalEvent&&void 0!==a.originalEvent.touches?a.originalEvent.touches.length:1,b.touchObject.minSwipe=b.listWidth/b.options.touchThreshold,b.options.verticalSwiping===!0&&(b.touchObject.minSwipe=b.listHeight/b.options.touchThreshold),a.data.action){case"start":b.swipeStart(a);break;case"move":b.swipeMove(a);break;case"end":b.swipeEnd(a)}},b.prototype.swipeMove=function(a){var d,e,f,g,h,b=this;return h=void 0!==a.originalEvent?a.originalEvent.touches:null,!b.dragging||h&&1!==h.length?!1:(d=b.getLeft(b.currentSlide),b.touchObject.curX=void 0!==h?h[0].pageX:a.clientX,b.touchObject.curY=void 0!==h?h[0].pageY:a.clientY,b.touchObject.swipeLength=Math.round(Math.sqrt(Math.pow(b.touchObject.curX-b.touchObject.startX,2))),b.options.verticalSwiping===!0&&(b.touchObject.swipeLength=Math.round(Math.sqrt(Math.pow(b.touchObject.curY-b.touchObject.startY,2)))),e=b.swipeDirection(),"vertical"!==e?(void 0!==a.originalEvent&&b.touchObject.swipeLength>4&&a.preventDefault(),g=(b.options.rtl===!1?1:-1)*(b.touchObject.curX>b.touchObject.startX?1:-1),b.options.verticalSwiping===!0&&(g=b.touchObject.curY>b.touchObject.startY?1:-1),f=b.touchObject.swipeLength,b.touchObject.edgeHit=!1,b.options.infinite===!1&&(0===b.currentSlide&&"right"===e||b.currentSlide>=b.getDotCount()&&"left"===e)&&(f=b.touchObject.swipeLength*b.options.edgeFriction,b.touchObject.edgeHit=!0),b.options.vertical===!1?b.swipeLeft=d+f*g:b.swipeLeft=d+f*(b.$list.height()/b.listWidth)*g,b.options.verticalSwiping===!0&&(b.swipeLeft=d+f*g),b.options.fade===!0||b.options.touchMove===!1?!1:b.animating===!0?(b.swipeLeft=null,!1):void b.setCSS(b.swipeLeft)):void 0)},b.prototype.swipeStart=function(a){var c,b=this;return b.interrupted=!0,1!==b.touchObject.fingerCount||b.slideCount<=b.options.slidesToShow?(b.touchObject={},!1):(void 0!==a.originalEvent&&void 0!==a.originalEvent.touches&&(c=a.originalEvent.touches[0]),b.touchObject.startX=b.touchObject.curX=void 0!==c?c.pageX:a.clientX,b.touchObject.startY=b.touchObject.curY=void 0!==c?c.pageY:a.clientY,void(b.dragging=!0))},b.prototype.unfilterSlides=b.prototype.slickUnfilter=function(){var a=this;null!==a.$slidesCache&&(a.unload(),a.$slideTrack.children(this.options.slide).detach(),a.$slidesCache.appendTo(a.$slideTrack),a.reinit())},b.prototype.unload=function(){var b=this;a(".slick-cloned",b.$slider).remove(),b.$dots&&b.$dots.remove(),b.$prevArrow&&b.htmlExpr.test(b.options.prevArrow)&&b.$prevArrow.remove(),b.$nextArrow&&b.htmlExpr.test(b.options.nextArrow)&&b.$nextArrow.remove(),b.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden","true").css("width","")},b.prototype.unslick=function(a){var b=this;b.$slider.trigger("unslick",[b,a]),b.destroy()},b.prototype.updateArrows=function(){var b,a=this;b=Math.floor(a.options.slidesToShow/2),a.options.arrows===!0&&a.slideCount>a.options.slidesToShow&&!a.options.infinite&&(a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled","false"),a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled","false"),0===a.currentSlide?(a.$prevArrow.addClass("slick-disabled").attr("aria-disabled","true"),a.$nextArrow.removeClass("slick-disabled").attr("aria-disabled","false")):a.currentSlide>=a.slideCount-a.options.slidesToShow&&a.options.centerMode===!1?(a.$nextArrow.addClass("slick-disabled").attr("aria-disabled","true"),a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled","false")):a.currentSlide>=a.slideCount-1&&a.options.centerMode===!0&&(a.$nextArrow.addClass("slick-disabled").attr("aria-disabled","true"),a.$prevArrow.removeClass("slick-disabled").attr("aria-disabled","false")))},b.prototype.updateDots=function(){var a=this;null!==a.$dots&&(a.$dots.find("li").removeClass("slick-active").attr("aria-hidden","true"),a.$dots.find("li").eq(Math.floor(a.currentSlide/a.options.slidesToScroll)).addClass("slick-active").attr("aria-hidden","false"))},b.prototype.visibility=function(){var a=this;a.options.autoplay&&(document[a.hidden]?a.interrupted=!0:a.interrupted=!1)},a.fn.slick=function(){var f,g,a=this,c=arguments[0],d=Array.prototype.slice.call(arguments,1),e=a.length;for(f=0;e>f;f++)if("object"==typeof c||"undefined"==typeof c?a[f].slick=new b(a[f],c):g=a[f].slick[c].apply(a[f].slick,d),"undefined"!=typeof g)return g;return a}});

/*! showdown v 1.8.6 - 22-12-2017 */
(function() {
  function g(g) {
    "use strict";
    var A = {
      omitExtraWLInCodeBlocks: {
        defaultValue: !1,
        describe: "Omit the default extra whiteline added to code blocks",
        type: "boolean"
      },
      noHeaderId: {
        defaultValue: !1,
        describe: "Turn on/off generated header id",
        type: "boolean"
      },
      prefixHeaderId: {
        defaultValue: !1,
        describe:
          "Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix",
        type: "string"
      },
      rawPrefixHeaderId: {
        defaultValue: !1,
        describe:
          'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
        type: "boolean"
      },
      ghCompatibleHeaderId: {
        defaultValue: !1,
        describe:
          "Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)",
        type: "boolean"
      },
      rawHeaderId: {
        defaultValue: !1,
        describe:
          "Remove only spaces, ' and \" from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids",
        type: "boolean"
      },
      headerLevelStart: {
        defaultValue: !1,
        describe: "The header blocks level start",
        type: "integer"
      },
      parseImgDimensions: {
        defaultValue: !1,
        describe: "Turn on/off image dimension parsing",
        type: "boolean"
      },
      simplifiedAutoLink: {
        defaultValue: !1,
        describe: "Turn on/off GFM autolink style",
        type: "boolean"
      },
      excludeTrailingPunctuationFromURLs: {
        defaultValue: !1,
        describe:
          "Excludes trailing punctuation from links generated with autoLinking",
        type: "boolean"
      },
      literalMidWordUnderscores: {
        defaultValue: !1,
        describe: "Parse midword underscores as literal underscores",
        type: "boolean"
      },
      literalMidWordAsterisks: {
        defaultValue: !1,
        describe: "Parse midword asterisks as literal asterisks",
        type: "boolean"
      },
      strikethrough: {
        defaultValue: !1,
        describe: "Turn on/off strikethrough support",
        type: "boolean"
      },
      tables: {
        defaultValue: !1,
        describe: "Turn on/off tables support",
        type: "boolean"
      },
      tablesHeaderId: {
        defaultValue: !1,
        describe: "Add an id to table headers",
        type: "boolean"
      },
      ghCodeBlocks: {
        defaultValue: !0,
        describe: "Turn on/off GFM fenced code blocks support",
        type: "boolean"
      },
      tasklists: {
        defaultValue: !1,
        describe: "Turn on/off GFM tasklist support",
        type: "boolean"
      },
      smoothLivePreview: {
        defaultValue: !1,
        describe:
          "Prevents weird effects in live previews due to incomplete input",
        type: "boolean"
      },
      smartIndentationFix: {
        defaultValue: !1,
        description: "Tries to smartly fix indentation in es6 strings",
        type: "boolean"
      },
      disableForced4SpacesIndentedSublists: {
        defaultValue: !1,
        description:
          "Disables the requirement of indenting nested sublists by 4 spaces",
        type: "boolean"
      },
      simpleLineBreaks: {
        defaultValue: !1,
        description: "Parses simple line breaks as <br> (GFM Style)",
        type: "boolean"
      },
      requireSpaceBeforeHeadingText: {
        defaultValue: !1,
        description:
          "Makes adding a space between `#` and the header text mandatory (GFM Style)",
        type: "boolean"
      },
      ghMentions: {
        defaultValue: !1,
        description: "Enables github @mentions",
        type: "boolean"
      },
      ghMentionsLink: {
        defaultValue: "https://github.com/{u}",
        description:
          "Changes the link generated by @mentions. Only applies if ghMentions option is enabled.",
        type: "string"
      },
      encodeEmails: {
        defaultValue: !0,
        description:
          "Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities",
        type: "boolean"
      },
      openLinksInNewWindow: {
        defaultValue: !1,
        description: "Open all links in new windows",
        type: "boolean"
      },
      backslashEscapesHTMLTags: {
        defaultValue: !1,
        description: "Support for HTML Tag escaping. ex: <div>foo</div>",
        type: "boolean"
      },
      emoji: {
        defaultValue: !1,
        description: "Enable emoji support. Ex: `this is a :smile: emoji`",
        type: "boolean"
      },
      underline: {
        defaultValue: !1,
        description:
          "Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`",
        type: "boolean"
      },
      completeHTMLDocument: {
        defaultValue: !1,
        description:
          "Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags",
        type: "boolean"
      },
      metadata: {
        defaultValue: !1,
        description:
          "Enable support for document metadata (defined at the top of the document between `` and `` or between `---` and `---`).",
        type: "boolean"
      },
      splitAdjacentBlockquotes: {
        defaultValue: !1,
        description: "Split adjacent blockquote blocks",
        type: "boolean"
      }
    };
    if (!1 === g) return JSON.parse(JSON.stringify(A));
    var C = {};
    for (var I in A) A.hasOwnProperty(I) && (C[I] = A[I].defaultValue);
    return C;
  }
  function A(g, A) {
    "use strict";
    var C = A ? "Error in " + A + " extension->" : "Error in unnamed extension",
      e = { valid: !0, error: "" };
    I.helper.isArray(g) || (g = [g]);
    for (var r = 0; r < g.length; ++r) {
      var t = C + " sub-extension " + r + ": ",
        a = g[r];
      if ("object" != typeof a)
        return (
          (e.valid = !1),
          (e.error = t + "must be an object, but " + typeof a + " given"),
          e
        );
      if (!I.helper.isString(a.type))
        return (
          (e.valid = !1),
          (e.error =
            t +
            'property "type" must be a string, but ' +
            typeof a.type +
            " given"),
          e
        );
      var n = (a.type = a.type.toLowerCase());
      if (
        ("language" === n && (n = a.type = "lang"),
        "html" === n && (n = a.type = "output"),
        "lang" !== n && "output" !== n && "listener" !== n)
      )
        return (
          (e.valid = !1),
          (e.error =
            t +
            "type " +
            n +
            ' is not recognized. Valid values: "lang/language", "output/html" or "listener"'),
          e
        );
      if ("listener" === n) {
        if (I.helper.isUndefined(a.listeners))
          return (
            (e.valid = !1),
            (e.error =
              t +
              '. Extensions of type "listener" must have a property called "listeners"'),
            e
          );
      } else if (
        I.helper.isUndefined(a.filter) &&
        I.helper.isUndefined(a.regex)
      )
        return (
          (e.valid = !1),
          (e.error =
            t +
            n +
            ' extensions must define either a "regex" property or a "filter" method'),
          e
        );
      if (a.listeners) {
        if ("object" != typeof a.listeners)
          return (
            (e.valid = !1),
            (e.error =
              t +
              '"listeners" property must be an object but ' +
              typeof a.listeners +
              " given"),
            e
          );
        for (var o in a.listeners)
          if (
            a.listeners.hasOwnProperty(o) &&
            "function" != typeof a.listeners[o]
          )
            return (
              (e.valid = !1),
              (e.error =
                t +
                '"listeners" property must be an hash of [event name]: [callback]. listeners.' +
                o +
                " must be a function but " +
                typeof a.listeners[o] +
                " given"),
              e
            );
      }
      if (a.filter) {
        if ("function" != typeof a.filter)
          return (
            (e.valid = !1),
            (e.error =
              t +
              '"filter" must be a function, but ' +
              typeof a.filter +
              " given"),
            e
          );
      } else if (a.regex) {
        if (
          (I.helper.isString(a.regex) && (a.regex = new RegExp(a.regex, "g")),
          !(a.regex instanceof RegExp))
        )
          return (
            (e.valid = !1),
            (e.error =
              t +
              '"regex" property must either be a string or a RegExp object, but ' +
              typeof a.regex +
              " given"),
            e
          );
        if (I.helper.isUndefined(a.replace))
          return (
            (e.valid = !1),
            (e.error =
              t +
              '"regex" extensions must implement a replace string or function'),
            e
          );
      }
    }
    return e;
  }
  function C(g, A) {
    "use strict";
    return "E" + A.charCodeAt(0) + "E";
  }
  var I = {},
    e = {},
    r = {},
    t = g(!0),
    a = "vanilla",
    n = {
      github: {
        omitExtraWLInCodeBlocks: !0,
        simplifiedAutoLink: !0,
        excludeTrailingPunctuationFromURLs: !0,
        literalMidWordUnderscores: !0,
        strikethrough: !0,
        tables: !0,
        tablesHeaderId: !0,
        ghCodeBlocks: !0,
        tasklists: !0,
        disableForced4SpacesIndentedSublists: !0,
        simpleLineBreaks: !0,
        requireSpaceBeforeHeadingText: !0,
        ghCompatibleHeaderId: !0,
        ghMentions: !0,
        backslashEscapesHTMLTags: !0,
        emoji: !0,
        splitAdjacentBlockquotes: !0
      },
      original: { noHeaderId: !0, ghCodeBlocks: !1 },
      ghost: {
        omitExtraWLInCodeBlocks: !0,
        parseImgDimensions: !0,
        simplifiedAutoLink: !0,
        excludeTrailingPunctuationFromURLs: !0,
        literalMidWordUnderscores: !0,
        strikethrough: !0,
        tables: !0,
        tablesHeaderId: !0,
        ghCodeBlocks: !0,
        tasklists: !0,
        smoothLivePreview: !0,
        simpleLineBreaks: !0,
        requireSpaceBeforeHeadingText: !0,
        ghMentions: !1,
        encodeEmails: !0
      },
      vanilla: g(!0),
      allOn: (function() {
        "use strict";
        var A = g(!0),
          C = {};
        for (var I in A) A.hasOwnProperty(I) && (C[I] = !0);
        return C;
      })()
    };
  (I.helper = {}),
    (I.extensions = {}),
    (I.setOption = function(g, A) {
      "use strict";
      return (t[g] = A), this;
    }),
    (I.getOption = function(g) {
      "use strict";
      return t[g];
    }),
    (I.getOptions = function() {
      "use strict";
      return t;
    }),
    (I.resetOptions = function() {
      "use strict";
      t = g(!0);
    }),
    (I.setFlavor = function(g) {
      "use strict";
      if (!n.hasOwnProperty(g)) throw Error(g + " flavor was not found");
      I.resetOptions();
      var A = n[g];
      a = g;
      for (var C in A) A.hasOwnProperty(C) && (t[C] = A[C]);
    }),
    (I.getFlavor = function() {
      "use strict";
      return a;
    }),
    (I.getFlavorOptions = function(g) {
      "use strict";
      if (n.hasOwnProperty(g)) return n[g];
    }),
    (I.getDefaultOptions = function(A) {
      "use strict";
      return g(A);
    }),
    (I.subParser = function(g, A) {
      "use strict";
      if (I.helper.isString(g)) {
        if (void 0 === A) {
          if (e.hasOwnProperty(g)) return e[g];
          throw Error("SubParser named " + g + " not registered!");
        }
        e[g] = A;
      }
    }),
    (I.extension = function(g, C) {
      "use strict";
      if (!I.helper.isString(g))
        throw Error("Extension 'name' must be a string");
      if (((g = I.helper.stdExtName(g)), I.helper.isUndefined(C))) {
        if (!r.hasOwnProperty(g))
          throw Error("Extension named " + g + " is not registered!");
        return r[g];
      }
      "function" == typeof C && (C = C()), I.helper.isArray(C) || (C = [C]);
      var e = A(C, g);
      if (!e.valid) throw Error(e.error);
      r[g] = C;
    }),
    (I.getAllExtensions = function() {
      "use strict";
      return r;
    }),
    (I.removeExtension = function(g) {
      "use strict";
      delete r[g];
    }),
    (I.resetExtensions = function() {
      "use strict";
      r = {};
    }),
    (I.validateExtension = function(g) {
      "use strict";
      var C = A(g, null);
      return !!C.valid || (console.warn(C.error), !1);
    }),
    I.hasOwnProperty("helper") || (I.helper = {}),
    (I.helper.isString = function(g) {
      "use strict";
      return "string" == typeof g || g instanceof String;
    }),
    (I.helper.isFunction = function(g) {
      "use strict";
      return g && "[object Function]" === {}.toString.call(g);
    }),
    (I.helper.isArray = function(g) {
      "use strict";
      return Array.isArray(g);
    }),
    (I.helper.isUndefined = function(g) {
      "use strict";
      return void 0 === g;
    }),
    (I.helper.forEach = function(g, A) {
      "use strict";
      if (I.helper.isUndefined(g)) throw new Error("obj param is required");
      if (I.helper.isUndefined(A))
        throw new Error("callback param is required");
      if (!I.helper.isFunction(A))
        throw new Error("callback param must be a function/closure");
      if ("function" == typeof g.forEach) g.forEach(A);
      else if (I.helper.isArray(g))
        for (var C = 0; C < g.length; C++) A(g[C], C, g);
      else {
        if ("object" != typeof g)
          throw new Error(
            "obj does not seem to be an array or an iterable object"
          );
        for (var e in g) g.hasOwnProperty(e) && A(g[e], e, g);
      }
    }),
    (I.helper.stdExtName = function(g) {
      "use strict";
      return g
        .replace(/[_?*+\/\\.^-]/g, "")
        .replace(/\s/g, "")
        .toLowerCase();
    }),
    (I.helper.escapeCharactersCallback = C),
    (I.helper.escapeCharacters = function(g, A, I) {
      "use strict";
      var e = "([" + A.replace(/([\[\]\\])/g, "\\$1") + "])";
      I && (e = "\\\\" + e);
      var r = new RegExp(e, "g");
      return (g = g.replace(r, C));
    });
  var o = function(g, A, C, I) {
    "use strict";
    var e,
      r,
      t,
      a,
      n,
      o = I || "",
      s = o.indexOf("g") > -1,
      i = new RegExp(A + "|" + C, "g" + o.replace(/g/g, "")),
      l = new RegExp(A, o.replace(/g/g, "")),
      c = [];
    do {
      for (e = 0; (t = i.exec(g)); )
        if (l.test(t[0])) e++ || (a = (r = i.lastIndex) - t[0].length);
        else if (e && !--e) {
          n = t.index + t[0].length;
          var u = {
            left: { start: a, end: r },
            match: { start: r, end: t.index },
            right: { start: t.index, end: n },
            wholeMatch: { start: a, end: n }
          };
          if ((c.push(u), !s)) return c;
        }
    } while (e && (i.lastIndex = r));
    return c;
  };
  (I.helper.matchRecursiveRegExp = function(g, A, C, I) {
    "use strict";
    for (var e = o(g, A, C, I), r = [], t = 0; t < e.length; ++t)
      r.push([
        g.slice(e[t].wholeMatch.start, e[t].wholeMatch.end),
        g.slice(e[t].match.start, e[t].match.end),
        g.slice(e[t].left.start, e[t].left.end),
        g.slice(e[t].right.start, e[t].right.end)
      ]);
    return r;
  }),
    (I.helper.replaceRecursiveRegExp = function(g, A, C, e, r) {
      "use strict";
      if (!I.helper.isFunction(A)) {
        var t = A;
        A = function() {
          return t;
        };
      }
      var a = o(g, C, e, r),
        n = g,
        s = a.length;
      if (s > 0) {
        var i = [];
        0 !== a[0].wholeMatch.start &&
          i.push(g.slice(0, a[0].wholeMatch.start));
        for (var l = 0; l < s; ++l)
          i.push(
            A(
              g.slice(a[l].wholeMatch.start, a[l].wholeMatch.end),
              g.slice(a[l].match.start, a[l].match.end),
              g.slice(a[l].left.start, a[l].left.end),
              g.slice(a[l].right.start, a[l].right.end)
            )
          ),
            l < s - 1 &&
              i.push(g.slice(a[l].wholeMatch.end, a[l + 1].wholeMatch.start));
        a[s - 1].wholeMatch.end < g.length &&
          i.push(g.slice(a[s - 1].wholeMatch.end)),
          (n = i.join(""));
      }
      return n;
    }),
    (I.helper.regexIndexOf = function(g, A, C) {
      "use strict";
      if (!I.helper.isString(g))
        throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
      if (A instanceof RegExp == !1)
        throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp";
      var e = g.substring(C || 0).search(A);
      return e >= 0 ? e + (C || 0) : e;
    }),
    (I.helper.splitAtIndex = function(g, A) {
      "use strict";
      if (!I.helper.isString(g))
        throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
      return [g.substring(0, A), g.substring(A)];
    }),
    (I.helper.encodeEmailAddress = function(g) {
      "use strict";
      var A = [
        function(g) {
          return "&#" + g.charCodeAt(0) + ";";
        },
        function(g) {
          return "&#x" + g.charCodeAt(0).toString(16) + ";";
        },
        function(g) {
          return g;
        }
      ];
      return (g = g.replace(/./g, function(g) {
        if ("@" === g) g = A[Math.floor(2 * Math.random())](g);
        else {
          var C = Math.random();
          g = C > 0.9 ? A[2](g) : C > 0.45 ? A[1](g) : A[0](g);
        }
        return g;
      }));
    }),
    "undefined" == typeof console &&
      (console = {
        warn: function(g) {
          "use strict";
          alert(g);
        },
        log: function(g) {
          "use strict";
          alert(g);
        },
        error: function(g) {
          "use strict";
          throw g;
        }
      }),
    (I.helper.regexes = { asteriskDashAndColon: /([*_:~])/g }),
    (I.helper.emojis = {
      "+1": "",
      "-1": "",
      100: "",
      1234: "",
      "1st_place_medal": "",
      "2nd_place_medal": "",
      "3rd_place_medal": "",
      "8ball": "",
      a: "",
      ab: "",
      abc: "",
      abcd: "",
      accept: "",
      aerial_tramway: "",
      airplane: "",
      alarm_clock: "",
      alembic: "",
      alien: "",
      ambulance: "",
      amphora: "",
      anchor: "",
      angel: "",
      anger: "",
      angry: "",
      anguished: "",
      ant: "",
      apple: "",
      aquarius: "",
      aries: "",
      arrow_backward: "",
      arrow_double_down: "",
      arrow_double_up: "",
      arrow_down: "",
      arrow_down_small: "",
      arrow_forward: "",
      arrow_heading_down: "",
      arrow_heading_up: "",
      arrow_left: "",
      arrow_lower_left: "",
      arrow_lower_right: "",
      arrow_right: "",
      arrow_right_hook: "",
      arrow_up: "",
      arrow_up_down: "",
      arrow_up_small: "",
      arrow_upper_left: "",
      arrow_upper_right: "",
      arrows_clockwise: "",
      arrows_counterclockwise: "",
      art: "",
      articulated_lorry: "",
      artificial_satellite: "",
      astonished: "",
      athletic_shoe: "",
      atm: "",
      atom_symbol: "",
      avocado: "",
      b: "",
      baby: "",
      baby_bottle: "",
      baby_chick: "",
      baby_symbol: "",
      back: "",
      bacon: "",
      badminton: "",
      baggage_claim: "",
      baguette_bread: "",
      balance_scale: "",
      balloon: "",
      ballot_box: "",
      ballot_box_with_check: "",
      bamboo: "",
      banana: "",
      bangbang: "",
      bank: "",
      bar_chart: "",
      barber: "",
      baseball: "",
      basketball: "",
      basketball_man: "",
      basketball_woman: "&zwj;",
      bat: "",
      bath: "",
      bathtub: "",
      battery: "",
      beach_umbrella: "",
      bear: "",
      bed: "",
      bee: "",
      beer: "",
      beers: "",
      beetle: "",
      beginner: "",
      bell: "",
      bellhop_bell: "",
      bento: "",
      biking_man: "",
      bike: "",
      biking_woman: "&zwj;",
      bikini: "",
      biohazard: "",
      bird: "",
      birthday: "",
      black_circle: "",
      black_flag: "",
      black_heart: "",
      black_joker: "",
      black_large_square: "",
      black_medium_small_square: "",
      black_medium_square: "",
      black_nib: "",
      black_small_square: "",
      black_square_button: "",
      blonde_man: "",
      blonde_woman: "&zwj;",
      blossom: "",
      blowfish: "",
      blue_book: "",
      blue_car: "",
      blue_heart: "",
      blush: "",
      boar: "",
      boat: "",
      bomb: "",
      book: "",
      bookmark: "",
      bookmark_tabs: "",
      books: "",
      boom: "",
      boot: "",
      bouquet: "",
      bowing_man: "",
      bow_and_arrow: "",
      bowing_woman: "&zwj;",
      bowling: "",
      boxing_glove: "",
      boy: "",
      bread: "",
      bride_with_veil: "",
      bridge_at_night: "",
      briefcase: "",
      broken_heart: "",
      bug: "",
      building_construction: "",
      bulb: "",
      bullettrain_front: "",
      bullettrain_side: "",
      burrito: "",
      bus: "",
      business_suit_levitating: "",
      busstop: "",
      bust_in_silhouette: "",
      busts_in_silhouette: "",
      butterfly: "",
      cactus: "",
      cake: "",
      calendar: "",
      call_me_hand: "",
      calling: "",
      camel: "",
      camera: "",
      camera_flash: "",
      camping: "",
      cancer: "",
      candle: "",
      candy: "",
      canoe: "",
      capital_abcd: "",
      capricorn: "",
      car: "",
      card_file_box: "",
      card_index: "",
      card_index_dividers: "",
      carousel_horse: "",
      carrot: "",
      cat: "",
      cat2: "",
      cd: "",
      chains: "",
      champagne: "",
      chart: "",
      chart_with_downwards_trend: "",
      chart_with_upwards_trend: "",
      checkered_flag: "",
      cheese: "",
      cherries: "",
      cherry_blossom: "",
      chestnut: "",
      chicken: "",
      children_crossing: "",
      chipmunk: "",
      chocolate_bar: "",
      christmas_tree: "",
      church: "",
      cinema: "",
      circus_tent: "",
      city_sunrise: "",
      city_sunset: "",
      cityscape: "",
      cl: "",
      clamp: "",
      clap: "",
      clapper: "",
      classical_building: "",
      clinking_glasses: "",
      clipboard: "",
      clock1: "",
      clock10: "",
      clock1030: "",
      clock11: "",
      clock1130: "",
      clock12: "",
      clock1230: "",
      clock130: "",
      clock2: "",
      clock230: "",
      clock3: "",
      clock330: "",
      clock4: "",
      clock430: "",
      clock5: "",
      clock530: "",
      clock6: "",
      clock630: "",
      clock7: "",
      clock730: "",
      clock8: "",
      clock830: "",
      clock9: "",
      clock930: "",
      closed_book: "",
      closed_lock_with_key: "",
      closed_umbrella: "",
      cloud: "",
      cloud_with_lightning: "",
      cloud_with_lightning_and_rain: "",
      cloud_with_rain: "",
      cloud_with_snow: "",
      clown_face: "",
      clubs: "",
      cocktail: "",
      coffee: "",
      coffin: "",
      cold_sweat: "",
      comet: "",
      computer: "",
      computer_mouse: "",
      confetti_ball: "",
      confounded: "",
      confused: "",
      congratulations: "",
      construction: "",
      construction_worker_man: "",
      construction_worker_woman: "&zwj;",
      control_knobs: "",
      convenience_store: "",
      cookie: "",
      cool: "",
      policeman: "",
      copyright: "",
      corn: "",
      couch_and_lamp: "",
      couple: "",
      couple_with_heart_woman_man: "",
      couple_with_heart_man_man: "&zwj;&zwj;",
      couple_with_heart_woman_woman: "&zwj;&zwj;",
      couplekiss_man_man: "&zwj;&zwj;&zwj;",
      couplekiss_man_woman: "",
      couplekiss_woman_woman: "&zwj;&zwj;&zwj;",
      cow: "",
      cow2: "",
      cowboy_hat_face: "",
      crab: "",
      crayon: "",
      credit_card: "",
      crescent_moon: "",
      cricket: "",
      crocodile: "",
      croissant: "",
      crossed_fingers: "",
      crossed_flags: "",
      crossed_swords: "",
      crown: "",
      cry: "",
      crying_cat_face: "",
      crystal_ball: "",
      cucumber: "",
      cupid: "",
      curly_loop: "",
      currency_exchange: "",
      curry: "",
      custard: "",
      customs: "",
      cyclone: "",
      dagger: "",
      dancer: "",
      dancing_women: "",
      dancing_men: "&zwj;",
      dango: "",
      dark_sunglasses: "",
      dart: "",
      dash: "",
      date: "",
      deciduous_tree: "",
      deer: "",
      department_store: "",
      derelict_house: "",
      desert: "",
      desert_island: "",
      desktop_computer: "",
      male_detective: "",
      diamond_shape_with_a_dot_inside: "",
      diamonds: "",
      disappointed: "",
      disappointed_relieved: "",
      dizzy: "",
      dizzy_face: "",
      do_not_litter: "",
      dog: "",
      dog2: "",
      dollar: "",
      dolls: "",
      dolphin: "",
      door: "",
      doughnut: "",
      dove: "",
      dragon: "",
      dragon_face: "",
      dress: "",
      dromedary_camel: "",
      drooling_face: "",
      droplet: "",
      drum: "",
      duck: "",
      dvd: "",
      "e-mail": "",
      eagle: "",
      ear: "",
      ear_of_rice: "",
      earth_africa: "",
      earth_americas: "",
      earth_asia: "",
      egg: "",
      eggplant: "",
      eight_pointed_black_star: "",
      eight_spoked_asterisk: "",
      electric_plug: "",
      elephant: "",
      email: "",
      end: "",
      envelope_with_arrow: "",
      euro: "",
      european_castle: "",
      european_post_office: "",
      evergreen_tree: "",
      exclamation: "",
      expressionless: "",
      eye: "",
      eye_speech_bubble: "&zwj;",
      eyeglasses: "",
      eyes: "",
      face_with_head_bandage: "",
      face_with_thermometer: "",
      fist_oncoming: "",
      factory: "",
      fallen_leaf: "",
      family_man_woman_boy: "",
      family_man_boy: "&zwj;",
      family_man_boy_boy: "&zwj;&zwj;",
      family_man_girl: "&zwj;",
      family_man_girl_boy: "&zwj;&zwj;",
      family_man_girl_girl: "&zwj;&zwj;",
      family_man_man_boy: "&zwj;&zwj;",
      family_man_man_boy_boy: "&zwj;&zwj;&zwj;",
      family_man_man_girl: "&zwj;&zwj;",
      family_man_man_girl_boy: "&zwj;&zwj;&zwj;",
      family_man_man_girl_girl: "&zwj;&zwj;&zwj;",
      family_man_woman_boy_boy: "&zwj;&zwj;&zwj;",
      family_man_woman_girl: "&zwj;&zwj;",
      family_man_woman_girl_boy: "&zwj;&zwj;&zwj;",
      family_man_woman_girl_girl: "&zwj;&zwj;&zwj;",
      family_woman_boy: "&zwj;",
      family_woman_boy_boy: "&zwj;&zwj;",
      family_woman_girl: "&zwj;",
      family_woman_girl_boy: "&zwj;&zwj;",
      family_woman_girl_girl: "&zwj;&zwj;",
      family_woman_woman_boy: "&zwj;&zwj;",
      family_woman_woman_boy_boy: "&zwj;&zwj;&zwj;",
      family_woman_woman_girl: "&zwj;&zwj;",
      family_woman_woman_girl_boy: "&zwj;&zwj;&zwj;",
      family_woman_woman_girl_girl: "&zwj;&zwj;&zwj;",
      fast_forward: "",
      fax: "",
      fearful: "",
      feet: "",
      female_detective: "&zwj;",
      ferris_wheel: "",
      ferry: "",
      field_hockey: "",
      file_cabinet: "",
      file_folder: "",
      film_projector: "",
      film_strip: "",
      fire: "",
      fire_engine: "",
      fireworks: "",
      first_quarter_moon: "",
      first_quarter_moon_with_face: "",
      fish: "",
      fish_cake: "",
      fishing_pole_and_fish: "",
      fist_raised: "",
      fist_left: "",
      fist_right: "",
      flags: "",
      flashlight: "",
      fleur_de_lis: "",
      flight_arrival: "",
      flight_departure: "",
      floppy_disk: "",
      flower_playing_cards: "",
      flushed: "",
      fog: "",
      foggy: "",
      football: "",
      footprints: "",
      fork_and_knife: "",
      fountain: "",
      fountain_pen: "",
      four_leaf_clover: "",
      fox_face: "",
      framed_picture: "",
      free: "",
      fried_egg: "",
      fried_shrimp: "",
      fries: "",
      frog: "",
      frowning: "",
      frowning_face: "",
      frowning_man: "&zwj;",
      frowning_woman: "",
      middle_finger: "",
      fuelpump: "",
      full_moon: "",
      full_moon_with_face: "",
      funeral_urn: "",
      game_die: "",
      gear: "",
      gem: "",
      gemini: "",
      ghost: "",
      gift: "",
      gift_heart: "",
      girl: "",
      globe_with_meridians: "",
      goal_net: "",
      goat: "",
      golf: "",
      golfing_man: "",
      golfing_woman: "&zwj;",
      gorilla: "",
      grapes: "",
      green_apple: "",
      green_book: "",
      green_heart: "",
      green_salad: "",
      grey_exclamation: "",
      grey_question: "",
      grimacing: "",
      grin: "",
      grinning: "",
      guardsman: "",
      guardswoman: "&zwj;",
      guitar: "",
      gun: "",
      haircut_woman: "",
      haircut_man: "&zwj;",
      hamburger: "",
      hammer: "",
      hammer_and_pick: "",
      hammer_and_wrench: "",
      hamster: "",
      hand: "",
      handbag: "",
      handshake: "",
      hankey: "",
      hatched_chick: "",
      hatching_chick: "",
      headphones: "",
      hear_no_evil: "",
      heart: "",
      heart_decoration: "",
      heart_eyes: "",
      heart_eyes_cat: "",
      heartbeat: "",
      heartpulse: "",
      hearts: "",
      heavy_check_mark: "",
      heavy_division_sign: "",
      heavy_dollar_sign: "",
      heavy_heart_exclamation: "",
      heavy_minus_sign: "",
      heavy_multiplication_x: "",
      heavy_plus_sign: "",
      helicopter: "",
      herb: "",
      hibiscus: "",
      high_brightness: "",
      high_heel: "",
      hocho: "",
      hole: "",
      honey_pot: "",
      horse: "",
      horse_racing: "",
      hospital: "",
      hot_pepper: "",
      hotdog: "",
      hotel: "",
      hotsprings: "",
      hourglass: "",
      hourglass_flowing_sand: "",
      house: "",
      house_with_garden: "",
      houses: "",
      hugs: "",
      hushed: "",
      ice_cream: "",
      ice_hockey: "",
      ice_skate: "",
      icecream: "",
      id: "",
      ideograph_advantage: "",
      imp: "",
      inbox_tray: "",
      incoming_envelope: "",
      tipping_hand_woman: "",
      information_source: "",
      innocent: "",
      interrobang: "",
      iphone: "",
      izakaya_lantern: "",
      jack_o_lantern: "",
      japan: "",
      japanese_castle: "",
      japanese_goblin: "",
      japanese_ogre: "",
      jeans: "",
      joy: "",
      joy_cat: "",
      joystick: "",
      kaaba: "",
      key: "",
      keyboard: "",
      keycap_ten: "",
      kick_scooter: "",
      kimono: "",
      kiss: "",
      kissing: "",
      kissing_cat: "",
      kissing_closed_eyes: "",
      kissing_heart: "",
      kissing_smiling_eyes: "",
      kiwi_fruit: "",
      koala: "",
      koko: "",
      label: "",
      large_blue_circle: "",
      large_blue_diamond: "",
      large_orange_diamond: "",
      last_quarter_moon: "",
      last_quarter_moon_with_face: "",
      latin_cross: "",
      laughing: "",
      leaves: "",
      ledger: "",
      left_luggage: "",
      left_right_arrow: "",
      leftwards_arrow_with_hook: "",
      lemon: "",
      leo: "",
      leopard: "",
      level_slider: "",
      libra: "",
      light_rail: "",
      link: "",
      lion: "",
      lips: "",
      lipstick: "",
      lizard: "",
      lock: "",
      lock_with_ink_pen: "",
      lollipop: "",
      loop: "",
      loud_sound: "",
      loudspeaker: "",
      love_hotel: "",
      love_letter: "",
      low_brightness: "",
      lying_face: "",
      m: "",
      mag: "",
      mag_right: "",
      mahjong: "",
      mailbox: "",
      mailbox_closed: "",
      mailbox_with_mail: "",
      mailbox_with_no_mail: "",
      man: "",
      man_artist: "&zwj;",
      man_astronaut: "&zwj;",
      man_cartwheeling: "&zwj;",
      man_cook: "&zwj;",
      man_dancing: "",
      man_facepalming: "&zwj;",
      man_factory_worker: "&zwj;",
      man_farmer: "&zwj;",
      man_firefighter: "&zwj;",
      man_health_worker: "&zwj;",
      man_in_tuxedo: "",
      man_judge: "&zwj;",
      man_juggling: "&zwj;",
      man_mechanic: "&zwj;",
      man_office_worker: "&zwj;",
      man_pilot: "&zwj;",
      man_playing_handball: "&zwj;",
      man_playing_water_polo: "&zwj;",
      man_scientist: "&zwj;",
      man_shrugging: "&zwj;",
      man_singer: "&zwj;",
      man_student: "&zwj;",
      man_teacher: "&zwj;",
      man_technologist: "&zwj;",
      man_with_gua_pi_mao: "",
      man_with_turban: "",
      tangerine: "",
      mans_shoe: "",
      mantelpiece_clock: "",
      maple_leaf: "",
      martial_arts_uniform: "",
      mask: "",
      massage_woman: "",
      massage_man: "&zwj;",
      meat_on_bone: "",
      medal_military: "",
      medal_sports: "",
      mega: "",
      melon: "",
      memo: "",
      men_wrestling: "&zwj;",
      menorah: "",
      mens: "",
      metal: "",
      metro: "",
      microphone: "",
      microscope: "",
      milk_glass: "",
      milky_way: "",
      minibus: "",
      minidisc: "",
      mobile_phone_off: "",
      money_mouth_face: "",
      money_with_wings: "",
      moneybag: "",
      monkey: "",
      monkey_face: "",
      monorail: "",
      moon: "",
      mortar_board: "",
      mosque: "",
      motor_boat: "",
      motor_scooter: "",
      motorcycle: "",
      motorway: "",
      mount_fuji: "",
      mountain: "",
      mountain_biking_man: "",
      mountain_biking_woman: "&zwj;",
      mountain_cableway: "",
      mountain_railway: "",
      mountain_snow: "",
      mouse: "",
      mouse2: "",
      movie_camera: "",
      moyai: "",
      mrs_claus: "",
      muscle: "",
      mushroom: "",
      musical_keyboard: "",
      musical_note: "",
      musical_score: "",
      mute: "",
      nail_care: "",
      name_badge: "",
      national_park: "",
      nauseated_face: "",
      necktie: "",
      negative_squared_cross_mark: "",
      nerd_face: "",
      neutral_face: "",
      new: "",
      new_moon: "",
      new_moon_with_face: "",
      newspaper: "",
      newspaper_roll: "",
      next_track_button: "",
      ng: "",
      no_good_man: "&zwj;",
      no_good_woman: "",
      night_with_stars: "",
      no_bell: "",
      no_bicycles: "",
      no_entry: "",
      no_entry_sign: "",
      no_mobile_phones: "",
      no_mouth: "",
      no_pedestrians: "",
      no_smoking: "",
      "non-potable_water": "",
      nose: "",
      notebook: "",
      notebook_with_decorative_cover: "",
      notes: "",
      nut_and_bolt: "",
      o: "",
      o2: "",
      ocean: "",
      octopus: "",
      oden: "",
      office: "",
      oil_drum: "",
      ok: "",
      ok_hand: "",
      ok_man: "&zwj;",
      ok_woman: "",
      old_key: "",
      older_man: "",
      older_woman: "",
      om: "",
      on: "",
      oncoming_automobile: "",
      oncoming_bus: "",
      oncoming_police_car: "",
      oncoming_taxi: "",
      open_file_folder: "",
      open_hands: "",
      open_mouth: "",
      open_umbrella: "",
      ophiuchus: "",
      orange_book: "",
      orthodox_cross: "",
      outbox_tray: "",
      owl: "",
      ox: "",
      package: "",
      page_facing_up: "",
      page_with_curl: "",
      pager: "",
      paintbrush: "",
      palm_tree: "",
      pancakes: "",
      panda_face: "",
      paperclip: "",
      paperclips: "",
      parasol_on_ground: "",
      parking: "",
      part_alternation_mark: "",
      partly_sunny: "",
      passenger_ship: "",
      passport_control: "",
      pause_button: "",
      peace_symbol: "",
      peach: "",
      peanuts: "",
      pear: "",
      pen: "",
      pencil2: "",
      penguin: "",
      pensive: "",
      performing_arts: "",
      persevere: "",
      person_fencing: "",
      pouting_woman: "",
      phone: "",
      pick: "",
      pig: "",
      pig2: "",
      pig_nose: "",
      pill: "",
      pineapple: "",
      ping_pong: "",
      pisces: "",
      pizza: "",
      place_of_worship: "",
      plate_with_cutlery: "",
      play_or_pause_button: "",
      point_down: "",
      point_left: "",
      point_right: "",
      point_up: "",
      point_up_2: "",
      police_car: "",
      policewoman: "&zwj;",
      poodle: "",
      popcorn: "",
      post_office: "",
      postal_horn: "",
      postbox: "",
      potable_water: "",
      potato: "",
      pouch: "",
      poultry_leg: "",
      pound: "",
      rage: "",
      pouting_cat: "",
      pouting_man: "&zwj;",
      pray: "",
      prayer_beads: "",
      pregnant_woman: "",
      previous_track_button: "",
      prince: "",
      princess: "",
      printer: "",
      purple_heart: "",
      purse: "",
      pushpin: "",
      put_litter_in_its_place: "",
      question: "",
      rabbit: "",
      rabbit2: "",
      racehorse: "",
      racing_car: "",
      radio: "",
      radio_button: "",
      radioactive: "",
      railway_car: "",
      railway_track: "",
      rainbow: "",
      rainbow_flag: "&zwj;",
      raised_back_of_hand: "",
      raised_hand_with_fingers_splayed: "",
      raised_hands: "",
      raising_hand_woman: "",
      raising_hand_man: "&zwj;",
      ram: "",
      ramen: "",
      rat: "",
      record_button: "",
      recycle: "",
      red_circle: "",
      registered: "",
      relaxed: "",
      relieved: "",
      reminder_ribbon: "",
      repeat: "",
      repeat_one: "",
      rescue_worker_helmet: "",
      restroom: "",
      revolving_hearts: "",
      rewind: "",
      rhinoceros: "",
      ribbon: "",
      rice: "",
      rice_ball: "",
      rice_cracker: "",
      rice_scene: "",
      right_anger_bubble: "",
      ring: "",
      robot: "",
      rocket: "",
      rofl: "",
      roll_eyes: "",
      roller_coaster: "",
      rooster: "",
      rose: "",
      rosette: "",
      rotating_light: "",
      round_pushpin: "",
      rowing_man: "",
      rowing_woman: "&zwj;",
      rugby_football: "",
      running_man: "",
      running_shirt_with_sash: "",
      running_woman: "&zwj;",
      sa: "",
      sagittarius: "",
      sake: "",
      sandal: "",
      santa: "",
      satellite: "",
      saxophone: "",
      school: "",
      school_satchel: "",
      scissors: "",
      scorpion: "",
      scorpius: "",
      scream: "",
      scream_cat: "",
      scroll: "",
      seat: "",
      secret: "",
      see_no_evil: "",
      seedling: "",
      selfie: "",
      shallow_pan_of_food: "",
      shamrock: "",
      shark: "",
      shaved_ice: "",
      sheep: "",
      shell: "",
      shield: "",
      shinto_shrine: "",
      ship: "",
      shirt: "",
      shopping: "",
      shopping_cart: "",
      shower: "",
      shrimp: "",
      signal_strength: "",
      six_pointed_star: "",
      ski: "",
      skier: "",
      skull: "",
      skull_and_crossbones: "",
      sleeping: "",
      sleeping_bed: "",
      sleepy: "",
      slightly_frowning_face: "",
      slightly_smiling_face: "",
      slot_machine: "",
      small_airplane: "",
      small_blue_diamond: "",
      small_orange_diamond: "",
      small_red_triangle: "",
      small_red_triangle_down: "",
      smile: "",
      smile_cat: "",
      smiley: "",
      smiley_cat: "",
      smiling_imp: "",
      smirk: "",
      smirk_cat: "",
      smoking: "",
      snail: "",
      snake: "",
      sneezing_face: "",
      snowboarder: "",
      snowflake: "",
      snowman: "",
      snowman_with_snow: "",
      sob: "",
      soccer: "",
      soon: "",
      sos: "",
      sound: "",
      space_invader: "",
      spades: "",
      spaghetti: "",
      sparkle: "",
      sparkler: "",
      sparkles: "",
      sparkling_heart: "",
      speak_no_evil: "",
      speaker: "",
      speaking_head: "",
      speech_balloon: "",
      speedboat: "",
      spider: "",
      spider_web: "",
      spiral_calendar: "",
      spiral_notepad: "",
      spoon: "",
      squid: "",
      stadium: "",
      star: "",
      star2: "",
      star_and_crescent: "",
      star_of_david: "",
      stars: "",
      station: "",
      statue_of_liberty: "",
      steam_locomotive: "",
      stew: "",
      stop_button: "",
      stop_sign: "",
      stopwatch: "",
      straight_ruler: "",
      strawberry: "",
      stuck_out_tongue: "",
      stuck_out_tongue_closed_eyes: "",
      stuck_out_tongue_winking_eye: "",
      studio_microphone: "",
      stuffed_flatbread: "",
      sun_behind_large_cloud: "",
      sun_behind_rain_cloud: "",
      sun_behind_small_cloud: "",
      sun_with_face: "",
      sunflower: "",
      sunglasses: "",
      sunny: "",
      sunrise: "",
      sunrise_over_mountains: "",
      surfing_man: "",
      surfing_woman: "&zwj;",
      sushi: "",
      suspension_railway: "",
      sweat: "",
      sweat_drops: "",
      sweat_smile: "",
      sweet_potato: "",
      swimming_man: "",
      swimming_woman: "&zwj;",
      symbols: "",
      synagogue: "",
      syringe: "",
      taco: "",
      tada: "",
      tanabata_tree: "",
      taurus: "",
      taxi: "",
      tea: "",
      telephone_receiver: "",
      telescope: "",
      tennis: "",
      tent: "",
      thermometer: "",
      thinking: "",
      thought_balloon: "",
      ticket: "",
      tickets: "",
      tiger: "",
      tiger2: "",
      timer_clock: "",
      tipping_hand_man: "&zwj;",
      tired_face: "",
      tm: "",
      toilet: "",
      tokyo_tower: "",
      tomato: "",
      tongue: "",
      top: "",
      tophat: "",
      tornado: "",
      trackball: "",
      tractor: "",
      traffic_light: "",
      train: "",
      train2: "",
      tram: "",
      triangular_flag_on_post: "",
      triangular_ruler: "",
      trident: "",
      triumph: "",
      trolleybus: "",
      trophy: "",
      tropical_drink: "",
      tropical_fish: "",
      truck: "",
      trumpet: "",
      tulip: "",
      tumbler_glass: "",
      turkey: "",
      turtle: "",
      tv: "",
      twisted_rightwards_arrows: "",
      two_hearts: "",
      two_men_holding_hands: "",
      two_women_holding_hands: "",
      u5272: "",
      u5408: "",
      u55b6: "",
      u6307: "",
      u6708: "",
      u6709: "",
      u6e80: "",
      u7121: "",
      u7533: "",
      u7981: "",
      u7a7a: "",
      umbrella: "",
      unamused: "",
      underage: "",
      unicorn: "",
      unlock: "",
      up: "",
      upside_down_face: "",
      v: "",
      vertical_traffic_light: "",
      vhs: "",
      vibration_mode: "",
      video_camera: "",
      video_game: "",
      violin: "",
      virgo: "",
      volcano: "",
      volleyball: "",
      vs: "",
      vulcan_salute: "",
      walking_man: "",
      walking_woman: "&zwj;",
      waning_crescent_moon: "",
      waning_gibbous_moon: "",
      warning: "",
      wastebasket: "",
      watch: "",
      water_buffalo: "",
      watermelon: "",
      wave: "",
      wavy_dash: "",
      waxing_crescent_moon: "",
      wc: "",
      weary: "",
      wedding: "",
      weight_lifting_man: "",
      weight_lifting_woman: "&zwj;",
      whale: "",
      whale2: "",
      wheel_of_dharma: "",
      wheelchair: "",
      white_check_mark: "",
      white_circle: "",
      white_flag: "",
      white_flower: "",
      white_large_square: "",
      white_medium_small_square: "",
      white_medium_square: "",
      white_small_square: "",
      white_square_button: "",
      wilted_flower: "",
      wind_chime: "",
      wind_face: "",
      wine_glass: "",
      wink: "",
      wolf: "",
      woman: "",
      woman_artist: "&zwj;",
      woman_astronaut: "&zwj;",
      woman_cartwheeling: "&zwj;",
      woman_cook: "&zwj;",
      woman_facepalming: "&zwj;",
      woman_factory_worker: "&zwj;",
      woman_farmer: "&zwj;",
      woman_firefighter: "&zwj;",
      woman_health_worker: "&zwj;",
      woman_judge: "&zwj;",
      woman_juggling: "&zwj;",
      woman_mechanic: "&zwj;",
      woman_office_worker: "&zwj;",
      woman_pilot: "&zwj;",
      woman_playing_handball: "&zwj;",
      woman_playing_water_polo: "&zwj;",
      woman_scientist: "&zwj;",
      woman_shrugging: "&zwj;",
      woman_singer: "&zwj;",
      woman_student: "&zwj;",
      woman_teacher: "&zwj;",
      woman_technologist: "&zwj;",
      woman_with_turban: "&zwj;",
      womans_clothes: "",
      womans_hat: "",
      women_wrestling: "&zwj;",
      womens: "",
      world_map: "",
      worried: "",
      wrench: "",
      writing_hand: "",
      x: "",
      yellow_heart: "",
      yen: "",
      yin_yang: "",
      yum: "",
      zap: "",
      zipper_mouth_face: "",
      zzz: "",
      octocat:
        '<img width="20" height="20" align="absmiddle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAOwUlEQVR42uVbCVyO6RbPmn0sw9gZS0aZO4y5GTEUE2ObxjZjrbHEJVy3sWS5pkaWxjLEkCVDSbSgFLdESaWSLIVUSIi4kvb9f895vi/zbbR+yZ339/tbnu99n/ec/3Oe85xznufV0CjDBaAdwZqwnzCJ0FXjHV70/i8J5oQDhCFV8cJdq1atwqxZs+Ds7Iz4+HhqwgXCLELNKlK6G2Ej4e6lS5ewZcsWzJgxA+fOnWNZFqvzxT1v3boF/qcsBg0ahP3796OwsJAFWKYuIqjfPoS9cXFxWL58Obp06SInh5aWFr//jjoJWLlu3TolAorRuXNn7Ny5k4W4Spgj81xrgj5hLmED4RDhlNRygglBhADCSakpWxFMCHoETUJTwrYHDx7A1NT0je9nPHz4kN/fXl0EeI0aNeqtAjB69+4NPz8/FsSdlXvy5An8/f1hZ2cHCwsLGBsbY/To0cJy9PT0MGDAAAwePBhGRkbClNesWYODBw8iODgYOTk53M/d9evXo27duiW++8iRI3z/ZHURENOjR48ShSjGuHHjhHJ16tQp9TOKaNWqlZKpvw1MHluQOpSvk5eXh5YtW5ZbmarAvHnzmIBd6iCgXnZ2Npo1a1atCWAfwY5SHQTUKCoqQocOHao1AebmHBJgi7p8QBDP6epMwKFDvMDAWF0ELLS1ta3WBNy9e5cJMFIXAdvt7e2rNQHDhw9nAv5D+KKylV9y8+bNCi1pVYWZM2cyCfaVTcDdsqzH7xpBQRxcwqyylLdi5/K+KM/Q0dFhAqIri4Bn1T0AUgVpdmhYUeVHnD59+r1TnjF27Fgm4HhFCThoYmLyXhLQoEGD4mRKsyIE3OrZs+d7SQCDCyZcNSqv8k1evXoFTU3NUr+wzUcfYqRBf8yb/C2WzfoBFoTF08fBdMIITDD8CsP1+kL30x7Q6dYZH7drjfZ0f4fWLdG1Q1t81qMLBvTRwejB/TBl1BDMnzQGS2dMxKo5k7Fs9iSY/jAaBvR8Pc26pZaH02quLZSXgO6xsbGlelGnli1wZKcVMqN8gKcRwItrf+K/VB95doXaLwOJIVSzOU/+2Re5kV7IuuyJrIhTyLt6mmztLBBPNZLHoUAy9fE8UvJ8ikxfj8PwJPQErJeYlkquTZs2MQFLykuANgc/Jb2kn3Z3ZMaQUrmxwO1zyAo7gfRAJ6RfOIyMEFdkXj5F8BTK5lzxQv610yi8QcFatI8gQoCIK7x+hojwRnaE5H4JTiEj9Pjr/rJDqcZyn9b4ovu45LYbdWvXeqtsXMHiSlZ5CegRExPz1hd83PYj5POo0QinXyLFg48hnZTOiQ1Dzr1IZEaeQRoJn0HKZIR7lA2kfHrQUerXHTlx4ZL+rnjjFRGRGeYB5MUj2GnbW+XbuJFrp1heXgI6JCYmvvUFN1x3Aek3SWkapRAXMeJFGS8ge2Xfuog0toaykED3Mpk8+shOk+sv68Y50V9WuKewBKt5094o39atW/mRf5WXgIYZGRlo3Lixys4nj6A6Z1YMcqRCpwU4ouDlUyHk/QA/hNttR25Wlvh/ZthJUsil9ATQ/axkYbqEzDgfL0Ts/x35+aLyTES7IY36Q6w/+Q4/tP6wuUoZ9+7dy7ebVmQZjO/atavKzn32rAdeXkd6KCkXdAxZ13yFcLFnvPD73zrDVrsdTs6eggKSuSjjORHkUGoC0i86Iyc6QPQX7eqMnTodYNuzHU4vnosiaitMSUSavwMy6d3IvEUrzViVMrq5uXEX4ytCgL++vr5Sx7Vr1cIDX0dKkQJfj37Rs3jw1sBxkwlwGD4Ax3+ciN1faCHW76xQRFgAOcjSEMBkIe0x8nLzcez7kTg8Rh/uxuOxR/cTJISFSfq7eATpZCk8CAfXLVFJwIULXHnHoIoQYLtw4UKljps2aogXQcQuef/XAiMDKY+S4DhyEFwpDnCj9f+Afl8EbbWRTANaAdihlYoAMn8aZzyNuYODX/eD29TvRH/7v+qN8H27JdOAyWQfQQ74xPafVRLAPox9WUlK6hIGEgx4f00Kg2JcvHhRqeP6FIwknXemyen/2gLIIeC/CYk49M0AuE4xgtu0sThg8AUCN62TEuBdRgJo2Y+Kxh9D/k59SQiwH9QHobt3SAk4KSGA4oWjm1YqyVi8U6Soj4yOrHM/jTAyKVby/PnzIoNi8L+L4eXlpXoFcLcTgc1rAlISkJeXDxeK2A6P1hdTwI6mQPTJE+WbAlnJyE7PhNO3Q3BkrKGYWtxfHMkkmQLO0ilwA7+vXqAkn66urtBLUZ9iHfm30NBQaPAf165dA0d9vP2UlJSEp0+f4vHjx3j06JH4e+rUqUovcNmyGkiNEkLwklXsBG+ecMUOnfbYod1emG5uboFKJ8jPFVD0l0dBUHqoPDHpQeQEb0qc4FUHe3KAbYUT9JgzDbwOFL5MfN0fXkXhJ5PxSvLt2LFD1Ah5u4z1YJ14l4qnBe8v3rhxAzz4PAVG8nLHivIP0dHRiIiIQGRkpEgmrl69ClW1QBMjQ7LDW8hmU+RRI69ckJIkhL7jfRJBm62R+TJVYq6h0jhBRslsivqenT2MF/7OyI70VmkFhWnPJaS6OyPkt43IycqR9EfWlH7JDQUUTuNhCHR7Ke9YcRp/5coVoQPrcvnyZURFRYmBZlLS0kR8MVLD29sbnp6e8PHxQUBAgCgn8YO8E3z79m3BGKeVc+bMkXuBZt06SA12F/F5Go0gR4C8HBalPZMPXKL8lQKhPAqF+f97KXFyNx6HQsoPsshJ/kmAp2TKkJLISpXvjyxNhMYcDVLOEO+lPDi8B5mamipkZx1YF9YpJCRErAy+vr5CZ9ZdWABhDGEYYTBhAOFz3g4nfMJelNCbkNCpUye5F034mvxIPi1/FM+zQCw0k5B9O0iEr5kRXkqhMJOVf9NXIHjtT7hmaymSoBzKETimkAuFpaF1dkwI9RcmIYaXv3BJXoGCuyIgk5WpefPmKCgoYK46SmX/RKoL69Sfl0WuFEl1HlmWJXE5z6WmTZvKJxxmxkIQ3AuU5APk6NICj4hRT6eITTEEzqWk55HHPjz3cxJhNF5cxeNT9kj2cRDTQjEkzpDtjyyCic5l5fEA7uSHFEefR5pPsahrb2B9QkICFHeJ51HunkdLIg0VLY0BFKdLwllVHp4dHyvst3QuEiiju21vA/+VZkiluIKt4I3RIfWXQ4QgKUxkni47LJWUP3PmjHo2RxVI+CebmKJP6EiFDVurxUgmExe5PHlnPAkn8w4QqW62NCVmYopozid5H0CI9RKE21ggJeAYEeMnfitOnRn5XCfgeJ+VTosWQU8MOc6ZE0cqnUm4fv165SrPBVHCfMI4TowUfmOfsIcdJh92kBWmUcP6GDt8EDZbzIffH5tx3/ewSFjw5LKk0MEFEkZenDBjgew7Yiog5brkt+QrknvJmhIp4Apw/A1bVpjhG/0v5d7Vrl07bNu2TelUSqUoz8uI3Z49OEtBAy+TdP1CqKtwHzvQUxxgTJs2TeX5gdq1a0ObSmCjh+jB+NuvRamL1+3ls77HCip1rTSdJP5eNnMizKndjMLoH42G4bthX+FzHS3UVVEC69evH3799VeKMXJZrlWKclUGAZ5jxoxB02ZNsNlxH74aagBHZyex986HlVTczyGmI58h4CjL2toa48ePFxsUPEotWrQoc0GT0/C2bduiY8eO4ISMcxLeoOFYhS6qm2EpoZG65jmbv+dPSyRZlt5QfVjvtX19AOFNL+aDFNI4m0eFc9Ho5ORkaGtrl5kAVp6DMOk88efEjLe++ZhclZwHTJHEHbs4YOCmLj2645fdvwnTK42zoXtaEHwNDQ3LXdZm5yad3/2r+gQmDsRnIF5KAldX6zdsgG/GG8F44Vzcu3eP2y1K6GPr2rVrK1zbnz59Or/LoaoJCPZ4kCZsjw9GECL79OmDj9q2wb+320C3/5fgPQO6Vrzh+fpcDqxXr16lbHBwgkZXm6okYJr0ECMrX5vraiJ1lArEjrEnzWuOqemiYj9spGd2ee478XkiPsJakmJ83qA05/8qXNurJFLiunXrhpo1a6LxB02wyHIFZpovgOHwYfjZ0hK2lH5u2rwZ5suWYv5ycyUlmjRpgl69eimlrFy3kwuoyOvXr19frm3RokVMwPZ3TYC57E6xVq+e6KzVDSaL/oEp82Zh8IhhWLjGAp/p9oX5ujVKBNjY2MDV1VWuzd3dXaTesm2biUQuZ8u28elSPmKr8a4vdog8GnJpcT1N1KHUuBbt0jSgWuGbzJh3mVhh2TYHBwdxjFa2jVcZnvPVlQBOLXdZWlqW2ZFxNYYVlm07fPgwAgMD5dr4OD5HeHLFFxM+O42DGtXhIkFaMQlcUjIzM0P37t1Ro0YNpZPjPJcVK7SOjo5ybU5OTqIAo0gAh97VlgAZIj4l8Pn4WFaO64ocuXG6zJtDbMqySnC7IgF8uptLVrJtq1evFuWqak+A4j4i4TNpltiJ8LPiNFFFwNGjRyWFyfedAFUny/joekkEuLi4KK0CfykCeFnkiu1flgBeFtl3/D8SsMbKykpOifv37ysRcPz4cVHKUiSA8wwNdR9/VTMBSh9Y8S4Nf2qnSICiBbDzVCRg9uzZTMC+94kAv6FDh8opwRsVHPjItnl4eEDxHNLKlStFXV+2javQ/M1SpZe+1KA4L4G7WDG57fSm/OUbXiqG0ewAFYOeYcN4fwZhvLkp2y4tftrxcltdlf/w+fPn4qNGxTCYU2m6nrRu3VqunT/EoiuZvw6TTZHpyuNNmEaNGsndP3fu3OJAq1N1JOAHDmyKheVtNP4OkE2crULRAW7fvl20EyyLy24a8p+/7WISFixYIMLt4t82bNhQYjXqXREgPq3j74mlX3AmSL8E1eOPIBXnuVT5OsVZpuLnOMeOHeN7vifwiYhYzhC5IpwlOXj1QXWdBmy/XWU/X+UqMZfKBw4cKAobHPlJlZe9h6tOu+7cuSN2dg0MDMSSyZUpmXvaSD+crq/xvl0k9BTCRa7qEPq+5T4t6ffF52WVV+f1P6zyLG30bsU4AAAAAElFTkSuQmCC">',
      showdown:
        '<img width="20" height="20" align="absmiddle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAECtaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzA2NyA3OS4xNTc3NDcsIDIwMTUvMDMvMzAtMjM6NDA6NDIgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgICAgICAgICB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNSAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTUtMDEtMTVUMjE6MDE6MTlaPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNy0xMC0yNFQxMzozMTozMCswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTctMTAtMjRUMTM6MzE6MzArMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8cGhvdG9zaG9wOklDQ1Byb2ZpbGU+c1JHQiBJRUM2MTk2Ni0yLjE8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8cGhvdG9zaG9wOlRleHRMYXllcnM+CiAgICAgICAgICAgIDxyZGY6QmFnPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHBob3Rvc2hvcDpMYXllck5hbWU+UyAtPC9waG90b3Nob3A6TGF5ZXJOYW1lPgogICAgICAgICAgICAgICAgICA8cGhvdG9zaG9wOkxheWVyVGV4dD5TIC08L3Bob3Rvc2hvcDpMYXllclRleHQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICA8L3JkZjpCYWc+CiAgICAgICAgIDwvcGhvdG9zaG9wOlRleHRMYXllcnM+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6N2NkMzQxNzctOWYyZi0yNDRiLWEyYjQtMzU1MzJkY2Y1MWJiPC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD5hZG9iZTpkb2NpZDpwaG90b3Nob3A6M2E1YzgxYmYtYjhiNy0xMWU3LTk0NDktYTQ2MzdlZjJkNjMzPC94bXBNTTpEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06T3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6NjBDNUFFNjVGNjlDRTQxMTk0NUE4NTVFM0JDQTdFRUI8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NjBDNUFFNjVGNjlDRTQxMTk0NUE4NTVFM0JDQTdFRUI8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTUtMDEtMTVUMjE6MDE6MTlaPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ODZjNjBkMGQtOGY0Yy01ZTRlLWEwMjQtODI4ZWQyNTIwZDc3PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE3LTEwLTI0VDEzOjMxOjMwKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNSAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjdjZDM0MTc3LTlmMmYtMjQ0Yi1hMmI0LTM1NTMyZGNmNTFiYjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNy0xMC0yNFQxMzozMTozMCswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDx4bXBNTTpEZXJpdmVkRnJvbSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgIDxzdFJlZjppbnN0YW5jZUlEPnhtcC5paWQ6ODZjNjBkMGQtOGY0Yy01ZTRlLWEwMjQtODI4ZWQyNTIwZDc3PC9zdFJlZjppbnN0YW5jZUlEPgogICAgICAgICAgICA8c3RSZWY6ZG9jdW1lbnRJRD54bXAuZGlkOjYwQzVBRTY1RjY5Q0U0MTE5NDVBODU1RTNCQ0E3RUVCPC9zdFJlZjpkb2N1bWVudElEPgogICAgICAgICAgICA8c3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6NjBDNUFFNjVGNjlDRTQxMTk0NUE4NTVFM0JDQTdFRUI8L3N0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPHRpZmY6WFJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NjQ8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NjQ8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/Pse7bzcAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAA1JJREFUeNrsm1+OmlAUhz+aeS9dwZggJn1AnRUMO6jpBgZXULuC2hWUWUGZBTSxKyiuoA4mfUBMnB04K5g+9DihRBHlyh/lJLwIXLgf99xzzu9etZeXFy7Z3nDh1gBoAFy4XeVtQNO0zNcapmUDfUBPnFoBfhQGq6IBaHmjwD4Ahmk5wAD4kKG5J8CNwsAFaHe6DvA9cc0wCgOv8gDka3vA9RHNPgo0D7hNnJtGYWBXxgV2dH4MfMnRRA+Y1WIO2NJ5F/ikoKm3tYsChmkNFHW+fmHQMC1dfHaXPQP3wM1yMdc2B/AOGALTWobBmI1Shu0UGCwX83XyRBQGawHntTtdG5gUNfxVu4CTNqNv6/wWGL7kCc+1AmCYVisl3I2ydD4GYZUCs7IjoLXrxHIx9w9tLAqDCfBwDrXAY457x+cAoCfuwRGjYFUnAGk+PsjR7s8Dn1VeLWCYVlpDw+VivjVHSHt+u9PVJbzGzZXQWTkAkz0V31fATUaEsjVJlQBs4FeGcteLgzgbAALBA+4y3voAeJL8nA0AHfClnM1qm1HhnYUidCSE+KzvSSJUTwAxCOMcpfETMFYpfRUKIAbCFhC3OTJJJwqDWS0BxED0JZ4Pjix1P2+E0loCSMBwyK4S/xc1ojBwag8gMU84cvTKGgmlAYhngu1O9xAXuVE5J1QCQCz3bwHuHvdQui5QKQAxEO6eEKpsFCgTRSXkvdoxSlBMCxhJJbgrrbZRtHCiShN0pRB6PeQ3ckBw2K0oKXMBVYJIP+Nvh9qulFivGoBt1lLQxowT2ykBXCfnhZIglgYACWmqXQv+baioBYCeiCQHm+QEg1O7RhF7hO4OhSAhcJKSFU7qBGADwZeqMMuXn6TUBw8qlaMrirNb4LdhWlP+SWD+cjFfxTpuS2GUpik+o3jFSEkqbJiWn0P0OMSGqlWiOu0TvD+FRHZKAE+oW+cfRmEwqlsesJJEJs8y91QqP+9UL6lqEtz2gpuNEY5sm9sIHln2DRa2aFKGJtiXkZEMiWtgVvRKUSUFkSKt2S7fAGgAXLYpmQQXf36MUChTZdUa2u8/rkvPA6Tz30r4eH3ybcBS5gJ6SaNXb+aABkA1AMxKenclBZLW/He4cYEGwEXb3wEASelexk6LIIIAAAAASUVORK5CYII=">'
    }),
    (I.Converter = function(g) {
      "use strict";
      function C(g, C) {
        if (((C = C || null), I.helper.isString(g))) {
          if (((g = I.helper.stdExtName(g)), (C = g), I.extensions[g]))
            return (
              console.warn(
                "DEPRECATION WARNING: " +
                  g +
                  " is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!"
              ),
              void (function(g, C) {
                "function" == typeof g && (g = g(new I.Converter()));
                I.helper.isArray(g) || (g = [g]);
                var e = A(g, C);
                if (!e.valid) throw Error(e.error);
                for (var r = 0; r < g.length; ++r)
                  switch (g[r].type) {
                    case "lang":
                      s.push(g[r]);
                      break;
                    case "output":
                      i.push(g[r]);
                      break;
                    default:
                      throw Error(
                        "Extension loader error: Type unrecognized!!!"
                      );
                  }
              })(I.extensions[g], g)
            );
          if (I.helper.isUndefined(r[g]))
            throw Error(
              'Extension "' +
                g +
                '" could not be loaded. It was either not found or is not a valid extension.'
            );
          g = r[g];
        }
        "function" == typeof g && (g = g()), I.helper.isArray(g) || (g = [g]);
        var t = A(g, C);
        if (!t.valid) throw Error(t.error);
        for (var a = 0; a < g.length; ++a) {
          switch (g[a].type) {
            case "lang":
              s.push(g[a]);
              break;
            case "output":
              i.push(g[a]);
          }
          if (g[a].hasOwnProperty("listeners"))
            for (var n in g[a].listeners)
              g[a].listeners.hasOwnProperty(n) && e(n, g[a].listeners[n]);
        }
      }
      function e(g, A) {
        if (!I.helper.isString(g))
          throw Error(
            "Invalid argument in converter.listen() method: name must be a string, but " +
              typeof g +
              " given"
          );
        if ("function" != typeof A)
          throw Error(
            "Invalid argument in converter.listen() method: callback must be a function, but " +
              typeof A +
              " given"
          );
        l.hasOwnProperty(g) || (l[g] = []), l[g].push(A);
      }
      var o = {},
        s = [],
        i = [],
        l = {},
        c = a,
        u = { parsed: {}, raw: "", format: "" };
      !(function() {
        g = g || {};
        for (var A in t) t.hasOwnProperty(A) && (o[A] = t[A]);
        if ("object" != typeof g)
          throw Error(
            "Converter expects the passed parameter to be an object, but " +
              typeof g +
              " was passed instead."
          );
        for (var e in g) g.hasOwnProperty(e) && (o[e] = g[e]);
        o.extensions && I.helper.forEach(o.extensions, C);
      })(),
        (this._dispatch = function(g, A, C, I) {
          if (l.hasOwnProperty(g))
            for (var e = 0; e < l[g].length; ++e) {
              var r = l[g][e](g, A, this, C, I);
              r && void 0 !== r && (A = r);
            }
          return A;
        }),
        (this.listen = function(g, A) {
          return e(g, A), this;
        }),
        (this.makeHtml = function(g) {
          if (!g) return g;
          var A = {
            gHtmlBlocks: [],
            gHtmlMdBlocks: [],
            gHtmlSpans: [],
            gUrls: {},
            gTitles: {},
            gDimensions: {},
            gListLevel: 0,
            hashLinkCounts: {},
            langExtensions: s,
            outputModifiers: i,
            converter: this,
            ghCodeBlocks: [],
            metadata: { parsed: {}, raw: "", format: "" }
          };
          return (
            (g = g.replace(//g, "T")),
            (g = g.replace(/\$/g, "D")),
            (g = g.replace(/\r\n/g, "\n")),
            (g = g.replace(/\r/g, "\n")),
            (g = g.replace(/\u00A0/g, " ")),
            o.smartIndentationFix &&
              (g = (function(g) {
                var A = g.match(/^\s*/)[0].length,
                  C = new RegExp("^\\s{0," + A + "}", "gm");
                return g.replace(C, "");
              })(g)),
            (g = "\n\n" + g + "\n\n"),
            (g = I.subParser("detab")(g, o, A)),
            (g = g.replace(/^[ \t]+$/gm, "")),
            I.helper.forEach(s, function(C) {
              g = I.subParser("runExtension")(C, g, o, A);
            }),
            (g = I.subParser("metadata")(g, o, A)),
            (g = I.subParser("hashPreCodeTags")(g, o, A)),
            (g = I.subParser("githubCodeBlocks")(g, o, A)),
            (g = I.subParser("hashHTMLBlocks")(g, o, A)),
            (g = I.subParser("hashCodeTags")(g, o, A)),
            (g = I.subParser("stripLinkDefinitions")(g, o, A)),
            (g = I.subParser("blockGamut")(g, o, A)),
            (g = I.subParser("unhashHTMLSpans")(g, o, A)),
            (g = I.subParser("unescapeSpecialChars")(g, o, A)),
            (g = g.replace(/D/g, "$$")),
            (g = g.replace(/T/g, "")),
            (g = I.subParser("completeHTMLDocument")(g, o, A)),
            I.helper.forEach(i, function(C) {
              g = I.subParser("runExtension")(C, g, o, A);
            }),
            (u = A.metadata),
            g
          );
        }),
        (this.setOption = function(g, A) {
          o[g] = A;
        }),
        (this.getOption = function(g) {
          return o[g];
        }),
        (this.getOptions = function() {
          return o;
        }),
        (this.addExtension = function(g, A) {
          C(g, (A = A || null));
        }),
        (this.useExtension = function(g) {
          C(g);
        }),
        (this.setFlavor = function(g) {
          if (!n.hasOwnProperty(g)) throw Error(g + " flavor was not found");
          var A = n[g];
          c = g;
          for (var C in A) A.hasOwnProperty(C) && (o[C] = A[C]);
        }),
        (this.getFlavor = function() {
          return c;
        }),
        (this.removeExtension = function(g) {
          I.helper.isArray(g) || (g = [g]);
          for (var A = 0; A < g.length; ++A) {
            for (var C = g[A], e = 0; e < s.length; ++e)
              s[e] === C && s[e].splice(e, 1);
            for (; 0 < i.length; ++e) i[0] === C && i[0].splice(e, 1);
          }
        }),
        (this.getAllExtensions = function() {
          return { language: s, output: i };
        }),
        (this.getMetadata = function(g) {
          return g ? u.raw : u.parsed;
        }),
        (this.getMetadataFormat = function() {
          return u.format;
        }),
        (this._setMetadataPair = function(g, A) {
          u.parsed[g] = A;
        }),
        (this._setMetadataFormat = function(g) {
          u.format = g;
        }),
        (this._setMetadataRaw = function(g) {
          u.raw = g;
        });
    }),
    I.subParser("anchors", function(g, A, C) {
      "use strict";
      var e = function(g, e, r, t, a, n, o) {
        if (
          (I.helper.isUndefined(o) && (o = ""),
          (r = r.toLowerCase()),
          g.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)
        )
          t = "";
        else if (!t) {
          if (
            (r || (r = e.toLowerCase().replace(/ ?\n/g, " ")),
            (t = "#" + r),
            I.helper.isUndefined(C.gUrls[r]))
          )
            return g;
          (t = C.gUrls[r]),
            I.helper.isUndefined(C.gTitles[r]) || (o = C.gTitles[r]);
        }
        var s =
          '<a href="' +
          (t = t.replace(
            I.helper.regexes.asteriskDashAndColon,
            I.helper.escapeCharactersCallback
          )) +
          '"';
        return (
          "" !== o &&
            null !== o &&
            (s +=
              ' title="' +
              (o = (o = o.replace(/"/g, "&quot;")).replace(
                I.helper.regexes.asteriskDashAndColon,
                I.helper.escapeCharactersCallback
              )) +
              '"'),
          A.openLinksInNewWindow &&
            !/^#/.test(t) &&
            (s += ' target="E95Eblank"'),
          (s += ">" + e + "</a>")
        );
      };
      return (
        (g = (g = C.converter._dispatch("anchors.before", g, A, C)).replace(
          /\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g,
          e
        )),
        (g = g.replace(
          /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
          e
        )),
        (g = g.replace(
          /\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
          e
        )),
        (g = g.replace(/\[([^\[\]]+)]()()()()()/g, e)),
        A.ghMentions &&
          (g = g.replace(
            /(^|\s)(\\)?(@([a-z\d\-]+))(?=[.!?;,[\]()]|\s|$)/gim,
            function(g, C, e, r, t) {
              if ("\\" === e) return C + r;
              if (!I.helper.isString(A.ghMentionsLink))
                throw new Error("ghMentionsLink option must be a string");
              var a = A.ghMentionsLink.replace(/\{u}/g, t),
                n = "";
              return (
                A.openLinksInNewWindow && (n = ' target="E95Eblank"'),
                C + '<a href="' + a + '"' + n + ">" + r + "</a>"
              );
            }
          )),
        (g = C.converter._dispatch("anchors.after", g, A, C))
      );
    });
  var s = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
    i = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
    l = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
    c = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gim,
    u = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,
    d = function(g) {
      "use strict";
      return function(A, C, e, r, t, a, n) {
        var o = (e = e.replace(
            I.helper.regexes.asteriskDashAndColon,
            I.helper.escapeCharactersCallback
          )),
          s = "",
          i = "",
          l = C || "",
          c = n || "";
        return (
          /^www\./i.test(e) && (e = e.replace(/^www\./i, "http://www.")),
          g.excludeTrailingPunctuationFromURLs && a && (s = a),
          g.openLinksInNewWindow && (i = ' target="E95Eblank"'),
          l + '<a href="' + e + '"' + i + ">" + o + "</a>" + s + c
        );
      };
    },
    p = function(g, A) {
      "use strict";
      return function(C, e, r) {
        var t = "mailto:";
        return (
          (e = e || ""),
          (r = I.subParser("unescapeSpecialChars")(r, g, A)),
          g.encodeEmails
            ? ((t = I.helper.encodeEmailAddress(t + r)),
              (r = I.helper.encodeEmailAddress(r)))
            : (t += r),
          e + '<a href="' + t + '">' + r + "</a>"
        );
      };
    };
  I.subParser("autoLinks", function(g, A, C) {
    "use strict";
    return (
      (g = C.converter._dispatch("autoLinks.before", g, A, C)),
      (g = g.replace(l, d(A))),
      (g = g.replace(u, p(A, C))),
      (g = C.converter._dispatch("autoLinks.after", g, A, C))
    );
  }),
    I.subParser("simplifiedAutoLinks", function(g, A, C) {
      "use strict";
      return A.simplifiedAutoLink
        ? ((g = C.converter._dispatch("simplifiedAutoLinks.before", g, A, C)),
          (g = A.excludeTrailingPunctuationFromURLs
            ? g.replace(i, d(A))
            : g.replace(s, d(A))),
          (g = g.replace(c, p(A, C))),
          (g = C.converter._dispatch("simplifiedAutoLinks.after", g, A, C)))
        : g;
    }),
    I.subParser("blockGamut", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("blockGamut.before", g, A, C)),
        (g = I.subParser("blockQuotes")(g, A, C)),
        (g = I.subParser("headers")(g, A, C)),
        (g = I.subParser("horizontalRule")(g, A, C)),
        (g = I.subParser("lists")(g, A, C)),
        (g = I.subParser("codeBlocks")(g, A, C)),
        (g = I.subParser("tables")(g, A, C)),
        (g = I.subParser("hashHTMLBlocks")(g, A, C)),
        (g = I.subParser("paragraphs")(g, A, C)),
        (g = C.converter._dispatch("blockGamut.after", g, A, C))
      );
    }),
    I.subParser("blockQuotes", function(g, A, C) {
      "use strict";
      (g = C.converter._dispatch("blockQuotes.before", g, A, C)), (g += "\n\n");
      var e = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;
      return (
        A.splitAdjacentBlockquotes && (e = /^ {0,3}>[\s\S]*?(?:\n\n)/gm),
        (g = g.replace(e, function(g) {
          return (
            (g = g.replace(/^[ \t]*>[ \t]?/gm, "")),
            (g = g.replace(/0/g, "")),
            (g = g.replace(/^[ \t]+$/gm, "")),
            (g = I.subParser("githubCodeBlocks")(g, A, C)),
            (g = I.subParser("blockGamut")(g, A, C)),
            (g = g.replace(/(^|\n)/g, "$1  ")),
            (g = g.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function(g, A) {
              var C = A;
              return (C = C.replace(/^  /gm, "0")), (C = C.replace(/0/g, ""));
            })),
            I.subParser("hashBlock")(
              "<blockquote>\n" + g + "\n</blockquote>",
              A,
              C
            )
          );
        })),
        (g = C.converter._dispatch("blockQuotes.after", g, A, C))
      );
    }),
    I.subParser("codeBlocks", function(g, A, C) {
      "use strict";
      g = C.converter._dispatch("codeBlocks.before", g, A, C);
      return (
        (g = (g += "0").replace(
          /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g,
          function(g, e, r) {
            var t = e,
              a = r,
              n = "\n";
            return (
              (t = I.subParser("outdent")(t, A, C)),
              (t = I.subParser("encodeCode")(t, A, C)),
              (t = I.subParser("detab")(t, A, C)),
              (t = t.replace(/^\n+/g, "")),
              (t = t.replace(/\n+$/g, "")),
              A.omitExtraWLInCodeBlocks && (n = ""),
              (t = "<pre><code>" + t + n + "</code></pre>"),
              I.subParser("hashBlock")(t, A, C) + a
            );
          }
        )),
        (g = g.replace(/0/, "")),
        (g = C.converter._dispatch("codeBlocks.after", g, A, C))
      );
    }),
    I.subParser("codeSpans", function(g, A, C) {
      "use strict";
      return (
        void 0 === (g = C.converter._dispatch("codeSpans.before", g, A, C)) &&
          (g = ""),
        (g = g.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm, function(
          g,
          e,
          r,
          t
        ) {
          var a = t;
          return (
            (a = a.replace(/^([ \t]*)/g, "")),
            (a = a.replace(/[ \t]*$/g, "")),
            (a = I.subParser("encodeCode")(a, A, C)),
            (a = e + "<code>" + a + "</code>"),
            (a = I.subParser("hashHTMLSpans")(a, A, C))
          );
        })),
        (g = C.converter._dispatch("codeSpans.after", g, A, C))
      );
    }),
    I.subParser("completeHTMLDocument", function(g, A, C) {
      "use strict";
      if (!A.completeHTMLDocument) return g;
      g = C.converter._dispatch("completeHTMLDocument.before", g, A, C);
      var I = "html",
        e = "<!DOCTYPE HTML>\n",
        r = "",
        t = '<meta charset="utf-8">\n',
        a = "",
        n = "";
      void 0 !== C.metadata.parsed.doctype &&
        ((e = "<!DOCTYPE " + C.metadata.parsed.doctype + ">\n"),
        ("html" !== (I = C.metadata.parsed.doctype.toString().toLowerCase()) &&
          "html5" !== I) ||
          (t = '<meta charset="utf-8">'));
      for (var o in C.metadata.parsed)
        if (C.metadata.parsed.hasOwnProperty(o))
          switch (o.toLowerCase()) {
            case "doctype":
              break;
            case "title":
              r = "<title>" + C.metadata.parsed.title + "</title>\n";
              break;
            case "charset":
              t =
                "html" === I || "html5" === I
                  ? '<meta charset="' + C.metadata.parsed.charset + '">\n'
                  : '<meta name="charset" content="' +
                    C.metadata.parsed.charset +
                    '">\n';
              break;
            case "language":
            case "lang":
              (a = ' lang="' + C.metadata.parsed[o] + '"'),
                (n +=
                  '<meta name="' +
                  o +
                  '" content="' +
                  C.metadata.parsed[o] +
                  '">\n');
              break;
            default:
              n +=
                '<meta name="' +
                o +
                '" content="' +
                C.metadata.parsed[o] +
                '">\n';
          }
      return (
        (g =
          e +
          "<html" +
          a +
          ">\n<head>\n" +
          r +
          t +
          n +
          "</head>\n<body>\n" +
          g.trim() +
          "\n</body>\n</html>"),
        (g = C.converter._dispatch("completeHTMLDocument.after", g, A, C))
      );
    }),
    I.subParser("detab", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("detab.before", g, A, C)),
        (g = g.replace(/\t(?=\t)/g, "    ")),
        (g = g.replace(/\t/g, "AB")),
        (g = g.replace(/B(.+?)A/g, function(g, A) {
          for (var C = A, I = 4 - C.length % 4, e = 0; e < I; e++) C += " ";
          return C;
        })),
        (g = g.replace(/A/g, "    ")),
        (g = g.replace(/B/g, "")),
        (g = C.converter._dispatch("detab.after", g, A, C))
      );
    }),
    I.subParser("ellipsis", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("ellipsis.before", g, A, C)),
        (g = g.replace(/\.\.\./g, "")),
        (g = C.converter._dispatch("ellipsis.after", g, A, C))
      );
    }),
    I.subParser("emoji", function(g, A, C) {
      "use strict";
      if (!A.emoji) return g;
      return (
        (g = (g = C.converter._dispatch("emoji.before", g, A, C)).replace(
          /:([\S]+?):/g,
          function(g, A) {
            return I.helper.emojis.hasOwnProperty(A) ? I.helper.emojis[A] : g;
          }
        )),
        (g = C.converter._dispatch("emoji.after", g, A, C))
      );
    }),
    I.subParser("encodeAmpsAndAngles", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("encodeAmpsAndAngles.before", g, A, C)),
        (g = g.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;")),
        (g = g.replace(/<(?![a-z\/?$!])/gi, "&lt;")),
        (g = g.replace(/</g, "&lt;")),
        (g = g.replace(/>/g, "&gt;")),
        (g = C.converter._dispatch("encodeAmpsAndAngles.after", g, A, C))
      );
    }),
    I.subParser("encodeBackslashEscapes", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("encodeBackslashEscapes.before", g, A, C)),
        (g = g.replace(/\\(\\)/g, I.helper.escapeCharactersCallback)),
        (g = g.replace(
          /\\([`*_{}\[\]()>#+.!~=|-])/g,
          I.helper.escapeCharactersCallback
        )),
        (g = C.converter._dispatch("encodeBackslashEscapes.after", g, A, C))
      );
    }),
    I.subParser("encodeCode", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("encodeCode.before", g, A, C)),
        (g = g
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/([*_{}\[\]\\=~-])/g, I.helper.escapeCharactersCallback)),
        (g = C.converter._dispatch("encodeCode.after", g, A, C))
      );
    }),
    I.subParser("escapeSpecialCharsWithinTagAttributes", function(g, A, C) {
      "use strict";
      return (
        (g = (g = C.converter._dispatch(
          "escapeSpecialCharsWithinTagAttributes.before",
          g,
          A,
          C
        )).replace(/<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi, function(g) {
          return g
            .replace(/(.)<\/?code>(?=.)/g, "$1`")
            .replace(/([\\`*_~=|])/g, I.helper.escapeCharactersCallback);
        })),
        (g = g.replace(
          /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi,
          function(g) {
            return g.replace(
              /([\\`*_~=|])/g,
              I.helper.escapeCharactersCallback
            );
          }
        )),
        (g = C.converter._dispatch(
          "escapeSpecialCharsWithinTagAttributes.after",
          g,
          A,
          C
        ))
      );
    }),
    I.subParser("githubCodeBlocks", function(g, A, C) {
      "use strict";
      return A.ghCodeBlocks
        ? ((g = C.converter._dispatch("githubCodeBlocks.before", g, A, C)),
          (g += "0"),
          (g = g.replace(
            /(?:^|\n)(```+|~~~+)([^\s`~]*)\n([\s\S]*?)\n\1/g,
            function(g, e, r, t) {
              var a = A.omitExtraWLInCodeBlocks ? "" : "\n";
              return (
                (t = I.subParser("encodeCode")(t, A, C)),
                (t = I.subParser("detab")(t, A, C)),
                (t = t.replace(/^\n+/g, "")),
                (t = t.replace(/\n+$/g, "")),
                (t =
                  "<pre><code" +
                  (r ? ' class="' + r + " language-" + r + '"' : "") +
                  ">" +
                  t +
                  a +
                  "</code></pre>"),
                (t = I.subParser("hashBlock")(t, A, C)),
                "\n\nG" +
                  (C.ghCodeBlocks.push({ text: g, codeblock: t }) - 1) +
                  "G\n\n"
              );
            }
          )),
          (g = g.replace(/0/, "")),
          C.converter._dispatch("githubCodeBlocks.after", g, A, C))
        : g;
    }),
    I.subParser("hashBlock", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("hashBlock.before", g, A, C)),
        (g = g.replace(/(^\n+|\n+$)/g, "")),
        (g = "\n\nK" + (C.gHtmlBlocks.push(g) - 1) + "K\n\n"),
        (g = C.converter._dispatch("hashBlock.after", g, A, C))
      );
    }),
    I.subParser("hashCodeTags", function(g, A, C) {
      "use strict";
      g = C.converter._dispatch("hashCodeTags.before", g, A, C);
      return (
        (g = I.helper.replaceRecursiveRegExp(
          g,
          function(g, e, r, t) {
            var a = r + I.subParser("encodeCode")(e, A, C) + t;
            return "C" + (C.gHtmlSpans.push(a) - 1) + "C";
          },
          "<code\\b[^>]*>",
          "</code>",
          "gim"
        )),
        (g = C.converter._dispatch("hashCodeTags.after", g, A, C))
      );
    }),
    I.subParser("hashElement", function(g, A, C) {
      "use strict";
      return function(g, A) {
        var I = A;
        return (
          (I = I.replace(/\n\n/g, "\n")),
          (I = I.replace(/^\n/, "")),
          (I = I.replace(/\n+$/g, "")),
          (I = "\n\nK" + (C.gHtmlBlocks.push(I) - 1) + "K\n\n")
        );
      };
    }),
    I.subParser("hashHTMLBlocks", function(g, A, C) {
      "use strict";
      g = C.converter._dispatch("hashHTMLBlocks.before", g, A, C);
      var e = [
          "pre",
          "div",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "blockquote",
          "table",
          "dl",
          "ol",
          "ul",
          "script",
          "noscript",
          "form",
          "fieldset",
          "iframe",
          "math",
          "style",
          "section",
          "header",
          "footer",
          "nav",
          "article",
          "aside",
          "address",
          "audio",
          "canvas",
          "figure",
          "hgroup",
          "output",
          "video",
          "p"
        ],
        r = function(g, A, I, e) {
          var r = g;
          return (
            -1 !== I.search(/\bmarkdown\b/) &&
              (r = I + C.converter.makeHtml(A) + e),
            "\n\nK" + (C.gHtmlBlocks.push(r) - 1) + "K\n\n"
          );
        };
      A.backslashEscapesHTMLTags &&
        (g = g.replace(/\\<(\/?[^>]+?)>/g, function(g, A) {
          return "&lt;" + A + "&gt;";
        }));
      for (var t = 0; t < e.length; ++t)
        for (
          var a,
            n = new RegExp("^ {0,3}(<" + e[t] + "\\b[^>]*>)", "im"),
            o = "<" + e[t] + "\\b[^>]*>",
            s = "</" + e[t] + ">";
          -1 !== (a = I.helper.regexIndexOf(g, n));

        ) {
          var i = I.helper.splitAtIndex(g, a),
            l = I.helper.replaceRecursiveRegExp(i[1], r, o, s, "im");
          if (l === i[1]) break;
          g = i[0].concat(l);
        }
      return (
        (g = g.replace(
          /(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
          I.subParser("hashElement")(g, A, C)
        )),
        (g = I.helper.replaceRecursiveRegExp(
          g,
          function(g) {
            return "\n\nK" + (C.gHtmlBlocks.push(g) - 1) + "K\n\n";
          },
          "^ {0,3}\x3c!--",
          "--\x3e",
          "gm"
        )),
        (g = g.replace(
          /(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
          I.subParser("hashElement")(g, A, C)
        )),
        (g = C.converter._dispatch("hashHTMLBlocks.after", g, A, C))
      );
    }),
    I.subParser("hashHTMLSpans", function(g, A, C) {
      "use strict";
      function I(g) {
        return "C" + (C.gHtmlSpans.push(g) - 1) + "C";
      }
      return (
        (g = C.converter._dispatch("hashHTMLSpans.before", g, A, C)),
        (g = g.replace(/<[^>]+?\/>/gi, function(g) {
          return I(g);
        })),
        (g = g.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function(g) {
          return I(g);
        })),
        (g = g.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function(g) {
          return I(g);
        })),
        (g = g.replace(/<[^>]+?>/gi, function(g) {
          return I(g);
        })),
        (g = C.converter._dispatch("hashHTMLSpans.after", g, A, C))
      );
    }),
    I.subParser("unhashHTMLSpans", function(g, A, C) {
      "use strict";
      g = C.converter._dispatch("unhashHTMLSpans.before", g, A, C);
      for (var I = 0; I < C.gHtmlSpans.length; ++I) {
        for (var e = C.gHtmlSpans[I], r = 0; /C(\d+)C/.test(e); ) {
          var t = RegExp.$1;
          if (((e = e.replace("C" + t + "C", C.gHtmlSpans[t])), 10 === r)) {
            console.error("maximum nesting of 10 spans reached!!!");
            break;
          }
          ++r;
        }
        g = g.replace("C" + I + "C", e);
      }
      return (g = C.converter._dispatch("unhashHTMLSpans.after", g, A, C));
    }),
    I.subParser("hashPreCodeTags", function(g, A, C) {
      "use strict";
      g = C.converter._dispatch("hashPreCodeTags.before", g, A, C);
      return (
        (g = I.helper.replaceRecursiveRegExp(
          g,
          function(g, e, r, t) {
            var a = r + I.subParser("encodeCode")(e, A, C) + t;
            return (
              "\n\nG" +
              (C.ghCodeBlocks.push({ text: g, codeblock: a }) - 1) +
              "G\n\n"
            );
          },
          "^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>",
          "^ {0,3}</code>\\s*</pre>",
          "gim"
        )),
        (g = C.converter._dispatch("hashPreCodeTags.after", g, A, C))
      );
    }),
    I.subParser("headers", function(g, A, C) {
      "use strict";
      function e(g) {
        var e, r;
        if (A.customizedHeaderId) {
          var t = g.match(/\{([^{]+?)}\s*$/);
          t && t[1] && (g = t[1]);
        }
        return (
          (e = g),
          (r = I.helper.isString(A.prefixHeaderId)
            ? A.prefixHeaderId
            : !0 === A.prefixHeaderId ? "section-" : ""),
          A.rawPrefixHeaderId || (e = r + e),
          (e = A.ghCompatibleHeaderId
            ? e
                .replace(/ /g, "-")
                .replace(/&amp;/g, "")
                .replace(/T/g, "")
                .replace(/D/g, "")
                .replace(/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g, "")
                .toLowerCase()
            : A.rawHeaderId
              ? e
                  .replace(/ /g, "-")
                  .replace(/&amp;/g, "&")
                  .replace(/T/g, "")
                  .replace(/D/g, "$")
                  .replace(/["']/g, "-")
                  .toLowerCase()
              : e.replace(/[^\w]/g, "").toLowerCase()),
          A.rawPrefixHeaderId && (e = r + e),
          C.hashLinkCounts[e]
            ? (e = e + "-" + C.hashLinkCounts[e]++)
            : (C.hashLinkCounts[e] = 1),
          e
        );
      }
      g = C.converter._dispatch("headers.before", g, A, C);
      var r = isNaN(parseInt(A.headerLevelStart))
          ? 1
          : parseInt(A.headerLevelStart),
        t = A.smoothLivePreview
          ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm
          : /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
        a = A.smoothLivePreview
          ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm
          : /^(.+)[ \t]*\n-+[ \t]*\n+/gm;
      g = (g = g.replace(t, function(g, t) {
        var a = I.subParser("spanGamut")(t, A, C),
          n = A.noHeaderId ? "" : ' id="' + e(t) + '"',
          o = "<h" + r + n + ">" + a + "</h" + r + ">";
        return I.subParser("hashBlock")(o, A, C);
      })).replace(a, function(g, t) {
        var a = I.subParser("spanGamut")(t, A, C),
          n = A.noHeaderId ? "" : ' id="' + e(t) + '"',
          o = r + 1,
          s = "<h" + o + n + ">" + a + "</h" + o + ">";
        return I.subParser("hashBlock")(s, A, C);
      });
      var n = A.requireSpaceBeforeHeadingText
        ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm
        : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;
      return (
        (g = g.replace(n, function(g, t, a) {
          var n = a;
          A.customizedHeaderId && (n = a.replace(/\s?\{([^{]+?)}\s*$/, ""));
          var o = I.subParser("spanGamut")(n, A, C),
            s = A.noHeaderId ? "" : ' id="' + e(a) + '"',
            i = r - 1 + t.length,
            l = "<h" + i + s + ">" + o + "</h" + i + ">";
          return I.subParser("hashBlock")(l, A, C);
        })),
        (g = C.converter._dispatch("headers.after", g, A, C))
      );
    }),
    I.subParser("horizontalRule", function(g, A, C) {
      "use strict";
      g = C.converter._dispatch("horizontalRule.before", g, A, C);
      var e = I.subParser("hashBlock")("<hr />", A, C);
      return (
        (g = g.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, e)),
        (g = g.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, e)),
        (g = g.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, e)),
        (g = C.converter._dispatch("horizontalRule.after", g, A, C))
      );
    }),
    I.subParser("images", function(g, A, C) {
      "use strict";
      function e(g, A, e, r, t, a, n, o) {
        var s = C.gUrls,
          i = C.gTitles,
          l = C.gDimensions;
        if (
          ((e = e.toLowerCase()),
          o || (o = ""),
          g.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)
        )
          r = "";
        else if ("" === r || null === r) {
          if (
            (("" !== e && null !== e) ||
              (e = A.toLowerCase().replace(/ ?\n/g, " ")),
            (r = "#" + e),
            I.helper.isUndefined(s[e]))
          )
            return g;
          (r = s[e]),
            I.helper.isUndefined(i[e]) || (o = i[e]),
            I.helper.isUndefined(l[e]) || ((t = l[e].width), (a = l[e].height));
        }
        A = A.replace(/"/g, "&quot;").replace(
          I.helper.regexes.asteriskDashAndColon,
          I.helper.escapeCharactersCallback
        );
        var c =
          '<img src="' +
          (r = r.replace(
            I.helper.regexes.asteriskDashAndColon,
            I.helper.escapeCharactersCallback
          )) +
          '" alt="' +
          A +
          '"';
        return (
          o &&
            (c +=
              ' title="' +
              (o = o
                .replace(/"/g, "&quot;")
                .replace(
                  I.helper.regexes.asteriskDashAndColon,
                  I.helper.escapeCharactersCallback
                )) +
              '"'),
          t &&
            a &&
            ((c += ' width="' + (t = "*" === t ? "auto" : t) + '"'),
            (c += ' height="' + (a = "*" === a ? "auto" : a) + '"')),
          (c += " />")
        );
      }
      return (
        (g = (g = C.converter._dispatch("images.before", g, A, C)).replace(
          /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
          e
        )),
        (g = g.replace(
          /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
          function(g, A, C, I, r, t, a, n) {
            return (I = I.replace(/\s/g, "")), e(g, A, C, I, r, t, 0, n);
          }
        )),
        (g = g.replace(
          /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
          e
        )),
        (g = g.replace(
          /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
          e
        )),
        (g = g.replace(/!\[([^\[\]]+)]()()()()()/g, e)),
        (g = C.converter._dispatch("images.after", g, A, C))
      );
    }),
    I.subParser("italicsAndBold", function(g, A, C) {
      "use strict";
      function I(g, A, C) {
        return A + g + C;
      }
      return (
        (g = C.converter._dispatch("italicsAndBold.before", g, A, C)),
        (g = A.literalMidWordUnderscores
          ? (g = (g = g.replace(/\b___(\S[\s\S]*)___\b/g, function(g, A) {
              return I(A, "<strong><em>", "</em></strong>");
            })).replace(/\b__(\S[\s\S]*)__\b/g, function(g, A) {
              return I(A, "<strong>", "</strong>");
            })).replace(/\b_(\S[\s\S]*?)_\b/g, function(g, A) {
              return I(A, "<em>", "</em>");
            })
          : (g = (g = g.replace(/___(\S[\s\S]*?)___/g, function(g, A) {
              return /\S$/.test(A) ? I(A, "<strong><em>", "</em></strong>") : g;
            })).replace(/__(\S[\s\S]*?)__/g, function(g, A) {
              return /\S$/.test(A) ? I(A, "<strong>", "</strong>") : g;
            })).replace(/_([^\s_][\s\S]*?)_/g, function(g, A) {
              return /\S$/.test(A) ? I(A, "<em>", "</em>") : g;
            })),
        (g = A.literalMidWordAsterisks
          ? (g = (g = g.replace(
              /([^*]|^)\B\*\*\*(\S[\s\S]+?)\*\*\*\B(?!\*)/g,
              function(g, A, C) {
                return I(C, A + "<strong><em>", "</em></strong>");
              }
            )).replace(/([^*]|^)\B\*\*(\S[\s\S]+?)\*\*\B(?!\*)/g, function(
              g,
              A,
              C
            ) {
              return I(C, A + "<strong>", "</strong>");
            })).replace(/([^*]|^)\B\*(\S[\s\S]+?)\*\B(?!\*)/g, function(
              g,
              A,
              C
            ) {
              return I(C, A + "<em>", "</em>");
            })
          : (g = (g = g.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function(g, A) {
              return /\S$/.test(A) ? I(A, "<strong><em>", "</em></strong>") : g;
            })).replace(/\*\*(\S[\s\S]*?)\*\*/g, function(g, A) {
              return /\S$/.test(A) ? I(A, "<strong>", "</strong>") : g;
            })).replace(/\*([^\s*][\s\S]*?)\*/g, function(g, A) {
              return /\S$/.test(A) ? I(A, "<em>", "</em>") : g;
            })),
        (g = C.converter._dispatch("italicsAndBold.after", g, A, C))
      );
    }),
    I.subParser("lists", function(g, A, C) {
      "use strict";
      function e(g, e) {
        C.gListLevel++, (g = g.replace(/\n{2,}$/, "\n"));
        var r = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
          t = /\n[ \t]*\n(?!0)/.test((g += "0"));
        return (
          A.disableForced4SpacesIndentedSublists &&
            (r = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm),
          (g = g.replace(r, function(g, e, r, a, n, o, s) {
            s = s && "" !== s.trim();
            var i = I.subParser("outdent")(n, A, C),
              l = "";
            return (
              o &&
                A.tasklists &&
                ((l = ' class="task-list-item" style="list-style-type: none;"'),
                (i = i.replace(/^[ \t]*\[(x|X| )?]/m, function() {
                  var g =
                    '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
                  return s && (g += " checked"), (g += ">");
                }))),
              (i = i.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function(g) {
                return "A" + g;
              })),
              e || i.search(/\n{2,}/) > -1
                ? ((i = I.subParser("githubCodeBlocks")(i, A, C)),
                  (i = I.subParser("blockGamut")(i, A, C)))
                : ((i = (i = I.subParser("lists")(i, A, C)).replace(/\n$/, "")),
                  (i = (i = I.subParser("hashHTMLBlocks")(i, A, C)).replace(
                    /\n\n+/g,
                    "\n\n"
                  )),
                  (i = t
                    ? I.subParser("paragraphs")(i, A, C)
                    : I.subParser("spanGamut")(i, A, C))),
              (i = i.replace("A", "")),
              (i = "<li" + l + ">" + i + "</li>\n")
            );
          })),
          (g = g.replace(/0/g, "")),
          C.gListLevel--,
          e && (g = g.replace(/\s+$/, "")),
          g
        );
      }
      function r(g, A) {
        if ("ol" === A) {
          var C = g.match(/^ *(\d+)\./);
          if (C && "1" !== C[1]) return ' start="' + C[1] + '"';
        }
        return "";
      }
      function t(g, C, I) {
        var t = A.disableForced4SpacesIndentedSublists
            ? /^ ?\d+\.[ \t]/gm
            : /^ {0,3}\d+\.[ \t]/gm,
          a = A.disableForced4SpacesIndentedSublists
            ? /^ ?[*+-][ \t]/gm
            : /^ {0,3}[*+-][ \t]/gm,
          n = "ul" === C ? t : a,
          o = "";
        if (-1 !== g.search(n))
          !(function A(s) {
            var i = s.search(n),
              l = r(g, C);
            -1 !== i
              ? ((o +=
                  "\n\n<" +
                  C +
                  l +
                  ">\n" +
                  e(s.slice(0, i), !!I) +
                  "</" +
                  C +
                  ">\n"),
                (n = "ul" === (C = "ul" === C ? "ol" : "ul") ? t : a),
                A(s.slice(i)))
              : (o += "\n\n<" + C + l + ">\n" + e(s, !!I) + "</" + C + ">\n");
          })(g);
        else {
          var s = r(g, C);
          o = "\n\n<" + C + s + ">\n" + e(g, !!I) + "</" + C + ">\n";
        }
        return o;
      }
      return (
        (g = C.converter._dispatch("lists.before", g, A, C)),
        (g += "0"),
        (g = C.gListLevel
          ? g.replace(
              /^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
              function(g, A, C) {
                return t(A, C.search(/[*+-]/g) > -1 ? "ul" : "ol", !0);
              }
            )
          : g.replace(
              /(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
              function(g, A, C, I) {
                return t(C, I.search(/[*+-]/g) > -1 ? "ul" : "ol", !1);
              }
            )),
        (g = g.replace(/0/, "")),
        (g = C.converter._dispatch("lists.after", g, A, C))
      );
    }),
    I.subParser("metadata", function(g, A, C) {
      "use strict";
      function I(g) {
        (C.metadata.raw = g),
          (g = (g = g.replace(/&/g, "&amp;").replace(/"/g, "&quot;")).replace(
            /\n {4}/g,
            " "
          )).replace(/^([\S ]+): +([\s\S]+?)$/gm, function(g, A, I) {
            return (C.metadata.parsed[A] = I), "";
          });
      }
      return A.metadata
        ? ((g = C.converter._dispatch("metadata.before", g, A, C)),
          (g = g.replace(/^\s*+(\S*?)\n([\s\S]+?)\n+\n/, function(
            g,
            A,
            C
          ) {
            return I(C), "M";
          })),
          (g = g.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function(
            g,
            A,
            e
          ) {
            return A && (C.metadata.format = A), I(e), "M";
          })),
          (g = g.replace(/M/g, "")),
          (g = C.converter._dispatch("metadata.after", g, A, C)))
        : g;
    }),
    I.subParser("outdent", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("outdent.before", g, A, C)),
        (g = g.replace(/^(\t|[ ]{1,4})/gm, "0")),
        (g = g.replace(/0/g, "")),
        (g = C.converter._dispatch("outdent.after", g, A, C))
      );
    }),
    I.subParser("paragraphs", function(g, A, C) {
      "use strict";
      for (
        var e = (g = (g = (g = C.converter._dispatch(
            "paragraphs.before",
            g,
            A,
            C
          )).replace(/^\n+/g, "")).replace(/\n+$/g, "")).split(/\n{2,}/g),
          r = [],
          t = e.length,
          a = 0;
        a < t;
        a++
      ) {
        var n = e[a];
        n.search(/(K|G)(\d+)\1/g) >= 0
          ? r.push(n)
          : n.search(/\S/) >= 0 &&
            ((n = (n = I.subParser("spanGamut")(n, A, C)).replace(
              /^([ \t]*)/g,
              "<p>"
            )),
            (n += "</p>"),
            r.push(n));
      }
      for (t = r.length, a = 0; a < t; a++) {
        for (var o = "", s = r[a], i = !1; /(K|G)(\d+)\1/.test(s); ) {
          var l = RegExp.$1,
            c = RegExp.$2;
          (o = (o =
            "K" === l
              ? C.gHtmlBlocks[c]
              : i
                ? I.subParser("encodeCode")(C.ghCodeBlocks[c].text, A, C)
                : C.ghCodeBlocks[c].codeblock).replace(/\$/g, "$$$$")),
            (s = s.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, o)),
            /^<pre\b[^>]*>\s*<code\b[^>]*>/.test(s) && (i = !0);
        }
        r[a] = s;
      }
      return (
        (g = r.join("\n")),
        (g = g.replace(/^\n+/g, "")),
        (g = g.replace(/\n+$/g, "")),
        C.converter._dispatch("paragraphs.after", g, A, C)
      );
    }),
    I.subParser("runExtension", function(g, A, C, I) {
      "use strict";
      if (g.filter) A = g.filter(A, I.converter, C);
      else if (g.regex) {
        var e = g.regex;
        e instanceof RegExp || (e = new RegExp(e, "g")),
          (A = A.replace(e, g.replace));
      }
      return A;
    }),
    I.subParser("spanGamut", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("spanGamut.before", g, A, C)),
        (g = I.subParser("codeSpans")(g, A, C)),
        (g = I.subParser("escapeSpecialCharsWithinTagAttributes")(g, A, C)),
        (g = I.subParser("encodeBackslashEscapes")(g, A, C)),
        (g = I.subParser("images")(g, A, C)),
        (g = I.subParser("anchors")(g, A, C)),
        (g = I.subParser("autoLinks")(g, A, C)),
        (g = I.subParser("simplifiedAutoLinks")(g, A, C)),
        (g = I.subParser("emoji")(g, A, C)),
        (g = I.subParser("underline")(g, A, C)),
        (g = I.subParser("italicsAndBold")(g, A, C)),
        (g = I.subParser("strikethrough")(g, A, C)),
        (g = I.subParser("ellipsis")(g, A, C)),
        (g = I.subParser("hashHTMLSpans")(g, A, C)),
        (g = I.subParser("encodeAmpsAndAngles")(g, A, C)),
        A.simpleLineBreaks
          ? /\n\nK/.test(g) || (g = g.replace(/\n+/g, "<br />\n"))
          : (g = g.replace(/  +\n/g, "<br />\n")),
        (g = C.converter._dispatch("spanGamut.after", g, A, C))
      );
    }),
    I.subParser("strikethrough", function(g, A, C) {
      "use strict";
      return (
        A.strikethrough &&
          ((g = (g = C.converter._dispatch(
            "strikethrough.before",
            g,
            A,
            C
          )).replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function(g, e) {
            return (function(g) {
              return (
                A.simplifiedAutoLink &&
                  (g = I.subParser("simplifiedAutoLinks")(g, A, C)),
                "<del>" + g + "</del>"
              );
            })(e);
          })),
          (g = C.converter._dispatch("strikethrough.after", g, A, C))),
        g
      );
    }),
    I.subParser("stripLinkDefinitions", function(g, A, C) {
      "use strict";
      var e = function(g, e, r, t, a, n, o) {
        return (
          (e = e.toLowerCase()),
          r.match(/^data:.+?\/.+?;base64,/)
            ? (C.gUrls[e] = r.replace(/\s/g, ""))
            : (C.gUrls[e] = I.subParser("encodeAmpsAndAngles")(r, A, C)),
          n
            ? n + o
            : (o && (C.gTitles[e] = o.replace(/"|'/g, "&quot;")),
              A.parseImgDimensions &&
                t &&
                a &&
                (C.gDimensions[e] = { width: t, height: a }),
              "")
        );
      };
      return (
        (g = (g += "0").replace(
          /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm,
          e
        )),
        (g = g.replace(
          /^ {0,3}\[(.+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm,
          e
        )),
        (g = g.replace(/0/, ""))
      );
    }),
    I.subParser("tables", function(g, A, C) {
      "use strict";
      function e(g) {
        return /^:[ \t]*--*$/.test(g)
          ? ' style="text-align:left;"'
          : /^--*[ \t]*:[ \t]*$/.test(g)
            ? ' style="text-align:right;"'
            : /^:[ \t]*--*[ \t]*:$/.test(g)
              ? ' style="text-align:center;"'
              : "";
      }
      function r(g, e) {
        var r = "";
        return (
          (g = g.trim()),
          (A.tablesHeaderId || A.tableHeaderId) &&
            (r = ' id="' + g.replace(/ /g, "_").toLowerCase() + '"'),
          (g = I.subParser("spanGamut")(g, A, C)),
          "<th" + r + e + ">" + g + "</th>\n"
        );
      }
      function t(g, e) {
        return "<td" + e + ">" + I.subParser("spanGamut")(g, A, C) + "</td>\n";
      }
      function a(g) {
        var a,
          n = g.split("\n");
        for (a = 0; a < n.length; ++a)
          /^ {0,3}\|/.test(n[a]) && (n[a] = n[a].replace(/^ {0,3}\|/, "")),
            /\|[ \t]*$/.test(n[a]) && (n[a] = n[a].replace(/\|[ \t]*$/, "")),
            (n[a] = I.subParser("codeSpans")(n[a], A, C));
        var o = n[0].split("|").map(function(g) {
            return g.trim();
          }),
          s = n[1].split("|").map(function(g) {
            return g.trim();
          }),
          i = [],
          l = [],
          c = [],
          u = [];
        for (n.shift(), n.shift(), a = 0; a < n.length; ++a)
          "" !== n[a].trim() &&
            i.push(
              n[a].split("|").map(function(g) {
                return g.trim();
              })
            );
        if (o.length < s.length) return g;
        for (a = 0; a < s.length; ++a) c.push(e(s[a]));
        for (a = 0; a < o.length; ++a)
          I.helper.isUndefined(c[a]) && (c[a] = ""), l.push(r(o[a], c[a]));
        for (a = 0; a < i.length; ++a) {
          for (var d = [], p = 0; p < l.length; ++p)
            I.helper.isUndefined(i[a][p]), d.push(t(i[a][p], c[p]));
          u.push(d);
        }
        return (function(g, A) {
          for (
            var C = "<table>\n<thead>\n<tr>\n", I = g.length, e = 0;
            e < I;
            ++e
          )
            C += g[e];
          for (C += "</tr>\n</thead>\n<tbody>\n", e = 0; e < A.length; ++e) {
            C += "<tr>\n";
            for (var r = 0; r < I; ++r) C += A[e][r];
            C += "</tr>\n";
          }
          return (C += "</tbody>\n</table>\n");
        })(l, u);
      }
      if (!A.tables) return g;
      return (
        (g = C.converter._dispatch("tables.before", g, A, C)),
        (g = g.replace(/\\(\|)/g, I.helper.escapeCharactersCallback)),
        (g = g.replace(
          /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm,
          a
        )),
        (g = g.replace(
          /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm,
          a
        )),
        (g = C.converter._dispatch("tables.after", g, A, C))
      );
    }),
    I.subParser("underline", function(g, A, C) {
      "use strict";
      return A.underline
        ? ((g = C.converter._dispatch("underline.before", g, A, C)),
          (g = A.literalMidWordUnderscores
            ? g.replace(/\b_?__(\S[\s\S]*)___?\b/g, function(g, A) {
                return "<u>" + A + "</u>";
              })
            : g.replace(/_?__(\S[\s\S]*?)___?/g, function(g, A) {
                return /\S$/.test(A) ? "<u>" + A + "</u>" : g;
              })),
          (g = g.replace(/(_)/g, I.helper.escapeCharactersCallback)),
          (g = C.converter._dispatch("underline.after", g, A, C)))
        : g;
    }),
    I.subParser("unescapeSpecialChars", function(g, A, C) {
      "use strict";
      return (
        (g = C.converter._dispatch("unescapeSpecialChars.before", g, A, C)),
        (g = g.replace(/E(\d+)E/g, function(g, A) {
          var C = parseInt(A);
          return String.fromCharCode(C);
        })),
        (g = C.converter._dispatch("unescapeSpecialChars.after", g, A, C))
      );
    });
  "function" == typeof define && define.amd
    ? define(function() {
        "use strict";
        return I;
      })
    : "undefined" != typeof module && module.exports
      ? (module.exports = I)
      : (this.showdown = I);
}.call(this));
//# sourceMappingURL=showdown.min.js.map

/*!
 DataTables 1.10.16
 2008-2017 SpryMedia Ltd - datatables.net/license
*/
(function(h) {
  "function" === typeof define && define.amd
    ? define(["jquery"], function(E) {
        return h(E, window, document);
      })
    : "object" === typeof exports
      ? (module.exports = function(E, G) {
          E || (E = window);
          G ||
            (G =
              "undefined" !== typeof window
                ? require("jquery")
                : require("jquery")(E));
          return h(G, E, E.document);
        })
      : h(jQuery, window, document);
})(function(h, E, G, k) {
  function X(a) {
    var b,
      c,
      d = {};
    h.each(a, function(e) {
      if (
        (b = e.match(/^([^A-Z]+?)([A-Z])/)) &&
        -1 !== "a aa ai ao as b fn i m o s ".indexOf(b[1] + " ")
      )
        (c = e.replace(b[0], b[2].toLowerCase())),
          (d[c] = e),
          "o" === b[1] && X(a[e]);
    });
    a._hungarianMap = d;
  }
  function I(a, b, c) {
    a._hungarianMap || X(a);
    var d;
    h.each(b, function(e) {
      d = a._hungarianMap[e];
      if (d !== k && (c || b[d] === k))
        "o" === d.charAt(0)
          ? (b[d] || (b[d] = {}), h.extend(!0, b[d], b[e]), I(a[d], b[d], c))
          : (b[d] = b[e]);
    });
  }
  function Ca(a) {
    var b = m.defaults.oLanguage,
      c = a.sZeroRecords;
    !a.sEmptyTable &&
      (c && "No data available in table" === b.sEmptyTable) &&
      F(a, a, "sZeroRecords", "sEmptyTable");
    !a.sLoadingRecords &&
      (c && "Loading..." === b.sLoadingRecords) &&
      F(a, a, "sZeroRecords", "sLoadingRecords");
    a.sInfoThousands && (a.sThousands = a.sInfoThousands);
    (a = a.sDecimal) && cb(a);
  }
  function db(a) {
    A(a, "ordering", "bSort");
    A(a, "orderMulti", "bSortMulti");
    A(a, "orderClasses", "bSortClasses");
    A(a, "orderCellsTop", "bSortCellsTop");
    A(a, "order", "aaSorting");
    A(a, "orderFixed", "aaSortingFixed");
    A(a, "paging", "bPaginate");
    A(a, "pagingType", "sPaginationType");
    A(a, "pageLength", "iDisplayLength");
    A(a, "searching", "bFilter");
    "boolean" === typeof a.sScrollX && (a.sScrollX = a.sScrollX ? "100%" : "");
    "boolean" === typeof a.scrollX && (a.scrollX = a.scrollX ? "100%" : "");
    if ((a = a.aoSearchCols))
      for (var b = 0, c = a.length; b < c; b++)
        a[b] && I(m.models.oSearch, a[b]);
  }
  function eb(a) {
    A(a, "orderable", "bSortable");
    A(a, "orderData", "aDataSort");
    A(a, "orderSequence", "asSorting");
    A(a, "orderDataType", "sortDataType");
    var b = a.aDataSort;
    "number" === typeof b && !h.isArray(b) && (a.aDataSort = [b]);
  }
  function fb(a) {
    if (!m.__browser) {
      var b = {};
      m.__browser = b;
      var c = h("<div/>")
          .css({
            position: "fixed",
            top: 0,
            left: -1 * h(E).scrollLeft(),
            height: 1,
            width: 1,
            overflow: "hidden"
          })
          .append(
            h("<div/>")
              .css({
                position: "absolute",
                top: 1,
                left: 1,
                width: 100,
                overflow: "scroll"
              })
              .append(h("<div/>").css({ width: "100%", height: 10 }))
          )
          .appendTo("body"),
        d = c.children(),
        e = d.children();
      b.barWidth = d[0].offsetWidth - d[0].clientWidth;
      b.bScrollOversize = 100 === e[0].offsetWidth && 100 !== d[0].clientWidth;
      b.bScrollbarLeft = 1 !== Math.round(e.offset().left);
      b.bBounding = c[0].getBoundingClientRect().width ? !0 : !1;
      c.remove();
    }
    h.extend(a.oBrowser, m.__browser);
    a.oScroll.iBarWidth = m.__browser.barWidth;
  }
  function gb(a, b, c, d, e, f) {
    var g,
      j = !1;
    c !== k && ((g = c), (j = !0));
    for (; d !== e; )
      a.hasOwnProperty(d) &&
        ((g = j ? b(g, a[d], d, a) : a[d]), (j = !0), (d += f));
    return g;
  }
  function Da(a, b) {
    var c = m.defaults.column,
      d = a.aoColumns.length,
      c = h.extend({}, m.models.oColumn, c, {
        nTh: b ? b : G.createElement("th"),
        sTitle: c.sTitle ? c.sTitle : b ? b.innerHTML : "",
        aDataSort: c.aDataSort ? c.aDataSort : [d],
        mData: c.mData ? c.mData : d,
        idx: d
      });
    a.aoColumns.push(c);
    c = a.aoPreSearchCols;
    c[d] = h.extend({}, m.models.oSearch, c[d]);
    ja(a, d, h(b).data());
  }
  function ja(a, b, c) {
    var b = a.aoColumns[b],
      d = a.oClasses,
      e = h(b.nTh);
    if (!b.sWidthOrig) {
      b.sWidthOrig = e.attr("width") || null;
      var f = (e.attr("style") || "").match(/width:\s*(\d+[pxem%]+)/);
      f && (b.sWidthOrig = f[1]);
    }
    c !== k &&
      null !== c &&
      (eb(c),
      I(m.defaults.column, c),
      c.mDataProp !== k && !c.mData && (c.mData = c.mDataProp),
      c.sType && (b._sManualType = c.sType),
      c.className && !c.sClass && (c.sClass = c.className),
      c.sClass && e.addClass(c.sClass),
      h.extend(b, c),
      F(b, c, "sWidth", "sWidthOrig"),
      c.iDataSort !== k && (b.aDataSort = [c.iDataSort]),
      F(b, c, "aDataSort"));
    var g = b.mData,
      j = Q(g),
      i = b.mRender ? Q(b.mRender) : null,
      c = function(a) {
        return "string" === typeof a && -1 !== a.indexOf("@");
      };
    b._bAttrSrc = h.isPlainObject(g) && (c(g.sort) || c(g.type) || c(g.filter));
    b._setter = null;
    b.fnGetData = function(a, b, c) {
      var d = j(a, b, k, c);
      return i && b ? i(d, b, a, c) : d;
    };
    b.fnSetData = function(a, b, c) {
      return R(g)(a, b, c);
    };
    "number" !== typeof g && (a._rowReadObject = !0);
    a.oFeatures.bSort || ((b.bSortable = !1), e.addClass(d.sSortableNone));
    a = -1 !== h.inArray("asc", b.asSorting);
    c = -1 !== h.inArray("desc", b.asSorting);
    !b.bSortable || (!a && !c)
      ? ((b.sSortingClass = d.sSortableNone), (b.sSortingClassJUI = ""))
      : a && !c
        ? ((b.sSortingClass = d.sSortableAsc),
          (b.sSortingClassJUI = d.sSortJUIAscAllowed))
        : !a && c
          ? ((b.sSortingClass = d.sSortableDesc),
            (b.sSortingClassJUI = d.sSortJUIDescAllowed))
          : ((b.sSortingClass = d.sSortable),
            (b.sSortingClassJUI = d.sSortJUI));
  }
  function Y(a) {
    if (!1 !== a.oFeatures.bAutoWidth) {
      var b = a.aoColumns;
      Ea(a);
      for (var c = 0, d = b.length; c < d; c++)
        b[c].nTh.style.width = b[c].sWidth;
    }
    b = a.oScroll;
    ("" !== b.sY || "" !== b.sX) && ka(a);
    r(a, null, "column-sizing", [a]);
  }
  function Z(a, b) {
    var c = la(a, "bVisible");
    return "number" === typeof c[b] ? c[b] : null;
  }
  function $(a, b) {
    var c = la(a, "bVisible"),
      c = h.inArray(b, c);
    return -1 !== c ? c : null;
  }
  function aa(a) {
    var b = 0;
    h.each(a.aoColumns, function(a, d) {
      d.bVisible && "none" !== h(d.nTh).css("display") && b++;
    });
    return b;
  }
  function la(a, b) {
    var c = [];
    h.map(a.aoColumns, function(a, e) {
      a[b] && c.push(e);
    });
    return c;
  }
  function Fa(a) {
    var b = a.aoColumns,
      c = a.aoData,
      d = m.ext.type.detect,
      e,
      f,
      g,
      j,
      i,
      h,
      l,
      q,
      t;
    e = 0;
    for (f = b.length; e < f; e++)
      if (((l = b[e]), (t = []), !l.sType && l._sManualType))
        l.sType = l._sManualType;
      else if (!l.sType) {
        g = 0;
        for (j = d.length; g < j; g++) {
          i = 0;
          for (h = c.length; i < h; i++) {
            t[i] === k && (t[i] = B(a, i, e, "type"));
            q = d[g](t[i], a);
            if (!q && g !== d.length - 1) break;
            if ("html" === q) break;
          }
          if (q) {
            l.sType = q;
            break;
          }
        }
        l.sType || (l.sType = "string");
      }
  }
  function hb(a, b, c, d) {
    var e,
      f,
      g,
      j,
      i,
      n,
      l = a.aoColumns;
    if (b)
      for (e = b.length - 1; 0 <= e; e--) {
        n = b[e];
        var q = n.targets !== k ? n.targets : n.aTargets;
        h.isArray(q) || (q = [q]);
        f = 0;
        for (g = q.length; f < g; f++)
          if ("number" === typeof q[f] && 0 <= q[f]) {
            for (; l.length <= q[f]; ) Da(a);
            d(q[f], n);
          } else if ("number" === typeof q[f] && 0 > q[f])
            d(l.length + q[f], n);
          else if ("string" === typeof q[f]) {
            j = 0;
            for (i = l.length; j < i; j++)
              ("_all" == q[f] || h(l[j].nTh).hasClass(q[f])) && d(j, n);
          }
      }
    if (c) {
      e = 0;
      for (a = c.length; e < a; e++) d(e, c[e]);
    }
  }
  function M(a, b, c, d) {
    var e = a.aoData.length,
      f = h.extend(!0, {}, m.models.oRow, { src: c ? "dom" : "data", idx: e });
    f._aData = b;
    a.aoData.push(f);
    for (var g = a.aoColumns, j = 0, i = g.length; j < i; j++)
      g[j].sType = null;
    a.aiDisplayMaster.push(e);
    b = a.rowIdFn(b);
    b !== k && (a.aIds[b] = f);
    (c || !a.oFeatures.bDeferRender) && Ga(a, e, c, d);
    return e;
  }
  function ma(a, b) {
    var c;
    b instanceof h || (b = h(b));
    return b.map(function(b, e) {
      c = Ha(a, e);
      return M(a, c.data, e, c.cells);
    });
  }
  function B(a, b, c, d) {
    var e = a.iDraw,
      f = a.aoColumns[c],
      g = a.aoData[b]._aData,
      j = f.sDefaultContent,
      i = f.fnGetData(g, d, { settings: a, row: b, col: c });
    if (i === k)
      return (
        a.iDrawError != e &&
          null === j &&
          (J(
            a,
            0,
            "Requested unknown parameter " +
              ("function" == typeof f.mData
                ? "{function}"
                : "'" + f.mData + "'") +
              " for row " +
              b +
              ", column " +
              c,
            4
          ),
          (a.iDrawError = e)),
        j
      );
    if ((i === g || null === i) && null !== j && d !== k) i = j;
    else if ("function" === typeof i) return i.call(g);
    return null === i && "display" == d ? "" : i;
  }
  function ib(a, b, c, d) {
    a.aoColumns[c].fnSetData(a.aoData[b]._aData, d, {
      settings: a,
      row: b,
      col: c
    });
  }
  function Ia(a) {
    return h.map(a.match(/(\\.|[^\.])+/g) || [""], function(a) {
      return a.replace(/\\\./g, ".");
    });
  }
  function Q(a) {
    if (h.isPlainObject(a)) {
      var b = {};
      h.each(a, function(a, c) {
        c && (b[a] = Q(c));
      });
      return function(a, c, f, g) {
        var j = b[c] || b._;
        return j !== k ? j(a, c, f, g) : a;
      };
    }
    if (null === a)
      return function(a) {
        return a;
      };
    if ("function" === typeof a)
      return function(b, c, f, g) {
        return a(b, c, f, g);
      };
    if (
      "string" === typeof a &&
      (-1 !== a.indexOf(".") || -1 !== a.indexOf("[") || -1 !== a.indexOf("("))
    ) {
      var c = function(a, b, f) {
        var g, j;
        if ("" !== f) {
          j = Ia(f);
          for (var i = 0, n = j.length; i < n; i++) {
            f = j[i].match(ba);
            g = j[i].match(U);
            if (f) {
              j[i] = j[i].replace(ba, "");
              "" !== j[i] && (a = a[j[i]]);
              g = [];
              j.splice(0, i + 1);
              j = j.join(".");
              if (h.isArray(a)) {
                i = 0;
                for (n = a.length; i < n; i++) g.push(c(a[i], b, j));
              }
              a = f[0].substring(1, f[0].length - 1);
              a = "" === a ? g : g.join(a);
              break;
            } else if (g) {
              j[i] = j[i].replace(U, "");
              a = a[j[i]]();
              continue;
            }
            if (null === a || a[j[i]] === k) return k;
            a = a[j[i]];
          }
        }
        return a;
      };
      return function(b, e) {
        return c(b, e, a);
      };
    }
    return function(b) {
      return b[a];
    };
  }
  function R(a) {
    if (h.isPlainObject(a)) return R(a._);
    if (null === a) return function() {};
    if ("function" === typeof a)
      return function(b, d, e) {
        a(b, "set", d, e);
      };
    if (
      "string" === typeof a &&
      (-1 !== a.indexOf(".") || -1 !== a.indexOf("[") || -1 !== a.indexOf("("))
    ) {
      var b = function(a, d, e) {
        var e = Ia(e),
          f;
        f = e[e.length - 1];
        for (var g, j, i = 0, n = e.length - 1; i < n; i++) {
          g = e[i].match(ba);
          j = e[i].match(U);
          if (g) {
            e[i] = e[i].replace(ba, "");
            a[e[i]] = [];
            f = e.slice();
            f.splice(0, i + 1);
            g = f.join(".");
            if (h.isArray(d)) {
              j = 0;
              for (n = d.length; j < n; j++)
                (f = {}), b(f, d[j], g), a[e[i]].push(f);
            } else a[e[i]] = d;
            return;
          }
          j && ((e[i] = e[i].replace(U, "")), (a = a[e[i]](d)));
          if (null === a[e[i]] || a[e[i]] === k) a[e[i]] = {};
          a = a[e[i]];
        }
        if (f.match(U)) a[f.replace(U, "")](d);
        else a[f.replace(ba, "")] = d;
      };
      return function(c, d) {
        return b(c, d, a);
      };
    }
    return function(b, d) {
      b[a] = d;
    };
  }
  function Ja(a) {
    return D(a.aoData, "_aData");
  }
  function na(a) {
    a.aoData.length = 0;
    a.aiDisplayMaster.length = 0;
    a.aiDisplay.length = 0;
    a.aIds = {};
  }
  function oa(a, b, c) {
    for (var d = -1, e = 0, f = a.length; e < f; e++)
      a[e] == b ? (d = e) : a[e] > b && a[e]--;
    -1 != d && c === k && a.splice(d, 1);
  }
  function ca(a, b, c, d) {
    var e = a.aoData[b],
      f,
      g = function(c, d) {
        for (; c.childNodes.length; ) c.removeChild(c.firstChild);
        c.innerHTML = B(a, b, d, "display");
      };
    if ("dom" === c || ((!c || "auto" === c) && "dom" === e.src))
      e._aData = Ha(a, e, d, d === k ? k : e._aData).data;
    else {
      var j = e.anCells;
      if (j)
        if (d !== k) g(j[d], d);
        else {
          c = 0;
          for (f = j.length; c < f; c++) g(j[c], c);
        }
    }
    e._aSortData = null;
    e._aFilterData = null;
    g = a.aoColumns;
    if (d !== k) g[d].sType = null;
    else {
      c = 0;
      for (f = g.length; c < f; c++) g[c].sType = null;
      Ka(a, e);
    }
  }
  function Ha(a, b, c, d) {
    var e = [],
      f = b.firstChild,
      g,
      j,
      i = 0,
      n,
      l = a.aoColumns,
      q = a._rowReadObject,
      d = d !== k ? d : q ? {} : [],
      t = function(a, b) {
        if ("string" === typeof a) {
          var c = a.indexOf("@");
          -1 !== c && ((c = a.substring(c + 1)), R(a)(d, b.getAttribute(c)));
        }
      },
      m = function(a) {
        if (c === k || c === i)
          (j = l[i]),
            (n = h.trim(a.innerHTML)),
            j && j._bAttrSrc
              ? (R(j.mData._)(d, n),
                t(j.mData.sort, a),
                t(j.mData.type, a),
                t(j.mData.filter, a))
              : q
                ? (j._setter || (j._setter = R(j.mData)), j._setter(d, n))
                : (d[i] = n);
        i++;
      };
    if (f)
      for (; f; ) {
        g = f.nodeName.toUpperCase();
        if ("TD" == g || "TH" == g) m(f), e.push(f);
        f = f.nextSibling;
      }
    else {
      e = b.anCells;
      f = 0;
      for (g = e.length; f < g; f++) m(e[f]);
    }
    if ((b = b.firstChild ? b : b.nTr))
      (b = b.getAttribute("id")) && R(a.rowId)(d, b);
    return { data: d, cells: e };
  }
  function Ga(a, b, c, d) {
    var e = a.aoData[b],
      f = e._aData,
      g = [],
      j,
      i,
      n,
      l,
      q;
    if (null === e.nTr) {
      j = c || G.createElement("tr");
      e.nTr = j;
      e.anCells = g;
      j._DT_RowIndex = b;
      Ka(a, e);
      l = 0;
      for (q = a.aoColumns.length; l < q; l++) {
        n = a.aoColumns[l];
        i = c ? d[l] : G.createElement(n.sCellType);
        i._DT_CellIndex = { row: b, column: l };
        g.push(i);
        if (
          (!c || n.mRender || n.mData !== l) &&
          (!h.isPlainObject(n.mData) || n.mData._ !== l + ".display")
        )
          i.innerHTML = B(a, b, l, "display");
        n.sClass && (i.className += " " + n.sClass);
        n.bVisible && !c
          ? j.appendChild(i)
          : !n.bVisible && c && i.parentNode.removeChild(i);
        n.fnCreatedCell &&
          n.fnCreatedCell.call(a.oInstance, i, B(a, b, l), f, b, l);
      }
      r(a, "aoRowCreatedCallback", null, [j, f, b]);
    }
    e.nTr.setAttribute("role", "row");
  }
  function Ka(a, b) {
    var c = b.nTr,
      d = b._aData;
    if (c) {
      var e = a.rowIdFn(d);
      e && (c.id = e);
      d.DT_RowClass &&
        ((e = d.DT_RowClass.split(" ")),
        (b.__rowc = b.__rowc ? qa(b.__rowc.concat(e)) : e),
        h(c)
          .removeClass(b.__rowc.join(" "))
          .addClass(d.DT_RowClass));
      d.DT_RowAttr && h(c).attr(d.DT_RowAttr);
      d.DT_RowData && h(c).data(d.DT_RowData);
    }
  }
  function jb(a) {
    var b,
      c,
      d,
      e,
      f,
      g = a.nTHead,
      j = a.nTFoot,
      i = 0 === h("th, td", g).length,
      n = a.oClasses,
      l = a.aoColumns;
    i && (e = h("<tr/>").appendTo(g));
    b = 0;
    for (c = l.length; b < c; b++)
      (f = l[b]),
        (d = h(f.nTh).addClass(f.sClass)),
        i && d.appendTo(e),
        a.oFeatures.bSort &&
          (d.addClass(f.sSortingClass),
          !1 !== f.bSortable &&
            (d.attr("tabindex", a.iTabIndex).attr("aria-controls", a.sTableId),
            La(a, f.nTh, b))),
        f.sTitle != d[0].innerHTML && d.html(f.sTitle),
        Ma(a, "header")(a, d, f, n);
    i && da(a.aoHeader, g);
    h(g)
      .find(">tr")
      .attr("role", "row");
    h(g)
      .find(">tr>th, >tr>td")
      .addClass(n.sHeaderTH);
    h(j)
      .find(">tr>th, >tr>td")
      .addClass(n.sFooterTH);
    if (null !== j) {
      a = a.aoFooter[0];
      b = 0;
      for (c = a.length; b < c; b++)
        (f = l[b]),
          (f.nTf = a[b].cell),
          f.sClass && h(f.nTf).addClass(f.sClass);
    }
  }
  function ea(a, b, c) {
    var d,
      e,
      f,
      g = [],
      j = [],
      i = a.aoColumns.length,
      n;
    if (b) {
      c === k && (c = !1);
      d = 0;
      for (e = b.length; d < e; d++) {
        g[d] = b[d].slice();
        g[d].nTr = b[d].nTr;
        for (f = i - 1; 0 <= f; f--)
          !a.aoColumns[f].bVisible && !c && g[d].splice(f, 1);
        j.push([]);
      }
      d = 0;
      for (e = g.length; d < e; d++) {
        if ((a = g[d].nTr)) for (; (f = a.firstChild); ) a.removeChild(f);
        f = 0;
        for (b = g[d].length; f < b; f++)
          if (((n = i = 1), j[d][f] === k)) {
            a.appendChild(g[d][f].cell);
            for (
              j[d][f] = 1;
              g[d + i] !== k && g[d][f].cell == g[d + i][f].cell;

            )
              (j[d + i][f] = 1), i++;
            for (; g[d][f + n] !== k && g[d][f].cell == g[d][f + n].cell; ) {
              for (c = 0; c < i; c++) j[d + c][f + n] = 1;
              n++;
            }
            h(g[d][f].cell)
              .attr("rowspan", i)
              .attr("colspan", n);
          }
      }
    }
  }
  function N(a) {
    var b = r(a, "aoPreDrawCallback", "preDraw", [a]);
    if (-1 !== h.inArray(!1, b)) C(a, !1);
    else {
      var b = [],
        c = 0,
        d = a.asStripeClasses,
        e = d.length,
        f = a.oLanguage,
        g = a.iInitDisplayStart,
        j = "ssp" == y(a),
        i = a.aiDisplay;
      a.bDrawing = !0;
      g !== k &&
        -1 !== g &&
        ((a._iDisplayStart = j ? g : g >= a.fnRecordsDisplay() ? 0 : g),
        (a.iInitDisplayStart = -1));
      var g = a._iDisplayStart,
        n = a.fnDisplayEnd();
      if (a.bDeferLoading) (a.bDeferLoading = !1), a.iDraw++, C(a, !1);
      else if (j) {
        if (!a.bDestroying && !kb(a)) return;
      } else a.iDraw++;
      if (0 !== i.length) {
        f = j ? a.aoData.length : n;
        for (j = j ? 0 : g; j < f; j++) {
          var l = i[j],
            q = a.aoData[l];
          null === q.nTr && Ga(a, l);
          l = q.nTr;
          if (0 !== e) {
            var t = d[c % e];
            q._sRowStripe != t &&
              (h(l)
                .removeClass(q._sRowStripe)
                .addClass(t),
              (q._sRowStripe = t));
          }
          r(a, "aoRowCallback", null, [l, q._aData, c, j]);
          b.push(l);
          c++;
        }
      } else
        (c = f.sZeroRecords),
          1 == a.iDraw && "ajax" == y(a)
            ? (c = f.sLoadingRecords)
            : f.sEmptyTable && 0 === a.fnRecordsTotal() && (c = f.sEmptyTable),
          (b[0] = h("<tr/>", { class: e ? d[0] : "" }).append(
            h("<td />", {
              valign: "top",
              colSpan: aa(a),
              class: a.oClasses.sRowEmpty
            }).html(c)
          )[0]);
      r(a, "aoHeaderCallback", "header", [
        h(a.nTHead).children("tr")[0],
        Ja(a),
        g,
        n,
        i
      ]);
      r(a, "aoFooterCallback", "footer", [
        h(a.nTFoot).children("tr")[0],
        Ja(a),
        g,
        n,
        i
      ]);
      d = h(a.nTBody);
      d.children().detach();
      d.append(h(b));
      r(a, "aoDrawCallback", "draw", [a]);
      a.bSorted = !1;
      a.bFiltered = !1;
      a.bDrawing = !1;
    }
  }
  function S(a, b) {
    var c = a.oFeatures,
      d = c.bFilter;
    c.bSort && lb(a);
    d ? fa(a, a.oPreviousSearch) : (a.aiDisplay = a.aiDisplayMaster.slice());
    !0 !== b && (a._iDisplayStart = 0);
    a._drawHold = b;
    N(a);
    a._drawHold = !1;
  }
  function mb(a) {
    var b = a.oClasses,
      c = h(a.nTable),
      c = h("<div/>").insertBefore(c),
      d = a.oFeatures,
      e = h("<div/>", {
        id: a.sTableId + "_wrapper",
        class: b.sWrapper + (a.nTFoot ? "" : " " + b.sNoFooter)
      });
    a.nHolding = c[0];
    a.nTableWrapper = e[0];
    a.nTableReinsertBefore = a.nTable.nextSibling;
    for (var f = a.sDom.split(""), g, j, i, n, l, q, k = 0; k < f.length; k++) {
      g = null;
      j = f[k];
      if ("<" == j) {
        i = h("<div/>")[0];
        n = f[k + 1];
        if ("'" == n || '"' == n) {
          l = "";
          for (q = 2; f[k + q] != n; ) (l += f[k + q]), q++;
          "H" == l ? (l = b.sJUIHeader) : "F" == l && (l = b.sJUIFooter);
          -1 != l.indexOf(".")
            ? ((n = l.split(".")),
              (i.id = n[0].substr(1, n[0].length - 1)),
              (i.className = n[1]))
            : "#" == l.charAt(0)
              ? (i.id = l.substr(1, l.length - 1))
              : (i.className = l);
          k += q;
        }
        e.append(i);
        e = h(i);
      } else if (">" == j) e = e.parent();
      else if ("l" == j && d.bPaginate && d.bLengthChange) g = nb(a);
      else if ("f" == j && d.bFilter) g = ob(a);
      else if ("r" == j && d.bProcessing) g = pb(a);
      else if ("t" == j) g = qb(a);
      else if ("i" == j && d.bInfo) g = rb(a);
      else if ("p" == j && d.bPaginate) g = sb(a);
      else if (0 !== m.ext.feature.length) {
        i = m.ext.feature;
        q = 0;
        for (n = i.length; q < n; q++)
          if (j == i[q].cFeature) {
            g = i[q].fnInit(a);
            break;
          }
      }
      g &&
        ((i = a.aanFeatures), i[j] || (i[j] = []), i[j].push(g), e.append(g));
    }
    c.replaceWith(e);
    a.nHolding = null;
  }
  function da(a, b) {
    var c = h(b).children("tr"),
      d,
      e,
      f,
      g,
      j,
      i,
      n,
      l,
      q,
      k;
    a.splice(0, a.length);
    f = 0;
    for (i = c.length; f < i; f++) a.push([]);
    f = 0;
    for (i = c.length; f < i; f++) {
      d = c[f];
      for (e = d.firstChild; e; ) {
        if (
          "TD" == e.nodeName.toUpperCase() ||
          "TH" == e.nodeName.toUpperCase()
        ) {
          l = 1 * e.getAttribute("colspan");
          q = 1 * e.getAttribute("rowspan");
          l = !l || 0 === l || 1 === l ? 1 : l;
          q = !q || 0 === q || 1 === q ? 1 : q;
          g = 0;
          for (j = a[f]; j[g]; ) g++;
          n = g;
          k = 1 === l ? !0 : !1;
          for (j = 0; j < l; j++)
            for (g = 0; g < q; g++)
              (a[f + g][n + j] = { cell: e, unique: k }), (a[f + g].nTr = d);
        }
        e = e.nextSibling;
      }
    }
  }
  function ra(a, b, c) {
    var d = [];
    c || ((c = a.aoHeader), b && ((c = []), da(c, b)));
    for (var b = 0, e = c.length; b < e; b++)
      for (var f = 0, g = c[b].length; f < g; f++)
        if (c[b][f].unique && (!d[f] || !a.bSortCellsTop)) d[f] = c[b][f].cell;
    return d;
  }
  function sa(a, b, c) {
    r(a, "aoServerParams", "serverParams", [b]);
    if (b && h.isArray(b)) {
      var d = {},
        e = /(.*?)\[\]$/;
      h.each(b, function(a, b) {
        var c = b.name.match(e);
        c
          ? ((c = c[0]), d[c] || (d[c] = []), d[c].push(b.value))
          : (d[b.name] = b.value);
      });
      b = d;
    }
    var f,
      g = a.ajax,
      j = a.oInstance,
      i = function(b) {
        r(a, null, "xhr", [a, b, a.jqXHR]);
        c(b);
      };
    if (h.isPlainObject(g) && g.data) {
      f = g.data;
      var n = h.isFunction(f) ? f(b, a) : f,
        b = h.isFunction(f) && n ? n : h.extend(!0, b, n);
      delete g.data;
    }
    n = {
      data: b,
      success: function(b) {
        var c = b.error || b.sError;
        c && J(a, 0, c);
        a.json = b;
        i(b);
      },
      dataType: "json",
      cache: !1,
      type: a.sServerMethod,
      error: function(b, c) {
        var d = r(a, null, "xhr", [a, null, a.jqXHR]);
        -1 === h.inArray(!0, d) &&
          ("parsererror" == c
            ? J(a, 0, "Invalid JSON response", 1)
            : 4 === b.readyState && J(a, 0, "Ajax error", 7));
        C(a, !1);
      }
    };
    a.oAjaxData = b;
    r(a, null, "preXhr", [a, b]);
    a.fnServerData
      ? a.fnServerData.call(
          j,
          a.sAjaxSource,
          h.map(b, function(a, b) {
            return { name: b, value: a };
          }),
          i,
          a
        )
      : a.sAjaxSource || "string" === typeof g
        ? (a.jqXHR = h.ajax(h.extend(n, { url: g || a.sAjaxSource })))
        : h.isFunction(g)
          ? (a.jqXHR = g.call(j, b, i, a))
          : ((a.jqXHR = h.ajax(h.extend(n, g))), (g.data = f));
  }
  function kb(a) {
    return a.bAjaxDataGet
      ? (a.iDraw++,
        C(a, !0),
        sa(a, tb(a), function(b) {
          ub(a, b);
        }),
        !1)
      : !0;
  }
  function tb(a) {
    var b = a.aoColumns,
      c = b.length,
      d = a.oFeatures,
      e = a.oPreviousSearch,
      f = a.aoPreSearchCols,
      g,
      j = [],
      i,
      n,
      l,
      k = V(a);
    g = a._iDisplayStart;
    i = !1 !== d.bPaginate ? a._iDisplayLength : -1;
    var t = function(a, b) {
      j.push({ name: a, value: b });
    };
    t("sEcho", a.iDraw);
    t("iColumns", c);
    t("sColumns", D(b, "sName").join(","));
    t("iDisplayStart", g);
    t("iDisplayLength", i);
    var pa = {
      draw: a.iDraw,
      columns: [],
      order: [],
      start: g,
      length: i,
      search: { value: e.sSearch, regex: e.bRegex }
    };
    for (g = 0; g < c; g++)
      (n = b[g]),
        (l = f[g]),
        (i = "function" == typeof n.mData ? "function" : n.mData),
        pa.columns.push({
          data: i,
          name: n.sName,
          searchable: n.bSearchable,
          orderable: n.bSortable,
          search: { value: l.sSearch, regex: l.bRegex }
        }),
        t("mDataProp_" + g, i),
        d.bFilter &&
          (t("sSearch_" + g, l.sSearch),
          t("bRegex_" + g, l.bRegex),
          t("bSearchable_" + g, n.bSearchable)),
        d.bSort && t("bSortable_" + g, n.bSortable);
    d.bFilter && (t("sSearch", e.sSearch), t("bRegex", e.bRegex));
    d.bSort &&
      (h.each(k, function(a, b) {
        pa.order.push({ column: b.col, dir: b.dir });
        t("iSortCol_" + a, b.col);
        t("sSortDir_" + a, b.dir);
      }),
      t("iSortingCols", k.length));
    b = m.ext.legacy.ajax;
    return null === b ? (a.sAjaxSource ? j : pa) : b ? j : pa;
  }
  function ub(a, b) {
    var c = ta(a, b),
      d = b.sEcho !== k ? b.sEcho : b.draw,
      e = b.iTotalRecords !== k ? b.iTotalRecords : b.recordsTotal,
      f =
        b.iTotalDisplayRecords !== k
          ? b.iTotalDisplayRecords
          : b.recordsFiltered;
    if (d) {
      if (1 * d < a.iDraw) return;
      a.iDraw = 1 * d;
    }
    na(a);
    a._iRecordsTotal = parseInt(e, 10);
    a._iRecordsDisplay = parseInt(f, 10);
    d = 0;
    for (e = c.length; d < e; d++) M(a, c[d]);
    a.aiDisplay = a.aiDisplayMaster.slice();
    a.bAjaxDataGet = !1;
    N(a);
    a._bInitComplete || ua(a, b);
    a.bAjaxDataGet = !0;
    C(a, !1);
  }
  function ta(a, b) {
    var c =
      h.isPlainObject(a.ajax) && a.ajax.dataSrc !== k
        ? a.ajax.dataSrc
        : a.sAjaxDataProp;
    return "data" === c ? b.aaData || b[c] : "" !== c ? Q(c)(b) : b;
  }
  function ob(a) {
    var b = a.oClasses,
      c = a.sTableId,
      d = a.oLanguage,
      e = a.oPreviousSearch,
      f = a.aanFeatures,
      g = '<input type="search" class="' + b.sFilterInput + '"/>',
      j = d.sSearch,
      j = j.match(/_INPUT_/) ? j.replace("_INPUT_", g) : j + g,
      b = h("<div/>", {
        id: !f.f ? c + "_filter" : null,
        class: b.sFilter
      }).append(h("<label/>").append(j)),
      f = function() {
        var b = !this.value ? "" : this.value;
        b != e.sSearch &&
          (fa(a, {
            sSearch: b,
            bRegex: e.bRegex,
            bSmart: e.bSmart,
            bCaseInsensitive: e.bCaseInsensitive
          }),
          (a._iDisplayStart = 0),
          N(a));
      },
      g = null !== a.searchDelay ? a.searchDelay : "ssp" === y(a) ? 400 : 0,
      i = h("input", b)
        .val(e.sSearch)
        .attr("placeholder", d.sSearchPlaceholder)
        .on("keyup.DT search.DT input.DT paste.DT cut.DT", g ? Na(f, g) : f)
        .on("keypress.DT", function(a) {
          if (13 == a.keyCode) return !1;
        })
        .attr("aria-controls", c);
    h(a.nTable).on("search.dt.DT", function(b, c) {
      if (a === c)
        try {
          i[0] !== G.activeElement && i.val(e.sSearch);
        } catch (d) {}
    });
    return b[0];
  }
  function fa(a, b, c) {
    var d = a.oPreviousSearch,
      e = a.aoPreSearchCols,
      f = function(a) {
        d.sSearch = a.sSearch;
        d.bRegex = a.bRegex;
        d.bSmart = a.bSmart;
        d.bCaseInsensitive = a.bCaseInsensitive;
      };
    Fa(a);
    if ("ssp" != y(a)) {
      vb(
        a,
        b.sSearch,
        c,
        b.bEscapeRegex !== k ? !b.bEscapeRegex : b.bRegex,
        b.bSmart,
        b.bCaseInsensitive
      );
      f(b);
      for (b = 0; b < e.length; b++)
        wb(
          a,
          e[b].sSearch,
          b,
          e[b].bEscapeRegex !== k ? !e[b].bEscapeRegex : e[b].bRegex,
          e[b].bSmart,
          e[b].bCaseInsensitive
        );
      xb(a);
    } else f(b);
    a.bFiltered = !0;
    r(a, null, "search", [a]);
  }
  function xb(a) {
    for (
      var b = m.ext.search, c = a.aiDisplay, d, e, f = 0, g = b.length;
      f < g;
      f++
    ) {
      for (var j = [], i = 0, n = c.length; i < n; i++)
        (e = c[i]),
          (d = a.aoData[e]),
          b[f](a, d._aFilterData, e, d._aData, i) && j.push(e);
      c.length = 0;
      h.merge(c, j);
    }
  }
  function wb(a, b, c, d, e, f) {
    if ("" !== b) {
      for (
        var g = [], j = a.aiDisplay, d = Oa(b, d, e, f), e = 0;
        e < j.length;
        e++
      )
        (b = a.aoData[j[e]]._aFilterData[c]), d.test(b) && g.push(j[e]);
      a.aiDisplay = g;
    }
  }
  function vb(a, b, c, d, e, f) {
    var d = Oa(b, d, e, f),
      f = a.oPreviousSearch.sSearch,
      g = a.aiDisplayMaster,
      j,
      e = [];
    0 !== m.ext.search.length && (c = !0);
    j = yb(a);
    if (0 >= b.length) a.aiDisplay = g.slice();
    else {
      if (j || c || f.length > b.length || 0 !== b.indexOf(f) || a.bSorted)
        a.aiDisplay = g.slice();
      b = a.aiDisplay;
      for (c = 0; c < b.length; c++)
        d.test(a.aoData[b[c]]._sFilterRow) && e.push(b[c]);
      a.aiDisplay = e;
    }
  }
  function Oa(a, b, c, d) {
    a = b ? a : Pa(a);
    c &&
      (a =
        "^(?=.*?" +
        h
          .map(a.match(/"[^"]+"|[^ ]+/g) || [""], function(a) {
            if ('"' === a.charAt(0))
              var b = a.match(/^"(.*)"$/),
                a = b ? b[1] : a;
            return a.replace('"', "");
          })
          .join(")(?=.*?") +
        ").*$");
    return RegExp(a, d ? "i" : "");
  }
  function yb(a) {
    var b = a.aoColumns,
      c,
      d,
      e,
      f,
      g,
      j,
      i,
      h,
      l = m.ext.type.search;
    c = !1;
    d = 0;
    for (f = a.aoData.length; d < f; d++)
      if (((h = a.aoData[d]), !h._aFilterData)) {
        j = [];
        e = 0;
        for (g = b.length; e < g; e++)
          (c = b[e]),
            c.bSearchable
              ? ((i = B(a, d, e, "filter")),
                l[c.sType] && (i = l[c.sType](i)),
                null === i && (i = ""),
                "string" !== typeof i && i.toString && (i = i.toString()))
              : (i = ""),
            i.indexOf &&
              -1 !== i.indexOf("&") &&
              ((va.innerHTML = i), (i = Wb ? va.textContent : va.innerText)),
            i.replace && (i = i.replace(/[\r\n]/g, "")),
            j.push(i);
        h._aFilterData = j;
        h._sFilterRow = j.join("  ");
        c = !0;
      }
    return c;
  }
  function zb(a) {
    return {
      search: a.sSearch,
      smart: a.bSmart,
      regex: a.bRegex,
      caseInsensitive: a.bCaseInsensitive
    };
  }
  function Ab(a) {
    return {
      sSearch: a.search,
      bSmart: a.smart,
      bRegex: a.regex,
      bCaseInsensitive: a.caseInsensitive
    };
  }
  function rb(a) {
    var b = a.sTableId,
      c = a.aanFeatures.i,
      d = h("<div/>", { class: a.oClasses.sInfo, id: !c ? b + "_info" : null });
    c ||
      (a.aoDrawCallback.push({ fn: Bb, sName: "information" }),
      d.attr("role", "status").attr("aria-live", "polite"),
      h(a.nTable).attr("aria-describedby", b + "_info"));
    return d[0];
  }
  function Bb(a) {
    var b = a.aanFeatures.i;
    if (0 !== b.length) {
      var c = a.oLanguage,
        d = a._iDisplayStart + 1,
        e = a.fnDisplayEnd(),
        f = a.fnRecordsTotal(),
        g = a.fnRecordsDisplay(),
        j = g ? c.sInfo : c.sInfoEmpty;
      g !== f && (j += " " + c.sInfoFiltered);
      j += c.sInfoPostFix;
      j = Cb(a, j);
      c = c.fnInfoCallback;
      null !== c && (j = c.call(a.oInstance, a, d, e, f, g, j));
      h(b).html(j);
    }
  }
  function Cb(a, b) {
    var c = a.fnFormatNumber,
      d = a._iDisplayStart + 1,
      e = a._iDisplayLength,
      f = a.fnRecordsDisplay(),
      g = -1 === e;
    return b
      .replace(/_START_/g, c.call(a, d))
      .replace(/_END_/g, c.call(a, a.fnDisplayEnd()))
      .replace(/_MAX_/g, c.call(a, a.fnRecordsTotal()))
      .replace(/_TOTAL_/g, c.call(a, f))
      .replace(/_PAGE_/g, c.call(a, g ? 1 : Math.ceil(d / e)))
      .replace(/_PAGES_/g, c.call(a, g ? 1 : Math.ceil(f / e)));
  }
  function ga(a) {
    var b,
      c,
      d = a.iInitDisplayStart,
      e = a.aoColumns,
      f;
    c = a.oFeatures;
    var g = a.bDeferLoading;
    if (a.bInitialised) {
      mb(a);
      jb(a);
      ea(a, a.aoHeader);
      ea(a, a.aoFooter);
      C(a, !0);
      c.bAutoWidth && Ea(a);
      b = 0;
      for (c = e.length; b < c; b++)
        (f = e[b]), f.sWidth && (f.nTh.style.width = v(f.sWidth));
      r(a, null, "preInit", [a]);
      S(a);
      e = y(a);
      if ("ssp" != e || g)
        "ajax" == e
          ? sa(
              a,
              [],
              function(c) {
                var f = ta(a, c);
                for (b = 0; b < f.length; b++) M(a, f[b]);
                a.iInitDisplayStart = d;
                S(a);
                C(a, !1);
                ua(a, c);
              },
              a
            )
          : (C(a, !1), ua(a));
    } else
      setTimeout(function() {
        ga(a);
      }, 200);
  }
  function ua(a, b) {
    a._bInitComplete = !0;
    (b || a.oInit.aaData) && Y(a);
    r(a, null, "plugin-init", [a, b]);
    r(a, "aoInitComplete", "init", [a, b]);
  }
  function Qa(a, b) {
    var c = parseInt(b, 10);
    a._iDisplayLength = c;
    Ra(a);
    r(a, null, "length", [a, c]);
  }
  function nb(a) {
    for (
      var b = a.oClasses,
        c = a.sTableId,
        d = a.aLengthMenu,
        e = h.isArray(d[0]),
        f = e ? d[0] : d,
        d = e ? d[1] : d,
        e = h("<select/>", {
          name: c + "_length",
          "aria-controls": c,
          class: b.sLengthSelect
        }),
        g = 0,
        j = f.length;
      g < j;
      g++
    )
      e[0][g] = new Option(
        "number" === typeof d[g] ? a.fnFormatNumber(d[g]) : d[g],
        f[g]
      );
    var i = h("<div><label/></div>").addClass(b.sLength);
    a.aanFeatures.l || (i[0].id = c + "_length");
    i
      .children()
      .append(a.oLanguage.sLengthMenu.replace("_MENU_", e[0].outerHTML));
    h("select", i)
      .val(a._iDisplayLength)
      .on("change.DT", function() {
        Qa(a, h(this).val());
        N(a);
      });
    h(a.nTable).on("length.dt.DT", function(b, c, d) {
      a === c && h("select", i).val(d);
    });
    return i[0];
  }
  function sb(a) {
    var b = a.sPaginationType,
      c = m.ext.pager[b],
      d = "function" === typeof c,
      e = function(a) {
        N(a);
      },
      b = h("<div/>").addClass(a.oClasses.sPaging + b)[0],
      f = a.aanFeatures;
    d || c.fnInit(a, b, e);
    f.p ||
      ((b.id = a.sTableId + "_paginate"),
      a.aoDrawCallback.push({
        fn: function(a) {
          if (d) {
            var b = a._iDisplayStart,
              i = a._iDisplayLength,
              h = a.fnRecordsDisplay(),
              l = -1 === i,
              b = l ? 0 : Math.ceil(b / i),
              i = l ? 1 : Math.ceil(h / i),
              h = c(b, i),
              k,
              l = 0;
            for (k = f.p.length; l < k; l++)
              Ma(a, "pageButton")(a, f.p[l], l, h, b, i);
          } else c.fnUpdate(a, e);
        },
        sName: "pagination"
      }));
    return b;
  }
  function Sa(a, b, c) {
    var d = a._iDisplayStart,
      e = a._iDisplayLength,
      f = a.fnRecordsDisplay();
    0 === f || -1 === e
      ? (d = 0)
      : "number" === typeof b
        ? ((d = b * e), d > f && (d = 0))
        : "first" == b
          ? (d = 0)
          : "previous" == b
            ? ((d = 0 <= e ? d - e : 0), 0 > d && (d = 0))
            : "next" == b
              ? d + e < f && (d += e)
              : "last" == b
                ? (d = Math.floor((f - 1) / e) * e)
                : J(a, 0, "Unknown paging action: " + b, 5);
    b = a._iDisplayStart !== d;
    a._iDisplayStart = d;
    b && (r(a, null, "page", [a]), c && N(a));
    return b;
  }
  function pb(a) {
    return h("<div/>", {
      id: !a.aanFeatures.r ? a.sTableId + "_processing" : null,
      class: a.oClasses.sProcessing
    })
      .html(a.oLanguage.sProcessing)
      .insertBefore(a.nTable)[0];
  }
  function C(a, b) {
    a.oFeatures.bProcessing &&
      h(a.aanFeatures.r).css("display", b ? "block" : "none");
    r(a, null, "processing", [a, b]);
  }
  function qb(a) {
    var b = h(a.nTable);
    b.attr("role", "grid");
    var c = a.oScroll;
    if ("" === c.sX && "" === c.sY) return a.nTable;
    var d = c.sX,
      e = c.sY,
      f = a.oClasses,
      g = b.children("caption"),
      j = g.length ? g[0]._captionSide : null,
      i = h(b[0].cloneNode(!1)),
      n = h(b[0].cloneNode(!1)),
      l = b.children("tfoot");
    l.length || (l = null);
    i = h("<div/>", { class: f.sScrollWrapper })
      .append(
        h("<div/>", { class: f.sScrollHead })
          .css({
            overflow: "hidden",
            position: "relative",
            border: 0,
            width: d ? (!d ? null : v(d)) : "100%"
          })
          .append(
            h("<div/>", { class: f.sScrollHeadInner })
              .css({ "box-sizing": "content-box", width: c.sXInner || "100%" })
              .append(
                i
                  .removeAttr("id")
                  .css("margin-left", 0)
                  .append("top" === j ? g : null)
                  .append(b.children("thead"))
              )
          )
      )
      .append(
        h("<div/>", { class: f.sScrollBody })
          .css({
            position: "relative",
            overflow: "auto",
            width: !d ? null : v(d)
          })
          .append(b)
      );
    l &&
      i.append(
        h("<div/>", { class: f.sScrollFoot })
          .css({
            overflow: "hidden",
            border: 0,
            width: d ? (!d ? null : v(d)) : "100%"
          })
          .append(
            h("<div/>", { class: f.sScrollFootInner }).append(
              n
                .removeAttr("id")
                .css("margin-left", 0)
                .append("bottom" === j ? g : null)
                .append(b.children("tfoot"))
            )
          )
      );
    var b = i.children(),
      k = b[0],
      f = b[1],
      t = l ? b[2] : null;
    if (d)
      h(f).on("scroll.DT", function() {
        var a = this.scrollLeft;
        k.scrollLeft = a;
        l && (t.scrollLeft = a);
      });
    h(f).css(e && c.bCollapse ? "max-height" : "height", e);
    a.nScrollHead = k;
    a.nScrollBody = f;
    a.nScrollFoot = t;
    a.aoDrawCallback.push({ fn: ka, sName: "scrolling" });
    return i[0];
  }
  function ka(a) {
    var b = a.oScroll,
      c = b.sX,
      d = b.sXInner,
      e = b.sY,
      b = b.iBarWidth,
      f = h(a.nScrollHead),
      g = f[0].style,
      j = f.children("div"),
      i = j[0].style,
      n = j.children("table"),
      j = a.nScrollBody,
      l = h(j),
      q = j.style,
      t = h(a.nScrollFoot).children("div"),
      m = t.children("table"),
      o = h(a.nTHead),
      p = h(a.nTable),
      s = p[0],
      r = s.style,
      u = a.nTFoot ? h(a.nTFoot) : null,
      x = a.oBrowser,
      T = x.bScrollOversize,
      Xb = D(a.aoColumns, "nTh"),
      O,
      K,
      P,
      w,
      Ta = [],
      y = [],
      z = [],
      A = [],
      B,
      C = function(a) {
        a = a.style;
        a.paddingTop = "0";
        a.paddingBottom = "0";
        a.borderTopWidth = "0";
        a.borderBottomWidth = "0";
        a.height = 0;
      };
    K = j.scrollHeight > j.clientHeight;
    if (a.scrollBarVis !== K && a.scrollBarVis !== k)
      (a.scrollBarVis = K), Y(a);
    else {
      a.scrollBarVis = K;
      p.children("thead, tfoot").remove();
      u &&
        ((P = u.clone().prependTo(p)), (O = u.find("tr")), (P = P.find("tr")));
      w = o.clone().prependTo(p);
      o = o.find("tr");
      K = w.find("tr");
      w.find("th, td").removeAttr("tabindex");
      c || ((q.width = "100%"), (f[0].style.width = "100%"));
      h.each(ra(a, w), function(b, c) {
        B = Z(a, b);
        c.style.width = a.aoColumns[B].sWidth;
      });
      u &&
        H(function(a) {
          a.style.width = "";
        }, P);
      f = p.outerWidth();
      if ("" === c) {
        r.width = "100%";
        if (
          T &&
          (p.find("tbody").height() > j.offsetHeight ||
            "scroll" == l.css("overflow-y"))
        )
          r.width = v(p.outerWidth() - b);
        f = p.outerWidth();
      } else "" !== d && ((r.width = v(d)), (f = p.outerWidth()));
      H(C, K);
      H(function(a) {
        z.push(a.innerHTML);
        Ta.push(v(h(a).css("width")));
      }, K);
      H(function(a, b) {
        if (h.inArray(a, Xb) !== -1) a.style.width = Ta[b];
      }, o);
      h(K).height(0);
      u &&
        (H(C, P),
        H(function(a) {
          A.push(a.innerHTML);
          y.push(v(h(a).css("width")));
        }, P),
        H(function(a, b) {
          a.style.width = y[b];
        }, O),
        h(P).height(0));
      H(function(a, b) {
        a.innerHTML =
          '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' +
          z[b] +
          "</div>";
        a.style.width = Ta[b];
      }, K);
      u &&
        H(function(a, b) {
          a.innerHTML =
            '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' +
            A[b] +
            "</div>";
          a.style.width = y[b];
        }, P);
      if (p.outerWidth() < f) {
        O =
          j.scrollHeight > j.offsetHeight || "scroll" == l.css("overflow-y")
            ? f + b
            : f;
        if (
          T &&
          (j.scrollHeight > j.offsetHeight || "scroll" == l.css("overflow-y"))
        )
          r.width = v(O - b);
        ("" === c || "" !== d) && J(a, 1, "Possible column misalignment", 6);
      } else O = "100%";
      q.width = v(O);
      g.width = v(O);
      u && (a.nScrollFoot.style.width = v(O));
      !e && T && (q.height = v(s.offsetHeight + b));
      c = p.outerWidth();
      n[0].style.width = v(c);
      i.width = v(c);
      d = p.height() > j.clientHeight || "scroll" == l.css("overflow-y");
      e = "padding" + (x.bScrollbarLeft ? "Left" : "Right");
      i[e] = d ? b + "px" : "0px";
      u &&
        ((m[0].style.width = v(c)),
        (t[0].style.width = v(c)),
        (t[0].style[e] = d ? b + "px" : "0px"));
      p.children("colgroup").insertBefore(p.children("thead"));
      l.scroll();
      if ((a.bSorted || a.bFiltered) && !a._drawHold) j.scrollTop = 0;
    }
  }
  function H(a, b, c) {
    for (var d = 0, e = 0, f = b.length, g, j; e < f; ) {
      g = b[e].firstChild;
      for (j = c ? c[e].firstChild : null; g; )
        1 === g.nodeType && (c ? a(g, j, d) : a(g, d), d++),
          (g = g.nextSibling),
          (j = c ? j.nextSibling : null);
      e++;
    }
  }
  function Ea(a) {
    var b = a.nTable,
      c = a.aoColumns,
      d = a.oScroll,
      e = d.sY,
      f = d.sX,
      g = d.sXInner,
      j = c.length,
      i = la(a, "bVisible"),
      n = h("th", a.nTHead),
      l = b.getAttribute("width"),
      k = b.parentNode,
      t = !1,
      m,
      o,
      p = a.oBrowser,
      d = p.bScrollOversize;
    (m = b.style.width) && -1 !== m.indexOf("%") && (l = m);
    for (m = 0; m < i.length; m++)
      (o = c[i[m]]),
        null !== o.sWidth && ((o.sWidth = Db(o.sWidthOrig, k)), (t = !0));
    if (d || (!t && !f && !e && j == aa(a) && j == n.length))
      for (m = 0; m < j; m++)
        (i = Z(a, m)), null !== i && (c[i].sWidth = v(n.eq(m).width()));
    else {
      j = h(b)
        .clone()
        .css("visibility", "hidden")
        .removeAttr("id");
      j.find("tbody tr").remove();
      var s = h("<tr/>").appendTo(j.find("tbody"));
      j.find("thead, tfoot").remove();
      j.append(h(a.nTHead).clone()).append(h(a.nTFoot).clone());
      j.find("tfoot th, tfoot td").css("width", "");
      n = ra(a, j.find("thead")[0]);
      for (m = 0; m < i.length; m++)
        (o = c[i[m]]),
          (n[m].style.width =
            null !== o.sWidthOrig && "" !== o.sWidthOrig
              ? v(o.sWidthOrig)
              : ""),
          o.sWidthOrig &&
            f &&
            h(n[m]).append(
              h("<div/>").css({
                width: o.sWidthOrig,
                margin: 0,
                padding: 0,
                border: 0,
                height: 1
              })
            );
      if (a.aoData.length)
        for (m = 0; m < i.length; m++)
          (t = i[m]),
            (o = c[t]),
            h(Eb(a, t))
              .clone(!1)
              .append(o.sContentPadding)
              .appendTo(s);
      h("[name]", j).removeAttr("name");
      o = h("<div/>")
        .css(
          f || e
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                height: 1,
                right: 0,
                overflow: "hidden"
              }
            : {}
        )
        .append(j)
        .appendTo(k);
      f && g
        ? j.width(g)
        : f
          ? (j.css("width", "auto"),
            j.removeAttr("width"),
            j.width() < k.clientWidth && l && j.width(k.clientWidth))
          : e ? j.width(k.clientWidth) : l && j.width(l);
      for (m = e = 0; m < i.length; m++)
        (k = h(n[m])),
          (g = k.outerWidth() - k.width()),
          (k = p.bBounding
            ? Math.ceil(n[m].getBoundingClientRect().width)
            : k.outerWidth()),
          (e += k),
          (c[i[m]].sWidth = v(k - g));
      b.style.width = v(e);
      o.remove();
    }
    l && (b.style.width = v(l));
    if ((l || f) && !a._reszEvt)
      (b = function() {
        h(E).on(
          "resize.DT-" + a.sInstance,
          Na(function() {
            Y(a);
          })
        );
      }),
        d ? setTimeout(b, 1e3) : b(),
        (a._reszEvt = !0);
  }
  function Db(a, b) {
    if (!a) return 0;
    var c = h("<div/>")
        .css("width", v(a))
        .appendTo(b || G.body),
      d = c[0].offsetWidth;
    c.remove();
    return d;
  }
  function Eb(a, b) {
    var c = Fb(a, b);
    if (0 > c) return null;
    var d = a.aoData[c];
    return !d.nTr ? h("<td/>").html(B(a, c, b, "display"))[0] : d.anCells[b];
  }
  function Fb(a, b) {
    for (var c, d = -1, e = -1, f = 0, g = a.aoData.length; f < g; f++)
      (c = B(a, f, b, "display") + ""),
        (c = c.replace(Yb, "")),
        (c = c.replace(/&nbsp;/g, " ")),
        c.length > d && ((d = c.length), (e = f));
    return e;
  }
  function v(a) {
    return null === a
      ? "0px"
      : "number" == typeof a
        ? 0 > a ? "0px" : a + "px"
        : a.match(/\d$/) ? a + "px" : a;
  }
  function V(a) {
    var b,
      c,
      d = [],
      e = a.aoColumns,
      f,
      g,
      j,
      i;
    b = a.aaSortingFixed;
    c = h.isPlainObject(b);
    var n = [];
    f = function(a) {
      a.length && !h.isArray(a[0]) ? n.push(a) : h.merge(n, a);
    };
    h.isArray(b) && f(b);
    c && b.pre && f(b.pre);
    f(a.aaSorting);
    c && b.post && f(b.post);
    for (a = 0; a < n.length; a++) {
      i = n[a][0];
      f = e[i].aDataSort;
      b = 0;
      for (c = f.length; b < c; b++)
        (g = f[b]),
          (j = e[g].sType || "string"),
          n[a]._idx === k && (n[a]._idx = h.inArray(n[a][1], e[g].asSorting)),
          d.push({
            src: i,
            col: g,
            dir: n[a][1],
            index: n[a]._idx,
            type: j,
            formatter: m.ext.type.order[j + "-pre"]
          });
    }
    return d;
  }
  function lb(a) {
    var b,
      c,
      d = [],
      e = m.ext.type.order,
      f = a.aoData,
      g = 0,
      j,
      i = a.aiDisplayMaster,
      h;
    Fa(a);
    h = V(a);
    b = 0;
    for (c = h.length; b < c; b++) (j = h[b]), j.formatter && g++, Gb(a, j.col);
    if ("ssp" != y(a) && 0 !== h.length) {
      b = 0;
      for (c = i.length; b < c; b++) d[i[b]] = b;
      g === h.length
        ? i.sort(function(a, b) {
            var c,
              e,
              g,
              j,
              i = h.length,
              k = f[a]._aSortData,
              m = f[b]._aSortData;
            for (g = 0; g < i; g++)
              if (
                ((j = h[g]),
                (c = k[j.col]),
                (e = m[j.col]),
                (c = c < e ? -1 : c > e ? 1 : 0),
                0 !== c)
              )
                return "asc" === j.dir ? c : -c;
            c = d[a];
            e = d[b];
            return c < e ? -1 : c > e ? 1 : 0;
          })
        : i.sort(function(a, b) {
            var c,
              g,
              j,
              i,
              k = h.length,
              m = f[a]._aSortData,
              o = f[b]._aSortData;
            for (j = 0; j < k; j++)
              if (
                ((i = h[j]),
                (c = m[i.col]),
                (g = o[i.col]),
                (i = e[i.type + "-" + i.dir] || e["string-" + i.dir]),
                (c = i(c, g)),
                0 !== c)
              )
                return c;
            c = d[a];
            g = d[b];
            return c < g ? -1 : c > g ? 1 : 0;
          });
    }
    a.bSorted = !0;
  }
  function Hb(a) {
    for (
      var b,
        c,
        d = a.aoColumns,
        e = V(a),
        a = a.oLanguage.oAria,
        f = 0,
        g = d.length;
      f < g;
      f++
    ) {
      c = d[f];
      var j = c.asSorting;
      b = c.sTitle.replace(/<.*?>/g, "");
      var i = c.nTh;
      i.removeAttribute("aria-sort");
      c.bSortable &&
        (0 < e.length && e[0].col == f
          ? (i.setAttribute(
              "aria-sort",
              "asc" == e[0].dir ? "ascending" : "descending"
            ),
            (c = j[e[0].index + 1] || j[0]))
          : (c = j[0]),
        (b += "asc" === c ? a.sSortAscending : a.sSortDescending));
      i.setAttribute("aria-label", b);
    }
  }
  function Ua(a, b, c, d) {
    var e = a.aaSorting,
      f = a.aoColumns[b].asSorting,
      g = function(a, b) {
        var c = a._idx;
        c === k && (c = h.inArray(a[1], f));
        return c + 1 < f.length ? c + 1 : b ? null : 0;
      };
    "number" === typeof e[0] && (e = a.aaSorting = [e]);
    c && a.oFeatures.bSortMulti
      ? ((c = h.inArray(b, D(e, "0"))),
        -1 !== c
          ? ((b = g(e[c], !0)),
            null === b && 1 === e.length && (b = 0),
            null === b ? e.splice(c, 1) : ((e[c][1] = f[b]), (e[c]._idx = b)))
          : (e.push([b, f[0], 0]), (e[e.length - 1]._idx = 0)))
      : e.length && e[0][0] == b
        ? ((b = g(e[0])), (e.length = 1), (e[0][1] = f[b]), (e[0]._idx = b))
        : ((e.length = 0), e.push([b, f[0]]), (e[0]._idx = 0));
    S(a);
    "function" == typeof d && d(a);
  }
  function La(a, b, c, d) {
    var e = a.aoColumns[c];
    Va(b, {}, function(b) {
      !1 !== e.bSortable &&
        (a.oFeatures.bProcessing
          ? (C(a, !0),
            setTimeout(function() {
              Ua(a, c, b.shiftKey, d);
              "ssp" !== y(a) && C(a, !1);
            }, 0))
          : Ua(a, c, b.shiftKey, d));
    });
  }
  function wa(a) {
    var b = a.aLastSort,
      c = a.oClasses.sSortColumn,
      d = V(a),
      e = a.oFeatures,
      f,
      g;
    if (e.bSort && e.bSortClasses) {
      e = 0;
      for (f = b.length; e < f; e++)
        (g = b[e].src),
          h(D(a.aoData, "anCells", g)).removeClass(c + (2 > e ? e + 1 : 3));
      e = 0;
      for (f = d.length; e < f; e++)
        (g = d[e].src),
          h(D(a.aoData, "anCells", g)).addClass(c + (2 > e ? e + 1 : 3));
    }
    a.aLastSort = d;
  }
  function Gb(a, b) {
    var c = a.aoColumns[b],
      d = m.ext.order[c.sSortDataType],
      e;
    d && (e = d.call(a.oInstance, a, b, $(a, b)));
    for (
      var f, g = m.ext.type.order[c.sType + "-pre"], j = 0, i = a.aoData.length;
      j < i;
      j++
    )
      if (
        ((c = a.aoData[j]),
        c._aSortData || (c._aSortData = []),
        !c._aSortData[b] || d)
      )
        (f = d ? e[j] : B(a, j, b, "sort")), (c._aSortData[b] = g ? g(f) : f);
  }
  function xa(a) {
    if (a.oFeatures.bStateSave && !a.bDestroying) {
      var b = {
        time: +new Date(),
        start: a._iDisplayStart,
        length: a._iDisplayLength,
        order: h.extend(!0, [], a.aaSorting),
        search: zb(a.oPreviousSearch),
        columns: h.map(a.aoColumns, function(b, d) {
          return { visible: b.bVisible, search: zb(a.aoPreSearchCols[d]) };
        })
      };
      r(a, "aoStateSaveParams", "stateSaveParams", [a, b]);
      a.oSavedState = b;
      a.fnStateSaveCallback.call(a.oInstance, a, b);
    }
  }
  function Ib(a, b, c) {
    var d,
      e,
      f = a.aoColumns,
      b = function(b) {
        if (b && b.time) {
          var g = r(a, "aoStateLoadParams", "stateLoadParams", [a, b]);
          if (
            -1 === h.inArray(!1, g) &&
            ((g = a.iStateDuration),
            !(0 < g && b.time < +new Date() - 1e3 * g) &&
              !(b.columns && f.length !== b.columns.length))
          ) {
            a.oLoadedState = h.extend(!0, {}, b);
            b.start !== k &&
              ((a._iDisplayStart = b.start), (a.iInitDisplayStart = b.start));
            b.length !== k && (a._iDisplayLength = b.length);
            b.order !== k &&
              ((a.aaSorting = []),
              h.each(b.order, function(b, c) {
                a.aaSorting.push(c[0] >= f.length ? [0, c[1]] : c);
              }));
            b.search !== k && h.extend(a.oPreviousSearch, Ab(b.search));
            if (b.columns) {
              d = 0;
              for (e = b.columns.length; d < e; d++)
                (g = b.columns[d]),
                  g.visible !== k && (f[d].bVisible = g.visible),
                  g.search !== k &&
                    h.extend(a.aoPreSearchCols[d], Ab(g.search));
            }
            r(a, "aoStateLoaded", "stateLoaded", [a, b]);
          }
        }
        c();
      };
    if (a.oFeatures.bStateSave) {
      var g = a.fnStateLoadCallback.call(a.oInstance, a, b);
      g !== k && b(g);
    } else c();
  }
  function ya(a) {
    var b = m.settings,
      a = h.inArray(a, D(b, "nTable"));
    return -1 !== a ? b[a] : null;
  }
  function J(a, b, c, d) {
    c =
      "DataTables warning: " + (a ? "table id=" + a.sTableId + " - " : "") + c;
    d &&
      (c +=
        ". For more information about this error, please see http://datatables.net/tn/" +
        d);
    if (b) E.console && console.log && console.log(c);
    else if (
      ((b = m.ext),
      (b = b.sErrMode || b.errMode),
      a && r(a, null, "error", [a, d, c]),
      "alert" == b)
    )
      alert(c);
    else {
      if ("throw" == b) throw Error(c);
      "function" == typeof b && b(a, d, c);
    }
  }
  function F(a, b, c, d) {
    h.isArray(c)
      ? h.each(c, function(c, d) {
          h.isArray(d) ? F(a, b, d[0], d[1]) : F(a, b, d);
        })
      : (d === k && (d = c), b[c] !== k && (a[d] = b[c]));
  }
  function Jb(a, b, c) {
    var d, e;
    for (e in b)
      b.hasOwnProperty(e) &&
        ((d = b[e]),
        h.isPlainObject(d)
          ? (h.isPlainObject(a[e]) || (a[e] = {}), h.extend(!0, a[e], d))
          : (a[e] =
              c && "data" !== e && "aaData" !== e && h.isArray(d)
                ? d.slice()
                : d));
    return a;
  }
  function Va(a, b, c) {
    h(a)
      .on("click.DT", b, function(b) {
        a.blur();
        c(b);
      })
      .on("keypress.DT", b, function(a) {
        13 === a.which && (a.preventDefault(), c(a));
      })
      .on("selectstart.DT", function() {
        return !1;
      });
  }
  function z(a, b, c, d) {
    c && a[b].push({ fn: c, sName: d });
  }
  function r(a, b, c, d) {
    var e = [];
    b &&
      (e = h.map(a[b].slice().reverse(), function(b) {
        return b.fn.apply(a.oInstance, d);
      }));
    null !== c &&
      ((b = h.Event(c + ".dt")), h(a.nTable).trigger(b, d), e.push(b.result));
    return e;
  }
  function Ra(a) {
    var b = a._iDisplayStart,
      c = a.fnDisplayEnd(),
      d = a._iDisplayLength;
    b >= c && (b = c - d);
    b -= b % d;
    if (-1 === d || 0 > b) b = 0;
    a._iDisplayStart = b;
  }
  function Ma(a, b) {
    var c = a.renderer,
      d = m.ext.renderer[b];
    return h.isPlainObject(c) && c[b]
      ? d[c[b]] || d._
      : "string" === typeof c ? d[c] || d._ : d._;
  }
  function y(a) {
    return a.oFeatures.bServerSide
      ? "ssp"
      : a.ajax || a.sAjaxSource ? "ajax" : "dom";
  }
  function ha(a, b) {
    var c = [],
      c = Kb.numbers_length,
      d = Math.floor(c / 2);
    b <= c
      ? (c = W(0, b))
      : a <= d
        ? ((c = W(0, c - 2)), c.push("ellipsis"), c.push(b - 1))
        : (a >= b - 1 - d
            ? (c = W(b - (c - 2), b))
            : ((c = W(a - d + 2, a + d - 1)),
              c.push("ellipsis"),
              c.push(b - 1)),
          c.splice(0, 0, "ellipsis"),
          c.splice(0, 0, 0));
    c.DT_el = "span";
    return c;
  }
  function cb(a) {
    h.each(
      {
        num: function(b) {
          return za(b, a);
        },
        "num-fmt": function(b) {
          return za(b, a, Wa);
        },
        "html-num": function(b) {
          return za(b, a, Aa);
        },
        "html-num-fmt": function(b) {
          return za(b, a, Aa, Wa);
        }
      },
      function(b, c) {
        x.type.order[b + a + "-pre"] = c;
        b.match(/^html\-/) && (x.type.search[b + a] = x.type.search.html);
      }
    );
  }
  function Lb(a) {
    return function() {
      var b = [ya(this[m.ext.iApiIndex])].concat(
        Array.prototype.slice.call(arguments)
      );
      return m.ext.internal[a].apply(this, b);
    };
  }
  var m = function(a) {
      this.$ = function(a, b) {
        return this.api(!0).$(a, b);
      };
      this._ = function(a, b) {
        return this.api(!0)
          .rows(a, b)
          .data();
      };
      this.api = function(a) {
        return a ? new s(ya(this[x.iApiIndex])) : new s(this);
      };
      this.fnAddData = function(a, b) {
        var c = this.api(!0),
          d =
            h.isArray(a) && (h.isArray(a[0]) || h.isPlainObject(a[0]))
              ? c.rows.add(a)
              : c.row.add(a);
        (b === k || b) && c.draw();
        return d.flatten().toArray();
      };
      this.fnAdjustColumnSizing = function(a) {
        var b = this.api(!0).columns.adjust(),
          c = b.settings()[0],
          d = c.oScroll;
        a === k || a ? b.draw(!1) : ("" !== d.sX || "" !== d.sY) && ka(c);
      };
      this.fnClearTable = function(a) {
        var b = this.api(!0).clear();
        (a === k || a) && b.draw();
      };
      this.fnClose = function(a) {
        this.api(!0)
          .row(a)
          .child.hide();
      };
      this.fnDeleteRow = function(a, b, c) {
        var d = this.api(!0),
          a = d.rows(a),
          e = a.settings()[0],
          h = e.aoData[a[0][0]];
        a.remove();
        b && b.call(this, e, h);
        (c === k || c) && d.draw();
        return h;
      };
      this.fnDestroy = function(a) {
        this.api(!0).destroy(a);
      };
      this.fnDraw = function(a) {
        this.api(!0).draw(a);
      };
      this.fnFilter = function(a, b, c, d, e, h) {
        e = this.api(!0);
        null === b || b === k
          ? e.search(a, c, d, h)
          : e.column(b).search(a, c, d, h);
        e.draw();
      };
      this.fnGetData = function(a, b) {
        var c = this.api(!0);
        if (a !== k) {
          var d = a.nodeName ? a.nodeName.toLowerCase() : "";
          return b !== k || "td" == d || "th" == d
            ? c.cell(a, b).data()
            : c.row(a).data() || null;
        }
        return c.data().toArray();
      };
      this.fnGetNodes = function(a) {
        var b = this.api(!0);
        return a !== k
          ? b.row(a).node()
          : b
              .rows()
              .nodes()
              .flatten()
              .toArray();
      };
      this.fnGetPosition = function(a) {
        var b = this.api(!0),
          c = a.nodeName.toUpperCase();
        return "TR" == c
          ? b.row(a).index()
          : "TD" == c || "TH" == c
            ? ((a = b.cell(a).index()), [a.row, a.columnVisible, a.column])
            : null;
      };
      this.fnIsOpen = function(a) {
        return this.api(!0)
          .row(a)
          .child.isShown();
      };
      this.fnOpen = function(a, b, c) {
        return this.api(!0)
          .row(a)
          .child(b, c)
          .show()
          .child()[0];
      };
      this.fnPageChange = function(a, b) {
        var c = this.api(!0).page(a);
        (b === k || b) && c.draw(!1);
      };
      this.fnSetColumnVis = function(a, b, c) {
        a = this.api(!0)
          .column(a)
          .visible(b);
        (c === k || c) && a.columns.adjust().draw();
      };
      this.fnSettings = function() {
        return ya(this[x.iApiIndex]);
      };
      this.fnSort = function(a) {
        this.api(!0)
          .order(a)
          .draw();
      };
      this.fnSortListener = function(a, b, c) {
        this.api(!0).order.listener(a, b, c);
      };
      this.fnUpdate = function(a, b, c, d, e) {
        var h = this.api(!0);
        c === k || null === c ? h.row(b).data(a) : h.cell(b, c).data(a);
        (e === k || e) && h.columns.adjust();
        (d === k || d) && h.draw();
        return 0;
      };
      this.fnVersionCheck = x.fnVersionCheck;
      var b = this,
        c = a === k,
        d = this.length;
      c && (a = {});
      this.oApi = this.internal = x.internal;
      for (var e in m.ext.internal) e && (this[e] = Lb(e));
      this.each(function() {
        var e = {},
          g = 1 < d ? Jb(e, a, !0) : a,
          j = 0,
          i,
          e = this.getAttribute("id"),
          n = !1,
          l = m.defaults,
          q = h(this);
        if ("table" != this.nodeName.toLowerCase())
          J(
            null,
            0,
            "Non-table node initialisation (" + this.nodeName + ")",
            2
          );
        else {
          db(l);
          eb(l.column);
          I(l, l, !0);
          I(l.column, l.column, !0);
          I(l, h.extend(g, q.data()));
          var t = m.settings,
            j = 0;
          for (i = t.length; j < i; j++) {
            var o = t[j];
            if (
              o.nTable == this ||
              o.nTHead.parentNode == this ||
              (o.nTFoot && o.nTFoot.parentNode == this)
            ) {
              var s = g.bRetrieve !== k ? g.bRetrieve : l.bRetrieve;
              if (c || s) return o.oInstance;
              if (g.bDestroy !== k ? g.bDestroy : l.bDestroy) {
                o.oInstance.fnDestroy();
                break;
              } else {
                J(o, 0, "Cannot reinitialise DataTable", 3);
                return;
              }
            }
            if (o.sTableId == this.id) {
              t.splice(j, 1);
              break;
            }
          }
          if (null === e || "" === e)
            this.id = e = "DataTables_Table_" + m.ext._unique++;
          var p = h.extend(!0, {}, m.models.oSettings, {
            sDestroyWidth: q[0].style.width,
            sInstance: e,
            sTableId: e
          });
          p.nTable = this;
          p.oApi = b.internal;
          p.oInit = g;
          t.push(p);
          p.oInstance = 1 === b.length ? b : q.dataTable();
          db(g);
          g.oLanguage && Ca(g.oLanguage);
          g.aLengthMenu &&
            !g.iDisplayLength &&
            (g.iDisplayLength = h.isArray(g.aLengthMenu[0])
              ? g.aLengthMenu[0][0]
              : g.aLengthMenu[0]);
          g = Jb(h.extend(!0, {}, l), g);
          F(
            p.oFeatures,
            g,
            "bPaginate bLengthChange bFilter bSort bSortMulti bInfo bProcessing bAutoWidth bSortClasses bServerSide bDeferRender".split(
              " "
            )
          );
          F(p, g, [
            "asStripeClasses",
            "ajax",
            "fnServerData",
            "fnFormatNumber",
            "sServerMethod",
            "aaSorting",
            "aaSortingFixed",
            "aLengthMenu",
            "sPaginationType",
            "sAjaxSource",
            "sAjaxDataProp",
            "iStateDuration",
            "sDom",
            "bSortCellsTop",
            "iTabIndex",
            "fnStateLoadCallback",
            "fnStateSaveCallback",
            "renderer",
            "searchDelay",
            "rowId",
            ["iCookieDuration", "iStateDuration"],
            ["oSearch", "oPreviousSearch"],
            ["aoSearchCols", "aoPreSearchCols"],
            ["iDisplayLength", "_iDisplayLength"]
          ]);
          F(p.oScroll, g, [
            ["sScrollX", "sX"],
            ["sScrollXInner", "sXInner"],
            ["sScrollY", "sY"],
            ["bScrollCollapse", "bCollapse"]
          ]);
          F(p.oLanguage, g, "fnInfoCallback");
          z(p, "aoDrawCallback", g.fnDrawCallback, "user");
          z(p, "aoServerParams", g.fnServerParams, "user");
          z(p, "aoStateSaveParams", g.fnStateSaveParams, "user");
          z(p, "aoStateLoadParams", g.fnStateLoadParams, "user");
          z(p, "aoStateLoaded", g.fnStateLoaded, "user");
          z(p, "aoRowCallback", g.fnRowCallback, "user");
          z(p, "aoRowCreatedCallback", g.fnCreatedRow, "user");
          z(p, "aoHeaderCallback", g.fnHeaderCallback, "user");
          z(p, "aoFooterCallback", g.fnFooterCallback, "user");
          z(p, "aoInitComplete", g.fnInitComplete, "user");
          z(p, "aoPreDrawCallback", g.fnPreDrawCallback, "user");
          p.rowIdFn = Q(g.rowId);
          fb(p);
          var u = p.oClasses;
          h.extend(u, m.ext.classes, g.oClasses);
          q.addClass(u.sTable);
          p.iInitDisplayStart === k &&
            ((p.iInitDisplayStart = g.iDisplayStart),
            (p._iDisplayStart = g.iDisplayStart));
          null !== g.iDeferLoading &&
            ((p.bDeferLoading = !0),
            (e = h.isArray(g.iDeferLoading)),
            (p._iRecordsDisplay = e ? g.iDeferLoading[0] : g.iDeferLoading),
            (p._iRecordsTotal = e ? g.iDeferLoading[1] : g.iDeferLoading));
          var v = p.oLanguage;
          h.extend(!0, v, g.oLanguage);
          v.sUrl &&
            (h.ajax({
              dataType: "json",
              url: v.sUrl,
              success: function(a) {
                Ca(a);
                I(l.oLanguage, a);
                h.extend(true, v, a);
                ga(p);
              },
              error: function() {
                ga(p);
              }
            }),
            (n = !0));
          null === g.asStripeClasses &&
            (p.asStripeClasses = [u.sStripeOdd, u.sStripeEven]);
          var e = p.asStripeClasses,
            x = q
              .children("tbody")
              .find("tr")
              .eq(0);
          -1 !==
            h.inArray(
              !0,
              h.map(e, function(a) {
                return x.hasClass(a);
              })
            ) &&
            (h("tbody tr", this).removeClass(e.join(" ")),
            (p.asDestroyStripes = e.slice()));
          e = [];
          t = this.getElementsByTagName("thead");
          0 !== t.length && (da(p.aoHeader, t[0]), (e = ra(p)));
          if (null === g.aoColumns) {
            t = [];
            j = 0;
            for (i = e.length; j < i; j++) t.push(null);
          } else t = g.aoColumns;
          j = 0;
          for (i = t.length; j < i; j++) Da(p, e ? e[j] : null);
          hb(p, g.aoColumnDefs, t, function(a, b) {
            ja(p, a, b);
          });
          if (x.length) {
            var w = function(a, b) {
              return a.getAttribute("data-" + b) !== null ? b : null;
            };
            h(x[0])
              .children("th, td")
              .each(function(a, b) {
                var c = p.aoColumns[a];
                if (c.mData === a) {
                  var d = w(b, "sort") || w(b, "order"),
                    e = w(b, "filter") || w(b, "search");
                  if (d !== null || e !== null) {
                    c.mData = {
                      _: a + ".display",
                      sort: d !== null ? a + ".@data-" + d : k,
                      type: d !== null ? a + ".@data-" + d : k,
                      filter: e !== null ? a + ".@data-" + e : k
                    };
                    ja(p, a);
                  }
                }
              });
          }
          var T = p.oFeatures,
            e = function() {
              if (g.aaSorting === k) {
                var a = p.aaSorting;
                j = 0;
                for (i = a.length; j < i; j++)
                  a[j][1] = p.aoColumns[j].asSorting[0];
              }
              wa(p);
              T.bSort &&
                z(p, "aoDrawCallback", function() {
                  if (p.bSorted) {
                    var a = V(p),
                      b = {};
                    h.each(a, function(a, c) {
                      b[c.src] = c.dir;
                    });
                    r(p, null, "order", [p, a, b]);
                    Hb(p);
                  }
                });
              z(
                p,
                "aoDrawCallback",
                function() {
                  (p.bSorted || y(p) === "ssp" || T.bDeferRender) && wa(p);
                },
                "sc"
              );
              var a = q.children("caption").each(function() {
                  this._captionSide = h(this).css("caption-side");
                }),
                b = q.children("thead");
              b.length === 0 && (b = h("<thead/>").appendTo(q));
              p.nTHead = b[0];
              b = q.children("tbody");
              b.length === 0 && (b = h("<tbody/>").appendTo(q));
              p.nTBody = b[0];
              b = q.children("tfoot");
              if (
                b.length === 0 &&
                a.length > 0 &&
                (p.oScroll.sX !== "" || p.oScroll.sY !== "")
              )
                b = h("<tfoot/>").appendTo(q);
              if (b.length === 0 || b.children().length === 0)
                q.addClass(u.sNoFooter);
              else if (b.length > 0) {
                p.nTFoot = b[0];
                da(p.aoFooter, p.nTFoot);
              }
              if (g.aaData)
                for (j = 0; j < g.aaData.length; j++) M(p, g.aaData[j]);
              else
                (p.bDeferLoading || y(p) == "dom") &&
                  ma(p, h(p.nTBody).children("tr"));
              p.aiDisplay = p.aiDisplayMaster.slice();
              p.bInitialised = true;
              n === false && ga(p);
            };
          g.bStateSave
            ? ((T.bStateSave = !0),
              z(p, "aoDrawCallback", xa, "state_save"),
              Ib(p, g, e))
            : e();
        }
      });
      b = null;
      return this;
    },
    x,
    s,
    o,
    u,
    Xa = {},
    Mb = /[\r\n]/g,
    Aa = /<.*?>/g,
    Zb = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/,
    $b = RegExp(
      "(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\|\\$|\\^|\\-)",
      "g"
    ),
    Wa = /[',$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi,
    L = function(a) {
      return !a || !0 === a || "-" === a ? !0 : !1;
    },
    Nb = function(a) {
      var b = parseInt(a, 10);
      return !isNaN(b) && isFinite(a) ? b : null;
    },
    Ob = function(a, b) {
      Xa[b] || (Xa[b] = RegExp(Pa(b), "g"));
      return "string" === typeof a && "." !== b
        ? a.replace(/\./g, "").replace(Xa[b], ".")
        : a;
    },
    Ya = function(a, b, c) {
      var d = "string" === typeof a;
      if (L(a)) return !0;
      b && d && (a = Ob(a, b));
      c && d && (a = a.replace(Wa, ""));
      return !isNaN(parseFloat(a)) && isFinite(a);
    },
    Pb = function(a, b, c) {
      return L(a)
        ? !0
        : !(L(a) || "string" === typeof a)
          ? null
          : Ya(a.replace(Aa, ""), b, c) ? !0 : null;
    },
    D = function(a, b, c) {
      var d = [],
        e = 0,
        f = a.length;
      if (c !== k) for (; e < f; e++) a[e] && a[e][b] && d.push(a[e][b][c]);
      else for (; e < f; e++) a[e] && d.push(a[e][b]);
      return d;
    },
    ia = function(a, b, c, d) {
      var e = [],
        f = 0,
        g = b.length;
      if (d !== k) for (; f < g; f++) a[b[f]][c] && e.push(a[b[f]][c][d]);
      else for (; f < g; f++) e.push(a[b[f]][c]);
      return e;
    },
    W = function(a, b) {
      var c = [],
        d;
      b === k ? ((b = 0), (d = a)) : ((d = b), (b = a));
      for (var e = b; e < d; e++) c.push(e);
      return c;
    },
    Qb = function(a) {
      for (var b = [], c = 0, d = a.length; c < d; c++) a[c] && b.push(a[c]);
      return b;
    },
    qa = function(a) {
      var b;
      a: {
        if (!(2 > a.length)) {
          b = a.slice().sort();
          for (var c = b[0], d = 1, e = b.length; d < e; d++) {
            if (b[d] === c) {
              b = !1;
              break a;
            }
            c = b[d];
          }
        }
        b = !0;
      }
      if (b) return a.slice();
      b = [];
      var e = a.length,
        f,
        g = 0,
        d = 0;
      a: for (; d < e; d++) {
        c = a[d];
        for (f = 0; f < g; f++) if (b[f] === c) continue a;
        b.push(c);
        g++;
      }
      return b;
    };
  m.util = {
    throttle: function(a, b) {
      var c = b !== k ? b : 200,
        d,
        e;
      return function() {
        var b = this,
          g = +new Date(),
          j = arguments;
        d && g < d + c
          ? (clearTimeout(e),
            (e = setTimeout(function() {
              d = k;
              a.apply(b, j);
            }, c)))
          : ((d = g), a.apply(b, j));
      };
    },
    escapeRegex: function(a) {
      return a.replace($b, "\\$1");
    }
  };
  var A = function(a, b, c) {
      a[b] !== k && (a[c] = a[b]);
    },
    ba = /\[.*?\]$/,
    U = /\(\)$/,
    Pa = m.util.escapeRegex,
    va = h("<div>")[0],
    Wb = va.textContent !== k,
    Yb = /<.*?>/g,
    Na = m.util.throttle,
    Rb = [],
    w = Array.prototype,
    ac = function(a) {
      var b,
        c,
        d = m.settings,
        e = h.map(d, function(a) {
          return a.nTable;
        });
      if (a) {
        if (a.nTable && a.oApi) return [a];
        if (a.nodeName && "table" === a.nodeName.toLowerCase())
          return (b = h.inArray(a, e)), -1 !== b ? [d[b]] : null;
        if (a && "function" === typeof a.settings)
          return a.settings().toArray();
        "string" === typeof a ? (c = h(a)) : a instanceof h && (c = a);
      } else return [];
      if (c)
        return c
          .map(function() {
            b = h.inArray(this, e);
            return -1 !== b ? d[b] : null;
          })
          .toArray();
    };
  s = function(a, b) {
    if (!(this instanceof s)) return new s(a, b);
    var c = [],
      d = function(a) {
        (a = ac(a)) && (c = c.concat(a));
      };
    if (h.isArray(a)) for (var e = 0, f = a.length; e < f; e++) d(a[e]);
    else d(a);
    this.context = qa(c);
    b && h.merge(this, b);
    this.selector = { rows: null, cols: null, opts: null };
    s.extend(this, this, Rb);
  };
  m.Api = s;
  h.extend(s.prototype, {
    any: function() {
      return 0 !== this.count();
    },
    concat: w.concat,
    context: [],
    count: function() {
      return this.flatten().length;
    },
    each: function(a) {
      for (var b = 0, c = this.length; b < c; b++)
        a.call(this, this[b], b, this);
      return this;
    },
    eq: function(a) {
      var b = this.context;
      return b.length > a ? new s(b[a], this[a]) : null;
    },
    filter: function(a) {
      var b = [];
      if (w.filter) b = w.filter.call(this, a, this);
      else
        for (var c = 0, d = this.length; c < d; c++)
          a.call(this, this[c], c, this) && b.push(this[c]);
      return new s(this.context, b);
    },
    flatten: function() {
      var a = [];
      return new s(this.context, a.concat.apply(a, this.toArray()));
    },
    join: w.join,
    indexOf:
      w.indexOf ||
      function(a, b) {
        for (var c = b || 0, d = this.length; c < d; c++)
          if (this[c] === a) return c;
        return -1;
      },
    iterator: function(a, b, c, d) {
      var e = [],
        f,
        g,
        j,
        h,
        n,
        l = this.context,
        m,
        o,
        u = this.selector;
      "string" === typeof a && ((d = c), (c = b), (b = a), (a = !1));
      g = 0;
      for (j = l.length; g < j; g++) {
        var r = new s(l[g]);
        if ("table" === b) (f = c.call(r, l[g], g)), f !== k && e.push(f);
        else if ("columns" === b || "rows" === b)
          (f = c.call(r, l[g], this[g], g)), f !== k && e.push(f);
        else if (
          "column" === b ||
          "column-rows" === b ||
          "row" === b ||
          "cell" === b
        ) {
          o = this[g];
          "column-rows" === b && (m = Ba(l[g], u.opts));
          h = 0;
          for (n = o.length; h < n; h++)
            (f = o[h]),
              (f =
                "cell" === b
                  ? c.call(r, l[g], f.row, f.column, g, h)
                  : c.call(r, l[g], f, g, h, m)),
              f !== k && e.push(f);
        }
      }
      return e.length || d
        ? ((a = new s(l, a ? e.concat.apply([], e) : e)),
          (b = a.selector),
          (b.rows = u.rows),
          (b.cols = u.cols),
          (b.opts = u.opts),
          a)
        : this;
    },
    lastIndexOf:
      w.lastIndexOf ||
      function(a, b) {
        return this.indexOf.apply(this.toArray.reverse(), arguments);
      },
    length: 0,
    map: function(a) {
      var b = [];
      if (w.map) b = w.map.call(this, a, this);
      else
        for (var c = 0, d = this.length; c < d; c++)
          b.push(a.call(this, this[c], c));
      return new s(this.context, b);
    },
    pluck: function(a) {
      return this.map(function(b) {
        return b[a];
      });
    },
    pop: w.pop,
    push: w.push,
    reduce:
      w.reduce ||
      function(a, b) {
        return gb(this, a, b, 0, this.length, 1);
      },
    reduceRight:
      w.reduceRight ||
      function(a, b) {
        return gb(this, a, b, this.length - 1, -1, -1);
      },
    reverse: w.reverse,
    selector: null,
    shift: w.shift,
    slice: function() {
      return new s(this.context, this);
    },
    sort: w.sort,
    splice: w.splice,
    toArray: function() {
      return w.slice.call(this);
    },
    to$: function() {
      return h(this);
    },
    toJQuery: function() {
      return h(this);
    },
    unique: function() {
      return new s(this.context, qa(this));
    },
    unshift: w.unshift
  });
  s.extend = function(a, b, c) {
    if (c.length && b && (b instanceof s || b.__dt_wrapper)) {
      var d,
        e,
        f,
        g = function(a, b, c) {
          return function() {
            var d = b.apply(a, arguments);
            s.extend(d, d, c.methodExt);
            return d;
          };
        };
      d = 0;
      for (e = c.length; d < e; d++)
        (f = c[d]),
          (b[f.name] =
            "function" === typeof f.val
              ? g(a, f.val, f)
              : h.isPlainObject(f.val) ? {} : f.val),
          (b[f.name].__dt_wrapper = !0),
          s.extend(a, b[f.name], f.propExt);
    }
  };
  s.register = o = function(a, b) {
    if (h.isArray(a))
      for (var c = 0, d = a.length; c < d; c++) s.register(a[c], b);
    else
      for (
        var e = a.split("."), f = Rb, g, j, c = 0, d = e.length;
        c < d;
        c++
      ) {
        g = (j = -1 !== e[c].indexOf("()")) ? e[c].replace("()", "") : e[c];
        var i;
        a: {
          i = 0;
          for (var n = f.length; i < n; i++)
            if (f[i].name === g) {
              i = f[i];
              break a;
            }
          i = null;
        }
        i ||
          ((i = { name: g, val: {}, methodExt: [], propExt: [] }), f.push(i));
        c === d - 1 ? (i.val = b) : (f = j ? i.methodExt : i.propExt);
      }
  };
  s.registerPlural = u = function(a, b, c) {
    s.register(a, c);
    s.register(b, function() {
      var a = c.apply(this, arguments);
      return a === this
        ? this
        : a instanceof s
          ? a.length ? (h.isArray(a[0]) ? new s(a.context, a[0]) : a[0]) : k
          : a;
    });
  };
  o("tables()", function(a) {
    var b;
    if (a) {
      b = s;
      var c = this.context;
      if ("number" === typeof a) a = [c[a]];
      else
        var d = h.map(c, function(a) {
            return a.nTable;
          }),
          a = h(d)
            .filter(a)
            .map(function() {
              var a = h.inArray(this, d);
              return c[a];
            })
            .toArray();
      b = new b(a);
    } else b = this;
    return b;
  });
  o("table()", function(a) {
    var a = this.tables(a),
      b = a.context;
    return b.length ? new s(b[0]) : a;
  });
  u("tables().nodes()", "table().node()", function() {
    return this.iterator(
      "table",
      function(a) {
        return a.nTable;
      },
      1
    );
  });
  u("tables().body()", "table().body()", function() {
    return this.iterator(
      "table",
      function(a) {
        return a.nTBody;
      },
      1
    );
  });
  u("tables().header()", "table().header()", function() {
    return this.iterator(
      "table",
      function(a) {
        return a.nTHead;
      },
      1
    );
  });
  u("tables().footer()", "table().footer()", function() {
    return this.iterator(
      "table",
      function(a) {
        return a.nTFoot;
      },
      1
    );
  });
  u("tables().containers()", "table().container()", function() {
    return this.iterator(
      "table",
      function(a) {
        return a.nTableWrapper;
      },
      1
    );
  });
  o("draw()", function(a) {
    return this.iterator("table", function(b) {
      "page" === a
        ? N(b)
        : ("string" === typeof a && (a = "full-hold" === a ? !1 : !0),
          S(b, !1 === a));
    });
  });
  o("page()", function(a) {
    return a === k
      ? this.page.info().page
      : this.iterator("table", function(b) {
          Sa(b, a);
        });
  });
  o("page.info()", function() {
    if (0 === this.context.length) return k;
    var a = this.context[0],
      b = a._iDisplayStart,
      c = a.oFeatures.bPaginate ? a._iDisplayLength : -1,
      d = a.fnRecordsDisplay(),
      e = -1 === c;
    return {
      page: e ? 0 : Math.floor(b / c),
      pages: e ? 1 : Math.ceil(d / c),
      start: b,
      end: a.fnDisplayEnd(),
      length: c,
      recordsTotal: a.fnRecordsTotal(),
      recordsDisplay: d,
      serverSide: "ssp" === y(a)
    };
  });
  o("page.len()", function(a) {
    return a === k
      ? 0 !== this.context.length ? this.context[0]._iDisplayLength : k
      : this.iterator("table", function(b) {
          Qa(b, a);
        });
  });
  var Sb = function(a, b, c) {
    if (c) {
      var d = new s(a);
      d.one("draw", function() {
        c(d.ajax.json());
      });
    }
    if ("ssp" == y(a)) S(a, b);
    else {
      C(a, !0);
      var e = a.jqXHR;
      e && 4 !== e.readyState && e.abort();
      sa(a, [], function(c) {
        na(a);
        for (var c = ta(a, c), d = 0, e = c.length; d < e; d++) M(a, c[d]);
        S(a, b);
        C(a, !1);
      });
    }
  };
  o("ajax.json()", function() {
    var a = this.context;
    if (0 < a.length) return a[0].json;
  });
  o("ajax.params()", function() {
    var a = this.context;
    if (0 < a.length) return a[0].oAjaxData;
  });
  o("ajax.reload()", function(a, b) {
    return this.iterator("table", function(c) {
      Sb(c, !1 === b, a);
    });
  });
  o("ajax.url()", function(a) {
    var b = this.context;
    if (a === k) {
      if (0 === b.length) return k;
      b = b[0];
      return b.ajax
        ? h.isPlainObject(b.ajax) ? b.ajax.url : b.ajax
        : b.sAjaxSource;
    }
    return this.iterator("table", function(b) {
      h.isPlainObject(b.ajax) ? (b.ajax.url = a) : (b.ajax = a);
    });
  });
  o("ajax.url().load()", function(a, b) {
    return this.iterator("table", function(c) {
      Sb(c, !1 === b, a);
    });
  });
  var Za = function(a, b, c, d, e) {
      var f = [],
        g,
        j,
        i,
        n,
        l,
        m;
      i = typeof b;
      if (!b || "string" === i || "function" === i || b.length === k) b = [b];
      i = 0;
      for (n = b.length; i < n; i++) {
        j =
          b[i] && b[i].split && !b[i].match(/[\[\(:]/)
            ? b[i].split(",")
            : [b[i]];
        l = 0;
        for (m = j.length; l < m; l++)
          (g = c("string" === typeof j[l] ? h.trim(j[l]) : j[l])) &&
            g.length &&
            (f = f.concat(g));
      }
      a = x.selector[a];
      if (a.length) {
        i = 0;
        for (n = a.length; i < n; i++) f = a[i](d, e, f);
      }
      return qa(f);
    },
    $a = function(a) {
      a || (a = {});
      a.filter && a.search === k && (a.search = a.filter);
      return h.extend({ search: "none", order: "current", page: "all" }, a);
    },
    ab = function(a) {
      for (var b = 0, c = a.length; b < c; b++)
        if (0 < a[b].length)
          return (
            (a[0] = a[b]),
            (a[0].length = 1),
            (a.length = 1),
            (a.context = [a.context[b]]),
            a
          );
      a.length = 0;
      return a;
    },
    Ba = function(a, b) {
      var c,
        d,
        e,
        f = [],
        g = a.aiDisplay;
      c = a.aiDisplayMaster;
      var j = b.search;
      d = b.order;
      e = b.page;
      if ("ssp" == y(a)) return "removed" === j ? [] : W(0, c.length);
      if ("current" == e) {
        c = a._iDisplayStart;
        for (d = a.fnDisplayEnd(); c < d; c++) f.push(g[c]);
      } else if ("current" == d || "applied" == d)
        f =
          "none" == j
            ? c.slice()
            : "applied" == j
              ? g.slice()
              : h.map(c, function(a) {
                  return -1 === h.inArray(a, g) ? a : null;
                });
      else if ("index" == d || "original" == d) {
        c = 0;
        for (d = a.aoData.length; c < d; c++)
          "none" == j
            ? f.push(c)
            : ((e = h.inArray(c, g)),
              ((-1 === e && "removed" == j) || (0 <= e && "applied" == j)) &&
                f.push(c));
      }
      return f;
    };
  o("rows()", function(a, b) {
    a === k ? (a = "") : h.isPlainObject(a) && ((b = a), (a = ""));
    var b = $a(b),
      c = this.iterator(
        "table",
        function(c) {
          var e = b,
            f;
          return Za(
            "row",
            a,
            function(a) {
              var b = Nb(a);
              if (b !== null && !e) return [b];
              f || (f = Ba(c, e));
              if (b !== null && h.inArray(b, f) !== -1) return [b];
              if (a === null || a === k || a === "") return f;
              if (typeof a === "function")
                return h.map(f, function(b) {
                  var e = c.aoData[b];
                  return a(b, e._aData, e.nTr) ? b : null;
                });
              b = Qb(ia(c.aoData, f, "nTr"));
              if (a.nodeName) {
                if (a._DT_RowIndex !== k) return [a._DT_RowIndex];
                if (a._DT_CellIndex) return [a._DT_CellIndex.row];
                b = h(a).closest("*[data-dt-row]");
                return b.length ? [b.data("dt-row")] : [];
              }
              if (typeof a === "string" && a.charAt(0) === "#") {
                var i = c.aIds[a.replace(/^#/, "")];
                if (i !== k) return [i.idx];
              }
              return h(b)
                .filter(a)
                .map(function() {
                  return this._DT_RowIndex;
                })
                .toArray();
            },
            c,
            e
          );
        },
        1
      );
    c.selector.rows = a;
    c.selector.opts = b;
    return c;
  });
  o("rows().nodes()", function() {
    return this.iterator(
      "row",
      function(a, b) {
        return a.aoData[b].nTr || k;
      },
      1
    );
  });
  o("rows().data()", function() {
    return this.iterator(
      !0,
      "rows",
      function(a, b) {
        return ia(a.aoData, b, "_aData");
      },
      1
    );
  });
  u("rows().cache()", "row().cache()", function(a) {
    return this.iterator(
      "row",
      function(b, c) {
        var d = b.aoData[c];
        return "search" === a ? d._aFilterData : d._aSortData;
      },
      1
    );
  });
  u("rows().invalidate()", "row().invalidate()", function(a) {
    return this.iterator("row", function(b, c) {
      ca(b, c, a);
    });
  });
  u("rows().indexes()", "row().index()", function() {
    return this.iterator(
      "row",
      function(a, b) {
        return b;
      },
      1
    );
  });
  u("rows().ids()", "row().id()", function(a) {
    for (var b = [], c = this.context, d = 0, e = c.length; d < e; d++)
      for (var f = 0, g = this[d].length; f < g; f++) {
        var h = c[d].rowIdFn(c[d].aoData[this[d][f]]._aData);
        b.push((!0 === a ? "#" : "") + h);
      }
    return new s(c, b);
  });
  u("rows().remove()", "row().remove()", function() {
    var a = this;
    this.iterator("row", function(b, c, d) {
      var e = b.aoData,
        f = e[c],
        g,
        h,
        i,
        n,
        l;
      e.splice(c, 1);
      g = 0;
      for (h = e.length; g < h; g++)
        if (
          ((i = e[g]),
          (l = i.anCells),
          null !== i.nTr && (i.nTr._DT_RowIndex = g),
          null !== l)
        ) {
          i = 0;
          for (n = l.length; i < n; i++) l[i]._DT_CellIndex.row = g;
        }
      oa(b.aiDisplayMaster, c);
      oa(b.aiDisplay, c);
      oa(a[d], c, !1);
      0 < b._iRecordsDisplay && b._iRecordsDisplay--;
      Ra(b);
      c = b.rowIdFn(f._aData);
      c !== k && delete b.aIds[c];
    });
    this.iterator("table", function(a) {
      for (var c = 0, d = a.aoData.length; c < d; c++) a.aoData[c].idx = c;
    });
    return this;
  });
  o("rows.add()", function(a) {
    var b = this.iterator(
        "table",
        function(b) {
          var c,
            f,
            g,
            h = [];
          f = 0;
          for (g = a.length; f < g; f++)
            (c = a[f]),
              c.nodeName && "TR" === c.nodeName.toUpperCase()
                ? h.push(ma(b, c)[0])
                : h.push(M(b, c));
          return h;
        },
        1
      ),
      c = this.rows(-1);
    c.pop();
    h.merge(c, b);
    return c;
  });
  o("row()", function(a, b) {
    return ab(this.rows(a, b));
  });
  o("row().data()", function(a) {
    var b = this.context;
    if (a === k)
      return b.length && this.length ? b[0].aoData[this[0]]._aData : k;
    b[0].aoData[this[0]]._aData = a;
    ca(b[0], this[0], "data");
    return this;
  });
  o("row().node()", function() {
    var a = this.context;
    return a.length && this.length ? a[0].aoData[this[0]].nTr || null : null;
  });
  o("row.add()", function(a) {
    a instanceof h && a.length && (a = a[0]);
    var b = this.iterator("table", function(b) {
      return a.nodeName && "TR" === a.nodeName.toUpperCase()
        ? ma(b, a)[0]
        : M(b, a);
    });
    return this.row(b[0]);
  });
  var bb = function(a, b) {
      var c = a.context;
      if (c.length && (c = c[0].aoData[b !== k ? b : a[0]]) && c._details)
        c._details.remove(), (c._detailsShow = k), (c._details = k);
    },
    Tb = function(a, b) {
      var c = a.context;
      if (c.length && a.length) {
        var d = c[0].aoData[a[0]];
        if (d._details) {
          (d._detailsShow = b)
            ? d._details.insertAfter(d.nTr)
            : d._details.detach();
          var e = c[0],
            f = new s(e),
            g = e.aoData;
          f.off(
            "draw.dt.DT_details column-visibility.dt.DT_details destroy.dt.DT_details"
          );
          0 < D(g, "_details").length &&
            (f.on("draw.dt.DT_details", function(a, b) {
              e === b &&
                f
                  .rows({ page: "current" })
                  .eq(0)
                  .each(function(a) {
                    a = g[a];
                    a._detailsShow && a._details.insertAfter(a.nTr);
                  });
            }),
            f.on("column-visibility.dt.DT_details", function(a, b) {
              if (e === b)
                for (var c, d = aa(b), f = 0, h = g.length; f < h; f++)
                  (c = g[f]),
                    c._details &&
                      c._details.children("td[colspan]").attr("colspan", d);
            }),
            f.on("destroy.dt.DT_details", function(a, b) {
              if (e === b)
                for (var c = 0, d = g.length; c < d; c++)
                  g[c]._details && bb(f, c);
            }));
        }
      }
    };
  o("row().child()", function(a, b) {
    var c = this.context;
    if (a === k)
      return c.length && this.length ? c[0].aoData[this[0]]._details : k;
    if (!0 === a) this.child.show();
    else if (!1 === a) bb(this);
    else if (c.length && this.length) {
      var d = c[0],
        c = c[0].aoData[this[0]],
        e = [],
        f = function(a, b) {
          if (h.isArray(a) || a instanceof h)
            for (var c = 0, k = a.length; c < k; c++) f(a[c], b);
          else
            a.nodeName && "tr" === a.nodeName.toLowerCase()
              ? e.push(a)
              : ((c = h("<tr><td/></tr>").addClass(b)),
                (h("td", c)
                  .addClass(b)
                  .html(a)[0].colSpan = aa(d)),
                e.push(c[0]));
        };
      f(a, b);
      c._details && c._details.detach();
      c._details = h(e);
      c._detailsShow && c._details.insertAfter(c.nTr);
    }
    return this;
  });
  o(["row().child.show()", "row().child().show()"], function() {
    Tb(this, !0);
    return this;
  });
  o(["row().child.hide()", "row().child().hide()"], function() {
    Tb(this, !1);
    return this;
  });
  o(["row().child.remove()", "row().child().remove()"], function() {
    bb(this);
    return this;
  });
  o("row().child.isShown()", function() {
    var a = this.context;
    return a.length && this.length
      ? a[0].aoData[this[0]]._detailsShow || !1
      : !1;
  });
  var bc = /^([^:]+):(name|visIdx|visible)$/,
    Ub = function(a, b, c, d, e) {
      for (var c = [], d = 0, f = e.length; d < f; d++) c.push(B(a, e[d], b));
      return c;
    };
  o("columns()", function(a, b) {
    a === k ? (a = "") : h.isPlainObject(a) && ((b = a), (a = ""));
    var b = $a(b),
      c = this.iterator(
        "table",
        function(c) {
          var e = a,
            f = b,
            g = c.aoColumns,
            j = D(g, "sName"),
            i = D(g, "nTh");
          return Za(
            "column",
            e,
            function(a) {
              var b = Nb(a);
              if (a === "") return W(g.length);
              if (b !== null) return [b >= 0 ? b : g.length + b];
              if (typeof a === "function") {
                var e = Ba(c, f);
                return h.map(g, function(b, f) {
                  return a(f, Ub(c, f, 0, 0, e), i[f]) ? f : null;
                });
              }
              var k = typeof a === "string" ? a.match(bc) : "";
              if (k)
                switch (k[2]) {
                  case "visIdx":
                  case "visible":
                    b = parseInt(k[1], 10);
                    if (b < 0) {
                      var m = h.map(g, function(a, b) {
                        return a.bVisible ? b : null;
                      });
                      return [m[m.length + b]];
                    }
                    return [Z(c, b)];
                  case "name":
                    return h.map(j, function(a, b) {
                      return a === k[1] ? b : null;
                    });
                  default:
                    return [];
                }
              if (a.nodeName && a._DT_CellIndex)
                return [a._DT_CellIndex.column];
              b = h(i)
                .filter(a)
                .map(function() {
                  return h.inArray(this, i);
                })
                .toArray();
              if (b.length || !a.nodeName) return b;
              b = h(a).closest("*[data-dt-column]");
              return b.length ? [b.data("dt-column")] : [];
            },
            c,
            f
          );
        },
        1
      );
    c.selector.cols = a;
    c.selector.opts = b;
    return c;
  });
  u("columns().header()", "column().header()", function() {
    return this.iterator(
      "column",
      function(a, b) {
        return a.aoColumns[b].nTh;
      },
      1
    );
  });
  u("columns().footer()", "column().footer()", function() {
    return this.iterator(
      "column",
      function(a, b) {
        return a.aoColumns[b].nTf;
      },
      1
    );
  });
  u("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", Ub, 1);
  });
  u("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator(
      "column",
      function(a, b) {
        return a.aoColumns[b].mData;
      },
      1
    );
  });
  u("columns().cache()", "column().cache()", function(a) {
    return this.iterator(
      "column-rows",
      function(b, c, d, e, f) {
        return ia(
          b.aoData,
          f,
          "search" === a ? "_aFilterData" : "_aSortData",
          c
        );
      },
      1
    );
  });
  u("columns().nodes()", "column().nodes()", function() {
    return this.iterator(
      "column-rows",
      function(a, b, c, d, e) {
        return ia(a.aoData, e, "anCells", b);
      },
      1
    );
  });
  u("columns().visible()", "column().visible()", function(a, b) {
    var c = this.iterator("column", function(b, c) {
      if (a === k) return b.aoColumns[c].bVisible;
      var f = b.aoColumns,
        g = f[c],
        j = b.aoData,
        i,
        n,
        l;
      if (a !== k && g.bVisible !== a) {
        if (a) {
          var m = h.inArray(!0, D(f, "bVisible"), c + 1);
          i = 0;
          for (n = j.length; i < n; i++)
            (l = j[i].nTr),
              (f = j[i].anCells),
              l && l.insertBefore(f[c], f[m] || null);
        } else h(D(b.aoData, "anCells", c)).detach();
        g.bVisible = a;
        ea(b, b.aoHeader);
        ea(b, b.aoFooter);
        xa(b);
      }
    });
    a !== k &&
      (this.iterator("column", function(c, e) {
        r(c, null, "column-visibility", [c, e, a, b]);
      }),
      (b === k || b) && this.columns.adjust());
    return c;
  });
  u("columns().indexes()", "column().index()", function(a) {
    return this.iterator(
      "column",
      function(b, c) {
        return "visible" === a ? $(b, c) : c;
      },
      1
    );
  });
  o("columns.adjust()", function() {
    return this.iterator(
      "table",
      function(a) {
        Y(a);
      },
      1
    );
  });
  o("column.index()", function(a, b) {
    if (0 !== this.context.length) {
      var c = this.context[0];
      if ("fromVisible" === a || "toData" === a) return Z(c, b);
      if ("fromData" === a || "toVisible" === a) return $(c, b);
    }
  });
  o("column()", function(a, b) {
    return ab(this.columns(a, b));
  });
  o("cells()", function(a, b, c) {
    h.isPlainObject(a) &&
      (a.row === k ? ((c = a), (a = null)) : ((c = b), (b = null)));
    h.isPlainObject(b) && ((c = b), (b = null));
    if (null === b || b === k)
      return this.iterator("table", function(b) {
        var d = a,
          e = $a(c),
          f = b.aoData,
          g = Ba(b, e),
          j = Qb(ia(f, g, "anCells")),
          i = h([].concat.apply([], j)),
          l,
          n = b.aoColumns.length,
          m,
          o,
          u,
          s,
          r,
          v;
        return Za(
          "cell",
          d,
          function(a) {
            var c = typeof a === "function";
            if (a === null || a === k || c) {
              m = [];
              o = 0;
              for (u = g.length; o < u; o++) {
                l = g[o];
                for (s = 0; s < n; s++) {
                  r = { row: l, column: s };
                  if (c) {
                    v = f[l];
                    a(r, B(b, l, s), v.anCells ? v.anCells[s] : null) &&
                      m.push(r);
                  } else m.push(r);
                }
              }
              return m;
            }
            if (h.isPlainObject(a)) return [a];
            c = i
              .filter(a)
              .map(function(a, b) {
                return {
                  row: b._DT_CellIndex.row,
                  column: b._DT_CellIndex.column
                };
              })
              .toArray();
            if (c.length || !a.nodeName) return c;
            v = h(a).closest("*[data-dt-row]");
            return v.length
              ? [{ row: v.data("dt-row"), column: v.data("dt-column") }]
              : [];
          },
          b,
          e
        );
      });
    var d = this.columns(b, c),
      e = this.rows(a, c),
      f,
      g,
      j,
      i,
      n,
      l = this.iterator(
        "table",
        function(a, b) {
          f = [];
          g = 0;
          for (j = e[b].length; g < j; g++) {
            i = 0;
            for (n = d[b].length; i < n; i++)
              f.push({ row: e[b][g], column: d[b][i] });
          }
          return f;
        },
        1
      );
    h.extend(l.selector, { cols: b, rows: a, opts: c });
    return l;
  });
  u("cells().nodes()", "cell().node()", function() {
    return this.iterator(
      "cell",
      function(a, b, c) {
        return (a = a.aoData[b]) && a.anCells ? a.anCells[c] : k;
      },
      1
    );
  });
  o("cells().data()", function() {
    return this.iterator(
      "cell",
      function(a, b, c) {
        return B(a, b, c);
      },
      1
    );
  });
  u("cells().cache()", "cell().cache()", function(a) {
    a = "search" === a ? "_aFilterData" : "_aSortData";
    return this.iterator(
      "cell",
      function(b, c, d) {
        return b.aoData[c][a][d];
      },
      1
    );
  });
  u("cells().render()", "cell().render()", function(a) {
    return this.iterator(
      "cell",
      function(b, c, d) {
        return B(b, c, d, a);
      },
      1
    );
  });
  u("cells().indexes()", "cell().index()", function() {
    return this.iterator(
      "cell",
      function(a, b, c) {
        return { row: b, column: c, columnVisible: $(a, c) };
      },
      1
    );
  });
  u("cells().invalidate()", "cell().invalidate()", function(a) {
    return this.iterator("cell", function(b, c, d) {
      ca(b, c, a, d);
    });
  });
  o("cell()", function(a, b, c) {
    return ab(this.cells(a, b, c));
  });
  o("cell().data()", function(a) {
    var b = this.context,
      c = this[0];
    if (a === k)
      return b.length && c.length ? B(b[0], c[0].row, c[0].column) : k;
    ib(b[0], c[0].row, c[0].column, a);
    ca(b[0], c[0].row, "data", c[0].column);
    return this;
  });
  o("order()", function(a, b) {
    var c = this.context;
    if (a === k) return 0 !== c.length ? c[0].aaSorting : k;
    "number" === typeof a
      ? (a = [[a, b]])
      : a.length &&
        !h.isArray(a[0]) &&
        (a = Array.prototype.slice.call(arguments));
    return this.iterator("table", function(b) {
      b.aaSorting = a.slice();
    });
  });
  o("order.listener()", function(a, b, c) {
    return this.iterator("table", function(d) {
      La(d, a, b, c);
    });
  });
  o("order.fixed()", function(a) {
    if (!a) {
      var b = this.context,
        b = b.length ? b[0].aaSortingFixed : k;
      return h.isArray(b) ? { pre: b } : b;
    }
    return this.iterator("table", function(b) {
      b.aaSortingFixed = h.extend(!0, {}, a);
    });
  });
  o(["columns().order()", "column().order()"], function(a) {
    var b = this;
    return this.iterator("table", function(c, d) {
      var e = [];
      h.each(b[d], function(b, c) {
        e.push([c, a]);
      });
      c.aaSorting = e;
    });
  });
  o("search()", function(a, b, c, d) {
    var e = this.context;
    return a === k
      ? 0 !== e.length ? e[0].oPreviousSearch.sSearch : k
      : this.iterator("table", function(e) {
          e.oFeatures.bFilter &&
            fa(
              e,
              h.extend({}, e.oPreviousSearch, {
                sSearch: a + "",
                bRegex: null === b ? !1 : b,
                bSmart: null === c ? !0 : c,
                bCaseInsensitive: null === d ? !0 : d
              }),
              1
            );
        });
  });
  u("columns().search()", "column().search()", function(a, b, c, d) {
    return this.iterator("column", function(e, f) {
      var g = e.aoPreSearchCols;
      if (a === k) return g[f].sSearch;
      e.oFeatures.bFilter &&
        (h.extend(g[f], {
          sSearch: a + "",
          bRegex: null === b ? !1 : b,
          bSmart: null === c ? !0 : c,
          bCaseInsensitive: null === d ? !0 : d
        }),
        fa(e, e.oPreviousSearch, 1));
    });
  });
  o("state()", function() {
    return this.context.length ? this.context[0].oSavedState : null;
  });
  o("state.clear()", function() {
    return this.iterator("table", function(a) {
      a.fnStateSaveCallback.call(a.oInstance, a, {});
    });
  });
  o("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  o("state.save()", function() {
    return this.iterator("table", function(a) {
      xa(a);
    });
  });
  m.versionCheck = m.fnVersionCheck = function(a) {
    for (
      var b = m.version.split("."), a = a.split("."), c, d, e = 0, f = a.length;
      e < f;
      e++
    )
      if (
        ((c = parseInt(b[e], 10) || 0), (d = parseInt(a[e], 10) || 0), c !== d)
      )
        return c > d;
    return !0;
  };
  m.isDataTable = m.fnIsDataTable = function(a) {
    var b = h(a).get(0),
      c = !1;
    if (a instanceof m.Api) return !0;
    h.each(m.settings, function(a, e) {
      var f = e.nScrollHead ? h("table", e.nScrollHead)[0] : null,
        g = e.nScrollFoot ? h("table", e.nScrollFoot)[0] : null;
      if (e.nTable === b || f === b || g === b) c = !0;
    });
    return c;
  };
  m.tables = m.fnTables = function(a) {
    var b = !1;
    h.isPlainObject(a) && ((b = a.api), (a = a.visible));
    var c = h.map(m.settings, function(b) {
      if (!a || (a && h(b.nTable).is(":visible"))) return b.nTable;
    });
    return b ? new s(c) : c;
  };
  m.camelToHungarian = I;
  o("$()", function(a, b) {
    var c = this.rows(b).nodes(),
      c = h(c);
    return h([].concat(c.filter(a).toArray(), c.find(a).toArray()));
  });
  h.each(["on", "one", "off"], function(a, b) {
    o(b + "()", function() {
      var a = Array.prototype.slice.call(arguments);
      a[0] = h
        .map(a[0].split(/\s/), function(a) {
          return !a.match(/\.dt\b/) ? a + ".dt" : a;
        })
        .join(" ");
      var d = h(this.tables().nodes());
      d[b].apply(d, a);
      return this;
    });
  });
  o("clear()", function() {
    return this.iterator("table", function(a) {
      na(a);
    });
  });
  o("settings()", function() {
    return new s(this.context, this.context);
  });
  o("init()", function() {
    var a = this.context;
    return a.length ? a[0].oInit : null;
  });
  o("data()", function() {
    return this.iterator("table", function(a) {
      return D(a.aoData, "_aData");
    }).flatten();
  });
  o("destroy()", function(a) {
    a = a || !1;
    return this.iterator("table", function(b) {
      var c = b.nTableWrapper.parentNode,
        d = b.oClasses,
        e = b.nTable,
        f = b.nTBody,
        g = b.nTHead,
        j = b.nTFoot,
        i = h(e),
        f = h(f),
        k = h(b.nTableWrapper),
        l = h.map(b.aoData, function(a) {
          return a.nTr;
        }),
        o;
      b.bDestroying = !0;
      r(b, "aoDestroyCallback", "destroy", [b]);
      a || new s(b).columns().visible(!0);
      k
        .off(".DT")
        .find(":not(tbody *)")
        .off(".DT");
      h(E).off(".DT-" + b.sInstance);
      e != g.parentNode && (i.children("thead").detach(), i.append(g));
      j && e != j.parentNode && (i.children("tfoot").detach(), i.append(j));
      b.aaSorting = [];
      b.aaSortingFixed = [];
      wa(b);
      h(l).removeClass(b.asStripeClasses.join(" "));
      h("th, td", g).removeClass(
        d.sSortable +
          " " +
          d.sSortableAsc +
          " " +
          d.sSortableDesc +
          " " +
          d.sSortableNone
      );
      f.children().detach();
      f.append(l);
      g = a ? "remove" : "detach";
      i[g]();
      k[g]();
      !a &&
        c &&
        (c.insertBefore(e, b.nTableReinsertBefore),
        i.css("width", b.sDestroyWidth).removeClass(d.sTable),
        (o = b.asDestroyStripes.length) &&
          f.children().each(function(a) {
            h(this).addClass(b.asDestroyStripes[a % o]);
          }));
      c = h.inArray(b, m.settings);
      -1 !== c && m.settings.splice(c, 1);
    });
  });
  h.each(["column", "row", "cell"], function(a, b) {
    o(b + "s().every()", function(a) {
      var d = this.selector.opts,
        e = this;
      return this.iterator(b, function(f, g, h, i, n) {
        a.call(e[b](g, "cell" === b ? h : d, "cell" === b ? d : k), g, h, i, n);
      });
    });
  });
  o("i18n()", function(a, b, c) {
    var d = this.context[0],
      a = Q(a)(d.oLanguage);
    a === k && (a = b);
    c !== k && h.isPlainObject(a) && (a = a[c] !== k ? a[c] : a._);
    return a.replace("%d", c);
  });
  m.version = "1.10.16";
  m.settings = [];
  m.models = {};
  m.models.oSearch = {
    bCaseInsensitive: !0,
    sSearch: "",
    bRegex: !1,
    bSmart: !0
  };
  m.models.oRow = {
    nTr: null,
    anCells: null,
    _aData: [],
    _aSortData: null,
    _aFilterData: null,
    _sFilterRow: null,
    _sRowStripe: "",
    src: null,
    idx: -1
  };
  m.models.oColumn = {
    idx: null,
    aDataSort: null,
    asSorting: null,
    bSearchable: null,
    bSortable: null,
    bVisible: null,
    _sManualType: null,
    _bAttrSrc: !1,
    fnCreatedCell: null,
    fnGetData: null,
    fnSetData: null,
    mData: null,
    mRender: null,
    nTh: null,
    nTf: null,
    sClass: null,
    sContentPadding: null,
    sDefaultContent: null,
    sName: null,
    sSortDataType: "std",
    sSortingClass: null,
    sSortingClassJUI: null,
    sTitle: null,
    sType: null,
    sWidth: null,
    sWidthOrig: null
  };
  m.defaults = {
    aaData: null,
    aaSorting: [[0, "asc"]],
    aaSortingFixed: [],
    ajax: null,
    aLengthMenu: [10, 25, 50, 100],
    aoColumns: null,
    aoColumnDefs: null,
    aoSearchCols: [],
    asStripeClasses: null,
    bAutoWidth: !0,
    bDeferRender: !1,
    bDestroy: !1,
    bFilter: !0,
    bInfo: !0,
    bLengthChange: !0,
    bPaginate: !0,
    bProcessing: !1,
    bRetrieve: !1,
    bScrollCollapse: !1,
    bServerSide: !1,
    bSort: !0,
    bSortMulti: !0,
    bSortCellsTop: !1,
    bSortClasses: !0,
    bStateSave: !1,
    fnCreatedRow: null,
    fnDrawCallback: null,
    fnFooterCallback: null,
    fnFormatNumber: function(a) {
      return a
        .toString()
        .replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands);
    },
    fnHeaderCallback: null,
    fnInfoCallback: null,
    fnInitComplete: null,
    fnPreDrawCallback: null,
    fnRowCallback: null,
    fnServerData: null,
    fnServerParams: null,
    fnStateLoadCallback: function(a) {
      try {
        return JSON.parse(
          (-1 === a.iStateDuration ? sessionStorage : localStorage).getItem(
            "DataTables_" + a.sInstance + "_" + location.pathname
          )
        );
      } catch (b) {}
    },
    fnStateLoadParams: null,
    fnStateLoaded: null,
    fnStateSaveCallback: function(a, b) {
      try {
        (-1 === a.iStateDuration ? sessionStorage : localStorage).setItem(
          "DataTables_" + a.sInstance + "_" + location.pathname,
          JSON.stringify(b)
        );
      } catch (c) {}
    },
    fnStateSaveParams: null,
    iStateDuration: 7200,
    iDeferLoading: null,
    iDisplayLength: 10,
    iDisplayStart: 0,
    iTabIndex: 0,
    oClasses: {},
    oLanguage: {
      oAria: {
        sSortAscending: ": activate to sort column ascending",
        sSortDescending: ": activate to sort column descending"
      },
      oPaginate: {
        sFirst: "First",
        sLast: "Last",
        sNext: "Next",
        sPrevious: "Previous"
      },
      sEmptyTable: "No data available in table",
      sInfo: "Showing _START_ to _END_ of _TOTAL_ entries",
      sInfoEmpty: "Showing 0 to 0 of 0 entries",
      sInfoFiltered: "(filtered from _MAX_ total entries)",
      sInfoPostFix: "",
      sDecimal: "",
      sThousands: ",",
      sLengthMenu: "Show _MENU_ entries",
      sLoadingRecords: "Loading...",
      sProcessing: "Processing...",
      sSearch: "Search:",
      sSearchPlaceholder: "",
      sUrl: "",
      sZeroRecords: "No matching records found"
    },
    oSearch: h.extend({}, m.models.oSearch),
    sAjaxDataProp: "data",
    sAjaxSource: null,
    sDom: "lfrtip",
    searchDelay: null,
    sPaginationType: "simple_numbers",
    sScrollX: "",
    sScrollXInner: "",
    sScrollY: "",
    sServerMethod: "GET",
    renderer: null,
    rowId: "DT_RowId"
  };
  X(m.defaults);
  m.defaults.column = {
    aDataSort: null,
    iDataSort: -1,
    asSorting: ["asc", "desc"],
    bSearchable: !0,
    bSortable: !0,
    bVisible: !0,
    fnCreatedCell: null,
    mData: null,
    mRender: null,
    sCellType: "td",
    sClass: "",
    sContentPadding: "",
    sDefaultContent: null,
    sName: "",
    sSortDataType: "std",
    sTitle: null,
    sType: null,
    sWidth: null
  };
  X(m.defaults.column);
  m.models.oSettings = {
    oFeatures: {
      bAutoWidth: null,
      bDeferRender: null,
      bFilter: null,
      bInfo: null,
      bLengthChange: null,
      bPaginate: null,
      bProcessing: null,
      bServerSide: null,
      bSort: null,
      bSortMulti: null,
      bSortClasses: null,
      bStateSave: null
    },
    oScroll: {
      bCollapse: null,
      iBarWidth: 0,
      sX: null,
      sXInner: null,
      sY: null
    },
    oLanguage: { fnInfoCallback: null },
    oBrowser: {
      bScrollOversize: !1,
      bScrollbarLeft: !1,
      bBounding: !1,
      barWidth: 0
    },
    ajax: null,
    aanFeatures: [],
    aoData: [],
    aiDisplay: [],
    aiDisplayMaster: [],
    aIds: {},
    aoColumns: [],
    aoHeader: [],
    aoFooter: [],
    oPreviousSearch: {},
    aoPreSearchCols: [],
    aaSorting: null,
    aaSortingFixed: [],
    asStripeClasses: null,
    asDestroyStripes: [],
    sDestroyWidth: 0,
    aoRowCallback: [],
    aoHeaderCallback: [],
    aoFooterCallback: [],
    aoDrawCallback: [],
    aoRowCreatedCallback: [],
    aoPreDrawCallback: [],
    aoInitComplete: [],
    aoStateSaveParams: [],
    aoStateLoadParams: [],
    aoStateLoaded: [],
    sTableId: "",
    nTable: null,
    nTHead: null,
    nTFoot: null,
    nTBody: null,
    nTableWrapper: null,
    bDeferLoading: !1,
    bInitialised: !1,
    aoOpenRows: [],
    sDom: null,
    searchDelay: null,
    sPaginationType: "two_button",
    iStateDuration: 0,
    aoStateSave: [],
    aoStateLoad: [],
    oSavedState: null,
    oLoadedState: null,
    sAjaxSource: null,
    sAjaxDataProp: null,
    bAjaxDataGet: !0,
    jqXHR: null,
    json: k,
    oAjaxData: k,
    fnServerData: null,
    aoServerParams: [],
    sServerMethod: null,
    fnFormatNumber: null,
    aLengthMenu: null,
    iDraw: 0,
    bDrawing: !1,
    iDrawError: -1,
    _iDisplayLength: 10,
    _iDisplayStart: 0,
    _iRecordsTotal: 0,
    _iRecordsDisplay: 0,
    oClasses: {},
    bFiltered: !1,
    bSorted: !1,
    bSortCellsTop: null,
    oInit: null,
    aoDestroyCallback: [],
    fnRecordsTotal: function() {
      return "ssp" == y(this)
        ? 1 * this._iRecordsTotal
        : this.aiDisplayMaster.length;
    },
    fnRecordsDisplay: function() {
      return "ssp" == y(this)
        ? 1 * this._iRecordsDisplay
        : this.aiDisplay.length;
    },
    fnDisplayEnd: function() {
      var a = this._iDisplayLength,
        b = this._iDisplayStart,
        c = b + a,
        d = this.aiDisplay.length,
        e = this.oFeatures,
        f = e.bPaginate;
      return e.bServerSide
        ? !1 === f || -1 === a ? b + d : Math.min(b + a, this._iRecordsDisplay)
        : !f || c > d || -1 === a ? d : c;
    },
    oInstance: null,
    sInstance: null,
    iTabIndex: 0,
    nScrollHead: null,
    nScrollFoot: null,
    aLastSort: [],
    oPlugins: {},
    rowIdFn: null,
    rowId: null
  };
  m.ext = x = {
    buttons: {},
    classes: {},
    builder: "-source-",
    errMode: "alert",
    feature: [],
    search: [],
    selector: { cell: [], column: [], row: [] },
    internal: {},
    legacy: { ajax: null },
    pager: {},
    renderer: { pageButton: {}, header: {} },
    order: {},
    type: { detect: [], search: {}, order: {} },
    _unique: 0,
    fnVersionCheck: m.fnVersionCheck,
    iApiIndex: 0,
    oJUIClasses: {},
    sVersion: m.version
  };
  h.extend(x, {
    afnFiltering: x.search,
    aTypes: x.type.detect,
    ofnSearch: x.type.search,
    oSort: x.type.order,
    afnSortData: x.order,
    aoFeatures: x.feature,
    oApi: x.internal,
    oStdClasses: x.classes,
    oPagination: x.pager
  });
  h.extend(m.ext.classes, {
    sTable: "dataTable",
    sNoFooter: "no-footer",
    sPageButton: "paginate_button",
    sPageButtonActive: "current",
    sPageButtonDisabled: "disabled",
    sStripeOdd: "odd",
    sStripeEven: "even",
    sRowEmpty: "dataTables_empty",
    sWrapper: "dataTables_wrapper",
    sFilter: "dataTables_filter",
    sInfo: "dataTables_info",
    sPaging: "dataTables_paginate paging_",
    sLength: "dataTables_length",
    sProcessing: "dataTables_processing",
    sSortAsc: "sorting_asc",
    sSortDesc: "sorting_desc",
    sSortable: "sorting",
    sSortableAsc: "sorting_asc_disabled",
    sSortableDesc: "sorting_desc_disabled",
    sSortableNone: "sorting_disabled",
    sSortColumn: "sorting_",
    sFilterInput: "",
    sLengthSelect: "",
    sScrollWrapper: "dataTables_scroll",
    sScrollHead: "dataTables_scrollHead",
    sScrollHeadInner: "dataTables_scrollHeadInner",
    sScrollBody: "dataTables_scrollBody",
    sScrollFoot: "dataTables_scrollFoot",
    sScrollFootInner: "dataTables_scrollFootInner",
    sHeaderTH: "",
    sFooterTH: "",
    sSortJUIAsc: "",
    sSortJUIDesc: "",
    sSortJUI: "",
    sSortJUIAscAllowed: "",
    sSortJUIDescAllowed: "",
    sSortJUIWrapper: "",
    sSortIcon: "",
    sJUIHeader: "",
    sJUIFooter: ""
  });
  var Kb = m.ext.pager;
  h.extend(Kb, {
    simple: function() {
      return ["previous", "next"];
    },
    full: function() {
      return ["first", "previous", "next", "last"];
    },
    numbers: function(a, b) {
      return [ha(a, b)];
    },
    simple_numbers: function(a, b) {
      return ["previous", ha(a, b), "next"];
    },
    full_numbers: function(a, b) {
      return ["first", "previous", ha(a, b), "next", "last"];
    },
    first_last_numbers: function(a, b) {
      return ["first", ha(a, b), "last"];
    },
    _numbers: ha,
    numbers_length: 7
  });
  h.extend(!0, m.ext.renderer, {
    pageButton: {
      _: function(a, b, c, d, e, f) {
        var g = a.oClasses,
          j = a.oLanguage.oPaginate,
          i = a.oLanguage.oAria.paginate || {},
          n,
          l,
          m = 0,
          o = function(b, d) {
            var k,
              s,
              u,
              r,
              v = function(b) {
                Sa(a, b.data.action, true);
              };
            k = 0;
            for (s = d.length; k < s; k++) {
              r = d[k];
              if (h.isArray(r)) {
                u = h("<" + (r.DT_el || "div") + "/>").appendTo(b);
                o(u, r);
              } else {
                n = null;
                l = "";
                switch (r) {
                  case "ellipsis":
                    b.append('<span class="ellipsis">&#x2026;</span>');
                    break;
                  case "first":
                    n = j.sFirst;
                    l = r + (e > 0 ? "" : " " + g.sPageButtonDisabled);
                    break;
                  case "previous":
                    n = j.sPrevious;
                    l = r + (e > 0 ? "" : " " + g.sPageButtonDisabled);
                    break;
                  case "next":
                    n = j.sNext;
                    l = r + (e < f - 1 ? "" : " " + g.sPageButtonDisabled);
                    break;
                  case "last":
                    n = j.sLast;
                    l = r + (e < f - 1 ? "" : " " + g.sPageButtonDisabled);
                    break;
                  default:
                    n = r + 1;
                    l = e === r ? g.sPageButtonActive : "";
                }
                if (n !== null) {
                  u = h("<a>", {
                    class: g.sPageButton + " " + l,
                    "aria-controls": a.sTableId,
                    "aria-label": i[r],
                    "data-dt-idx": m,
                    tabindex: a.iTabIndex,
                    id:
                      c === 0 && typeof r === "string"
                        ? a.sTableId + "_" + r
                        : null
                  })
                    .html(n)
                    .appendTo(b);
                  Va(u, { action: r }, v);
                  m++;
                }
              }
            }
          },
          s;
        try {
          s = h(b)
            .find(G.activeElement)
            .data("dt-idx");
        } catch (u) {}
        o(h(b).empty(), d);
        s !== k &&
          h(b)
            .find("[data-dt-idx=" + s + "]")
            .focus();
      }
    }
  });
  h.extend(m.ext.type.detect, [
    function(a, b) {
      var c = b.oLanguage.sDecimal;
      return Ya(a, c) ? "num" + c : null;
    },
    function(a) {
      if (a && !(a instanceof Date) && !Zb.test(a)) return null;
      var b = Date.parse(a);
      return (null !== b && !isNaN(b)) || L(a) ? "date" : null;
    },
    function(a, b) {
      var c = b.oLanguage.sDecimal;
      return Ya(a, c, !0) ? "num-fmt" + c : null;
    },
    function(a, b) {
      var c = b.oLanguage.sDecimal;
      return Pb(a, c) ? "html-num" + c : null;
    },
    function(a, b) {
      var c = b.oLanguage.sDecimal;
      return Pb(a, c, !0) ? "html-num-fmt" + c : null;
    },
    function(a) {
      return L(a) || ("string" === typeof a && -1 !== a.indexOf("<"))
        ? "html"
        : null;
    }
  ]);
  h.extend(m.ext.type.search, {
    html: function(a) {
      return L(a)
        ? a
        : "string" === typeof a ? a.replace(Mb, " ").replace(Aa, "") : "";
    },
    string: function(a) {
      return L(a) ? a : "string" === typeof a ? a.replace(Mb, " ") : a;
    }
  });
  var za = function(a, b, c, d) {
    if (0 !== a && (!a || "-" === a)) return -Infinity;
    b && (a = Ob(a, b));
    a.replace && (c && (a = a.replace(c, "")), d && (a = a.replace(d, "")));
    return 1 * a;
  };
  h.extend(x.type.order, {
    "date-pre": function(a) {
      return Date.parse(a) || -Infinity;
    },
    "html-pre": function(a) {
      return L(a)
        ? ""
        : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + "";
    },
    "string-pre": function(a) {
      return L(a)
        ? ""
        : "string" === typeof a
          ? a.toLowerCase()
          : !a.toString ? "" : a.toString();
    },
    "string-asc": function(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    },
    "string-desc": function(a, b) {
      return a < b ? 1 : a > b ? -1 : 0;
    }
  });
  cb("");
  h.extend(!0, m.ext.renderer, {
    header: {
      _: function(a, b, c, d) {
        h(a.nTable).on("order.dt.DT", function(e, f, g, h) {
          if (a === f) {
            e = c.idx;
            b
              .removeClass(
                c.sSortingClass + " " + d.sSortAsc + " " + d.sSortDesc
              )
              .addClass(
                h[e] == "asc"
                  ? d.sSortAsc
                  : h[e] == "desc" ? d.sSortDesc : c.sSortingClass
              );
          }
        });
      },
      jqueryui: function(a, b, c, d) {
        h("<div/>")
          .addClass(d.sSortJUIWrapper)
          .append(b.contents())
          .append(h("<span/>").addClass(d.sSortIcon + " " + c.sSortingClassJUI))
          .appendTo(b);
        h(a.nTable).on("order.dt.DT", function(e, f, g, h) {
          if (a === f) {
            e = c.idx;
            b
              .removeClass(d.sSortAsc + " " + d.sSortDesc)
              .addClass(
                h[e] == "asc"
                  ? d.sSortAsc
                  : h[e] == "desc" ? d.sSortDesc : c.sSortingClass
              );
            b
              .find("span." + d.sSortIcon)
              .removeClass(
                d.sSortJUIAsc +
                  " " +
                  d.sSortJUIDesc +
                  " " +
                  d.sSortJUI +
                  " " +
                  d.sSortJUIAscAllowed +
                  " " +
                  d.sSortJUIDescAllowed
              )
              .addClass(
                h[e] == "asc"
                  ? d.sSortJUIAsc
                  : h[e] == "desc" ? d.sSortJUIDesc : c.sSortingClassJUI
              );
          }
        });
      }
    }
  });
  var Vb = function(a) {
    return "string" === typeof a
      ? a
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
      : a;
  };
  m.render = {
    number: function(a, b, c, d, e) {
      return {
        display: function(f) {
          if ("number" !== typeof f && "string" !== typeof f) return f;
          var g = 0 > f ? "-" : "",
            h = parseFloat(f);
          if (isNaN(h)) return Vb(f);
          h = h.toFixed(c);
          f = Math.abs(h);
          h = parseInt(f, 10);
          f = c ? b + (f - h).toFixed(c).substring(2) : "";
          return (
            g +
            (d || "") +
            h.toString().replace(/\B(?=(\d{3})+(?!\d))/g, a) +
            f +
            (e || "")
          );
        }
      };
    },
    text: function() {
      return { display: Vb };
    }
  };
  h.extend(m.ext.internal, {
    _fnExternApiFunc: Lb,
    _fnBuildAjax: sa,
    _fnAjaxUpdate: kb,
    _fnAjaxParameters: tb,
    _fnAjaxUpdateDraw: ub,
    _fnAjaxDataSrc: ta,
    _fnAddColumn: Da,
    _fnColumnOptions: ja,
    _fnAdjustColumnSizing: Y,
    _fnVisibleToColumnIndex: Z,
    _fnColumnIndexToVisible: $,
    _fnVisbleColumns: aa,
    _fnGetColumns: la,
    _fnColumnTypes: Fa,
    _fnApplyColumnDefs: hb,
    _fnHungarianMap: X,
    _fnCamelToHungarian: I,
    _fnLanguageCompat: Ca,
    _fnBrowserDetect: fb,
    _fnAddData: M,
    _fnAddTr: ma,
    _fnNodeToDataIndex: function(a, b) {
      return b._DT_RowIndex !== k ? b._DT_RowIndex : null;
    },
    _fnNodeToColumnIndex: function(a, b, c) {
      return h.inArray(c, a.aoData[b].anCells);
    },
    _fnGetCellData: B,
    _fnSetCellData: ib,
    _fnSplitObjNotation: Ia,
    _fnGetObjectDataFn: Q,
    _fnSetObjectDataFn: R,
    _fnGetDataMaster: Ja,
    _fnClearTable: na,
    _fnDeleteIndex: oa,
    _fnInvalidate: ca,
    _fnGetRowElements: Ha,
    _fnCreateTr: Ga,
    _fnBuildHead: jb,
    _fnDrawHead: ea,
    _fnDraw: N,
    _fnReDraw: S,
    _fnAddOptionsHtml: mb,
    _fnDetectHeader: da,
    _fnGetUniqueThs: ra,
    _fnFeatureHtmlFilter: ob,
    _fnFilterComplete: fa,
    _fnFilterCustom: xb,
    _fnFilterColumn: wb,
    _fnFilter: vb,
    _fnFilterCreateSearch: Oa,
    _fnEscapeRegex: Pa,
    _fnFilterData: yb,
    _fnFeatureHtmlInfo: rb,
    _fnUpdateInfo: Bb,
    _fnInfoMacros: Cb,
    _fnInitialise: ga,
    _fnInitComplete: ua,
    _fnLengthChange: Qa,
    _fnFeatureHtmlLength: nb,
    _fnFeatureHtmlPaginate: sb,
    _fnPageChange: Sa,
    _fnFeatureHtmlProcessing: pb,
    _fnProcessingDisplay: C,
    _fnFeatureHtmlTable: qb,
    _fnScrollDraw: ka,
    _fnApplyToChildren: H,
    _fnCalculateColumnWidths: Ea,
    _fnThrottle: Na,
    _fnConvertToWidth: Db,
    _fnGetWidestNode: Eb,
    _fnGetMaxLenString: Fb,
    _fnStringToCss: v,
    _fnSortFlatten: V,
    _fnSort: lb,
    _fnSortAria: Hb,
    _fnSortListener: Ua,
    _fnSortAttachListener: La,
    _fnSortingClasses: wa,
    _fnSortData: Gb,
    _fnSaveState: xa,
    _fnLoadState: Ib,
    _fnSettingsFromNode: ya,
    _fnLog: J,
    _fnMap: F,
    _fnBindAction: Va,
    _fnCallbackReg: z,
    _fnCallbackFire: r,
    _fnLengthOverflow: Ra,
    _fnRenderer: Ma,
    _fnDataSource: y,
    _fnRowAttributes: Ka,
    _fnCalculateEnd: function() {}
  });
  h.fn.dataTable = m;
  m.$ = h;
  h.fn.dataTableSettings = m.settings;
  h.fn.dataTableExt = m.ext;
  h.fn.DataTable = function(a) {
    return h(this)
      .dataTable(a)
      .api();
  };
  h.each(m, function(a, b) {
    h.fn.DataTable[a] = b;
  });
  return h.fn.dataTable;
});

/*!
 FixedHeader 3.1.3
 2009-2017 SpryMedia Ltd - datatables.net/license
*/
(function(d) {
  "function" === typeof define && define.amd
    ? define(["jquery", "datatables.net"], function(g) {
        return d(g, window, document);
      })
    : "object" === typeof exports
      ? (module.exports = function(g, h) {
          g || (g = window);
          if (!h || !h.fn.dataTable) h = require("datatables.net")(g, h).$;
          return d(h, g, g.document);
        })
      : d(jQuery, window, document);
})(function(d, g, h, k) {
  var j = d.fn.dataTable,
    l = 0,
    i = function(b, a) {
      if (!(this instanceof i))
        throw "FixedHeader must be initialised with the 'new' keyword.";
      !0 === a && (a = {});
      b = new j.Api(b);
      this.c = d.extend(!0, {}, i.defaults, a);
      this.s = {
        dt: b,
        position: {
          theadTop: 0,
          tbodyTop: 0,
          tfootTop: 0,
          tfootBottom: 0,
          width: 0,
          left: 0,
          tfootHeight: 0,
          theadHeight: 0,
          windowHeight: d(g).height(),
          visible: !0
        },
        headerMode: null,
        footerMode: null,
        autoWidth: b.settings()[0].oFeatures.bAutoWidth,
        namespace: ".dtfc" + l++,
        scrollLeft: { header: -1, footer: -1 },
        enable: !0
      };
      this.dom = {
        floatingHeader: null,
        thead: d(b.table().header()),
        tbody: d(b.table().body()),
        tfoot: d(b.table().footer()),
        header: { host: null, floating: null, placeholder: null },
        footer: {
          host: null,
          floating: null,
          placeholder: null
        }
      };
      this.dom.header.host = this.dom.thead.parent();
      this.dom.footer.host = this.dom.tfoot.parent();
      var e = b.settings()[0];
      if (e._fixedHeader)
        throw "FixedHeader already initialised on table " + e.nTable.id;
      e._fixedHeader = this;
      this._constructor();
    };
  d.extend(i.prototype, {
    enable: function(b) {
      this.s.enable = b;
      this.c.header && this._modeChange("in-place", "header", !0);
      this.c.footer &&
        this.dom.tfoot.length &&
        this._modeChange("in-place", "footer", !0);
      this.update();
    },
    headerOffset: function(b) {
      b !== k && ((this.c.headerOffset = b), this.update());
      return this.c.headerOffset;
    },
    footerOffset: function(b) {
      b !== k && ((this.c.footerOffset = b), this.update());
      return this.c.footerOffset;
    },
    update: function() {
      this._positions();
      this._scroll(!0);
    },
    _constructor: function() {
      var b = this,
        a = this.s.dt;
      d(g)
        .on("scroll" + this.s.namespace, function() {
          b._scroll();
        })
        .on("resize" + this.s.namespace, function() {
          b.s.position.windowHeight = d(g).height();
          b.update();
        });
      var e = d(".fh-fixedHeader");
      !this.c.headerOffset &&
        e.length &&
        (this.c.headerOffset = e.outerHeight());
      e = d(".fh-fixedFooter");
      !this.c.footerOffset &&
        e.length &&
        (this.c.footerOffset = e.outerHeight());
      a.on(
        "column-reorder.dt.dtfc column-visibility.dt.dtfc draw.dt.dtfc column-sizing.dt.dtfc",
        function() {
          b.update();
        }
      );
      a.on("destroy.dtfc", function() {
        a.off(".dtfc");
        d(g).off(b.s.namespace);
      });
      this._positions();
      this._scroll();
    },
    _clone: function(b, a) {
      var e = this.s.dt,
        c = this.dom[b],
        f = "header" === b ? this.dom.thead : this.dom.tfoot;
      !a && c.floating
        ? c.floating.removeClass("fixedHeader-floating fixedHeader-locked")
        : (c.floating &&
            (c.placeholder.remove(),
            this._unsize(b),
            c.floating.children().detach(),
            c.floating.remove()),
          (c.floating = d(
            e
              .table()
              .node()
              .cloneNode(!1)
          )
            .css("table-layout", "fixed")
            .removeAttr("id")
            .append(f)
            .appendTo("body")),
          (c.placeholder = f.clone(!1)),
          c.placeholder.find("*[id]").removeAttr("id"),
          c.host.prepend(c.placeholder),
          this._matchWidths(c.placeholder, c.floating));
    },
    _matchWidths: function(b, a) {
      var e = function(a) {
          return d(a, b)
            .map(function() {
              return d(this).width();
            })
            .toArray();
        },
        c = function(b, c) {
          d(b, a).each(function(a) {
            d(this).css({
              width: c[a],
              minWidth: c[a]
            });
          });
        },
        f = e("th"),
        e = e("td");
      c("th", f);
      c("td", e);
    },
    _unsize: function(b) {
      var a = this.dom[b].floating;
      a && ("footer" === b || ("header" === b && !this.s.autoWidth))
        ? d("th, td", a).css({ width: "", minWidth: "" })
        : a && "header" === b && d("th, td", a).css("min-width", "");
    },
    _horizontal: function(b, a) {
      var e = this.dom[b],
        c = this.s.position,
        d = this.s.scrollLeft;
      e.floating &&
        d[b] !== a &&
        (e.floating.css("left", c.left - a), (d[b] = a));
    },
    _modeChange: function(b, a, e) {
      var c = this.dom[a],
        f = this.s.position,
        g = d.contains(
          this.dom["footer" === a ? "tfoot" : "thead"][0],
          h.activeElement
        )
          ? h.activeElement
          : null;
      if ("in-place" === b) {
        if (
          (c.placeholder && (c.placeholder.remove(), (c.placeholder = null)),
          this._unsize(a),
          "header" === a
            ? c.host.prepend(this.dom.thead)
            : c.host.append(this.dom.tfoot),
          c.floating)
        )
          c.floating.remove(), (c.floating = null);
      } else
        "in" === b
          ? (this._clone(a, e),
            c.floating
              .addClass("fixedHeader-floating")
              .css("header" === a ? "top" : "bottom", this.c[a + "Offset"])
              .css("left", f.left + "px")
              .css("width", f.width + "px"),
            "footer" === a && c.floating.css("top", ""))
          : "below" === b
            ? (this._clone(a, e),
              c.floating
                .addClass("fixedHeader-locked")
                .css("top", f.tfootTop - f.theadHeight)
                .css("left", f.left + "px")
                .css("width", f.width + "px"))
            : "above" === b &&
              (this._clone(a, e),
              c.floating
                .addClass("fixedHeader-locked")
                .css("top", f.tbodyTop)
                .css("left", f.left + "px")
                .css("width", f.width + "px"));
      g && g !== h.activeElement && g.focus();
      this.s.scrollLeft.header = -1;
      this.s.scrollLeft.footer = -1;
      this.s[a + "Mode"] = b;
    },
    _positions: function() {
      var b = this.s.dt.table(),
        a = this.s.position,
        e = this.dom,
        b = d(b.node()),
        c = b.children("thead"),
        f = b.children("tfoot"),
        e = e.tbody;
      a.visible = b.is(":visible");
      a.width = b.outerWidth();
      a.left = b.offset().left;
      a.theadTop = c.offset().top;
      a.tbodyTop = e.offset().top;
      a.theadHeight = a.tbodyTop - a.theadTop;
      f.length
        ? ((a.tfootTop = f.offset().top),
          (a.tfootBottom = a.tfootTop + f.outerHeight()),
          (a.tfootHeight = a.tfootBottom - a.tfootTop))
        : ((a.tfootTop = a.tbodyTop + e.outerHeight()),
          (a.tfootBottom = a.tfootTop),
          (a.tfootHeight = a.tfootTop));
    },
    _scroll: function(b) {
      var a = d(h).scrollTop(),
        e = d(h).scrollLeft(),
        c = this.s.position,
        f;
      if (
        this.s.enable &&
        (this.c.header &&
          ((f =
            !c.visible || a <= c.theadTop - this.c.headerOffset
              ? "in-place"
              : a <= c.tfootTop - c.theadHeight - this.c.headerOffset
                ? "in"
                : "below"),
          (b || f !== this.s.headerMode) && this._modeChange(f, "header", b),
          this._horizontal("header", e)),
        this.c.footer && this.dom.tfoot.length)
      )
        (a =
          !c.visible ||
          a + c.windowHeight >= c.tfootBottom + this.c.footerOffset
            ? "in-place"
            : c.windowHeight + a >
              c.tbodyTop + c.tfootHeight + this.c.footerOffset
              ? "in"
              : "above"),
          (b || a !== this.s.footerMode) && this._modeChange(a, "footer", b),
          this._horizontal("footer", e);
    }
  });
  i.version = "3.1.3";
  i.defaults = { header: !0, footer: !1, headerOffset: 0, footerOffset: 0 };
  d.fn.dataTable.FixedHeader = i;
  d.fn.DataTable.FixedHeader = i;
  d(h).on("init.dt.dtfh", function(b, a) {
    if ("dt" === b.namespace) {
      var e = a.oInit.fixedHeader,
        c = j.defaults.fixedHeader;
      if ((e || c) && !a._fixedHeader)
        (c = d.extend({}, c, e)), !1 !== e && new i(a, c);
    }
  });
  j.Api.register("fixedHeader()", function() {});
  j.Api.register("fixedHeader.adjust()", function() {
    return this.iterator("table", function(b) {
      (b = b._fixedHeader) && b.update();
    });
  });
  j.Api.register("fixedHeader.enable()", function(b) {
    return this.iterator("table", function(a) {
      a = a._fixedHeader;
      b = b !== k ? b : !0;
      a && b !== a.s.enable && a.enable(b);
    });
  });
  j.Api.register("fixedHeader.disable()", function() {
    return this.iterator("table", function(b) {
      (b = b._fixedHeader) && b.s.enable && b.enable(!1);
    });
  });
  d.each(["header", "footer"], function(b, a) {
    j.Api.register("fixedHeader." + a + "Offset()", function(b) {
      var c = this.context;
      return b === k
        ? c.length && c[0]._fixedHeader ? c[0]._fixedHeader[a + "Offset"]() : k
        : this.iterator("table", function(c) {
            if ((c = c._fixedHeader)) c[a + "Offset"](b);
          });
    });
  });
  return i;
});

$(document).on('ready', function() {
	var parentClass=null;
	/*on click of next arrow*/
	$('.slide-wrap .slick-next').on('click',function(){
		parentClass=null;
		if ($(this).parents('.availableExtras').length){
			parentClass=".availableExtras";
		}
		if ($(this).parents('.product-feature').length){
			parentClass=".product-feature";
		}
		if($(parentClass).find('.slick-dots').css("display") == "block"){
			if($(parentClass).find('.slick-dots li')[0]!=undefined && $(parentClass).find('.slick-dots li')[0].className==""){
				$(parentClass).find('.slick-prev').css('background','url("/etc/designs/sparkdigital/clientlib-site/img/slider-ar-lt-active1.png") no-repeat')
			}
			if($(parentClass).find('.slick-dots li')[0]!=undefined && $(parentClass).find('.slick-dots li')[0].className=="slick-active"){
				$(parentClass).find('.slick-prev').css('background','url("/etc/designs/sparkdigital/clientlib-site/img/slider-ar-lt1.png") no-repeat')
			}
		}
	}); 
	/*on click of previous arrow*/
	$('.slide-wrap .slick-prev').on('click',function(){
		parentClass=null;
		if ($(this).parents('.availableExtras').length){
			parentClass=".availableExtras";
		}
		if ($(this).parents('.product-feature').length){
			parentClass=".product-feature";
		}
		if($(parentClass).find('.slick-dots').css("display") == "block"){
			if($(parentClass).find('.slick-dots li')[0]!=undefined && $(parentClass).find('.slick-dots li')[0].className==""){
				$(parentClass).find('.slick-prev').css('background','url("/etc/designs/sparkdigital/clientlib-site/img/slider-ar-lt-active1.png") no-repeat')
			}
			 
			if($(parentClass).find('.slick-dots li')[0]!=undefined && $(parentClass).find('.slick-dots li')[0].className=="slick-active"){
				$(parentClass).find('.slick-prev').css('background','url("/etc/designs/sparkdigital/clientlib-site/img/slider-ar-lt1.png") no-repeat')
			}
		}
	});
	/*on click of each dot*/
	$('.slick-dots li').on('click',function(){
		parentClass=null;
		if ($(this).parents('.availableExtras').length){
			parentClass=".availableExtras";
		}
		if ($(this).parents('.product-feature').length){
			parentClass=".product-feature";
		}
		
		if($(parentClass).find('.slick-dots li')[0]!=undefined && $(parentClass).find('.slick-dots li')[0].className=="")
		{
			$(parentClass).find('.slick-prev').css('background','url("/etc/designs/sparkdigital/clientlib-site/img/slider-ar-lt-active1.png") no-repeat');
			
		}
		if($(parentClass).find('.slick-dots li')[0]!=undefined && $(parentClass).find('.slick-dots li')[0].className=="slick-active"){
			$(parentClass).find('.slick-prev').css('background','url("/etc/designs/sparkdigital/clientlib-site/img/slider-ar-lt1.png") no-repeat');
		}
	});
});

function fnOpenPopUpWindow(id,authormode){
	var authorMode = $("."+authormode).val();
	if(authorMode=="true") {
		var src = $("#"+id+"-src").val();
		src = src+'.html';
	}else {
		var src = $("#"+id+"-src").val();
		src = src.replace('.html',''); 	
	}
	
	$('body').prepend(	
    $('<div/>',
		{'class': 'modal fade cust-pop-sd','id':id,'role':'dialog'}).append(
			$('<div/>',
				{'class': 'modal-dialog container'}).append(
					$('<div/>',
						{'class': 'modal-content','style':'border-radius:0px'}).append(
							$('<div/>',{'class':'modal-header'}).append(
								$('<button/>',{'id':'contactus-form-close-btn','class':'close','type':'button','data-dismiss':'modal','html':'<i class="icon-close"></i>'})
							)
						).append(
							$('<iframe/>',
								{'src':src,'width':'100%'}
							)
						)
				)
		)
	)
}

// makes sure touch devices can open up the mega menu on first click
// and second click goes to the link
$(document).on('click', '#hmb-header.visible-md.visible-lg .site-menubar > .nav-list > li > a', function(e) {
    if ('ontouchstart' in window) {
        if ($(this).next('.subnav-list').length > 0) {
            if ($(this).next('.subnav-list').css('opacity') == '0') {
                e.preventDefault();
            }
        }
    }
});
$(document).on('touchend', '#hmb-header.visible-md.visible-lg .secondnavigationbar > .secondnavigationbar-body > ul > li > a', function(e) {
    if ($(this).next('.second-subnav').length > 0) {
        if (!$(this).closest('.secondnavigationbar-body-link').hasClass('focused')) {
            e.preventDefault();
            $(this).focus();
        }
    }
});
$(document).ready(function() {
	//invoke click function on the preselected color and memory variant - during device gallery page load
	$('.device-details').find('div.color-selection fieldset.active input[type="radio"]').click();
    $('.device-details').find('div.storage-selection input[type="radio"].preselectedMemoryVariant').click();
    hideBuyNowButton();
});

function hideBuyNowButton() {
    if ($('.devicedetail .device-detail-container').length) {
        if ($("#sd-pre-order") != undefined && $("#sd-pre-order").length) {
            $("#sd-buy-now").hide();
        } else {
            $("#sd-buy-now").show();
        }
    }
}

function getSelectedDeviceImages() {
    var color = "";
    var device = "";
    var deviceType = "";
    if ($("input[name=device-color]").val() != undefined) {
        color = $("input[name=device-color]").val().toLocaleLowerCase();
    }
    if ($("input[name=device-name]").val() != undefined) {
        device = $("input[name=device-name]").val().toLocaleLowerCase();
    }
    if ($("input[name=device-color]").val() != undefined) {
        deviceType = window.location.href;  
    }
  

    var data = {
        "path": "/content/dam/sparkdigital/images/mobility/devices/",
        "color": color,
        "device": device,
        "devicetype": deviceType,
    };
    if ($('.device-details-for').length) {
    sendAjaxReq(data);
    }
}  

function renderResponce(data) {

    var deviceImages = createImageSlider(data.images);
    if (undefined != deviceImages)
        $('.device-details-for').html(deviceImages);

    var thumbImages = createImageSlider(data.thumb);
    if (undefined != thumbImages)
        $('.device-details-nav').html(thumbImages);

    $('.device-details-for').removeClass("slick-initialized slick-slider");
    $('.device-details-nav').removeClass("slick-initialized slick-slider");

    initSlick();

}

function sendAjaxReq(data) {

    $.ajax({
        url: '/bin/sparkdigital/imagegallery',
        data: data,
        dataType: 'json',
        type: "GET",
        contentType: "application/json;charset=utf-8",
        beforeSend: function() {

        },
        success: function(returnData) {
            if (undefined != returnData.images && undefined != returnData.thumb) {
                renderResponce(returnData);
            }
        },
        error: function(xhr, ajaxOptions, thrownError) {
        },
        complete: function() {
        }
    });

}

function initSlick() {

    $('.device-details-for').slick({
        slidesToShow: 1,
        slidesToScroll: 1,
        arrows: true,
        fade: true,
        asNavFor: '.device-details-nav',
        resize: true,
        swipe: true
    }); 

    $('.device-details-nav').slick({
        slidesToShow: 4,
        slidesToScroll: 1,
        asNavFor: '.device-details-for',
        dots: true,
        centerMode: true,
        focusOnSelect: true,
        resize: true,
        swipe: true
    });

    $('.device-details-for').resize();
    $('.device-details-nav .area-block.slick-slide').css('width', '70px !important');
    $('.device-details-nav .slick-list.draggable .slick-track').addClass('drag-left').css('width', '320px !important');
}

function createImageSlider(images) {

    var imageSlider = "";
    var isThumb = false;
    if (images.length != 0) {
        for (var i = 0, len = images.length; i < len; ++i) {
            imageSlider += '<div class="area-block"><img src="' + images[i] + '" alt="image' + i + '" /> </div>';
        }

    }
    return imageSlider;
}

function loadselectedColorImages(color) {
    if ($('.device-gallery').length || $('.device-detail-container').length || $('.device-compare').length) {
        var deviceName;
        var deviceType;
        if ($("input[name=device-name]").val() != undefined) {
            deviceName = $("input[name=device-name]").val().toLocaleLowerCase();
        }
        if ($("input[name=device-color]").val() != undefined) {
            deviceType = window.location.href;
        }

        var data = {
            "path" : "/content/dam/sparkdigital/images/mobility/devices/",
            "color" : color,
            "device" : deviceName,
            "devicetype" : deviceType,
        };
        if ($('.device-details-for').length) {
            sendAjaxReq(data);
        }
    }
}

(function() {
if ($('.device-gallery').length || $('.device-detail-container').length || $('.device-compare').length) { 

    getSelectedDeviceImages();
    initSlick();

    $('input[name="devicecolor"]').change(function() {
        $('.prefer-select').show();
        $('.prefer-remove').hide();
        $('input[name="devicecolor"]').each(function() {
            $(this).attr("checked", false);
           // $(this).next().css("border", "none");
        });
        $(this).attr("checked", true);
        //$(this).next().css("border", "2px solid #149ee8");
    })
    $('input[name="devicestorage"]').change(function() {
        $('.prefer-select').show();
        $('.prefer-remove').hide(); 
    });    

    $('.btn-device-select').click(function() {
        $('.color-selection input[type="radio"]:checked + label').css('border', 'none');
        $('.storage-selection input[type="radio"]:checked + label').css('border', '1px solid #eee');
    });

    $('[data-toggle="popover"]').popover();

    $('.overlay-outer').on('click', '.storage-selection input[type="radio"] + label', function() {
        $('.storage-selection input[type="radio"] + label').removeClass('checked');
        $(this).toggleClass('checked');
    });

    $('.overlay-outer').on('click', '.color-selection input[type="radio"] + label', function() {
        $('.color-selection input[type="radio"] + label').removeClass('checked');
        $(this).toggleClass('checked');
    });

    $('.device-gallery').on('click', '.color-selection input[type="radio"] + label', function() {
        $('.color-selection input[type="radio"] + label').removeClass('checked');
        $(this).toggleClass('checked');
    });

    $('.device-gallery').on('click', '.btn-popup', function() {
        $(this).siblings('.overlay-outer').toggle();
        $(this).siblings('.overlay-outer').children('.device-selection-overlay').toggle();
        $(this).children('span.toggle-compare').toggle();
        $(this).children('span.toggle-close').toggle();
        $(this).siblings('.device-card-ribbon').toggle();
    });

    var mq = window.matchMedia("(max-width: 939px)");
    $('.btn-filter-search').on('click', function() {
        $('.search-holder').toggleClass('search-selection');
        $('.search-holder input').toggle();
        if (mq.matches) {
            $('.device-actions .filter, .device-actions .sort').toggle();
            //$('.device-actions .search').toggleClass('wd-100');
            $('.device-actions .search-holder').toggleClass('wd-100');
            $('.device-actions .device-search').toggleClass('wd-100');
        }

    });

    $(document).click(function() {
        $(".preference-wrap").hide();
        $('.btn-group-devices').removeClass('btn-filter-show');
        $('.btn-group-devices').removeClass('disable');
        $('.filter-default').removeAttr('disabled');
    });

    $('.filter-wrap input').on('change', function(e) {
        e.stopPropagation();
        $(this).parents(".preference-wrap").show();
    });

    $('.galleryFilter .filter .btn-group-devices').on('click', function(e) {
        e.stopPropagation();
        $(this).siblings(".preference-wrap").toggle();
        $('.galleryFilter .sort .filter-default').toggleClass('disable');
        $('.sort .filter-default').filter(function() {
            if ($('.disable')) {
                $('.sort .filter-default').attr('disabled', 'disabled');
            }
            if (!($('.sort .filter-default').hasClass('disable'))) {
                $('.sort .filter-default').removeAttr('disabled');
            }
        });
        $(this).toggleClass('btn-filter-show');
        $('.device-actions .filter .btn-group-devices .btn-text').toggleClass('test');
    });

    $('.galleryFilter .sort .btn-group-devices').on('click', function(e) {
        e.stopPropagation();
        $(this).siblings(".preference-wrap").toggle();
        $('.galleryFilter .filter .btn-group-devices').toggleClass('disable');
        $('.filter .filter-default').filter(function() {
            if ($('.disable')) {
                $('.filter .filter-default').attr('disabled', 'disabled');
            }
            if (!($('.filter .filter-default').hasClass('disable'))) {
                $('.filter .filter-default').removeAttr('disabled');
            }
        });
        $(this).toggleClass('btn-filter-show');
        $('.device-actions .sort .btn-group-devices .btn-text').toggleClass('test');
    });

    $('.btn-compare-panel').on('click', function() {
       // $('.toggle-hide').toggle();
       // $('.toggle-show').toggleClass('toggle-block');
       //   $(this).toggleClass('toggle-width');
        //  $('.compare-panel-container').toggle();
    });


    $('.overlay-inner').on('click', '.color-selection input[type="radio"] + label', function() {
        $('.color-selection input[type="radio"] + label').removeClass('checked');
        $(this).toggleClass('checked');
        $(this).parent().addClass('active');
        $(this).parent().siblings().removeClass('active');
        var color = $(this).find('span').html().trim().toLocaleLowerCase();
        loadselectedColorImages(color);
    });

    $('.device-gallery').on('click', '.color-selection input[type="radio"] + label', function() {
        $('.modal .color-selection input[type="radio"] + label').removeClass('checked');
        $(this).toggleClass('checked');

        var color = $(this).find('span').html().trim().toLocaleLowerCase();
        loadselectedColorImages(color);

    });

    //function to find the color which shd be preselected on page load
    if ($('.device-detail-response').val() != undefined) {
        var deviceDetailJsonString = $('.device-detail-response').val();

        var memoryTargets = [];
        if (typeof deviceDetailJsonString != undefined) {
            deviceDetailData = JSON.parse(deviceDetailJsonString);
            var prodReferences = deviceDetailData["productReferences"];
            var code = deviceDetailData["code"];
            var size = deviceDetailData["size"];
            for (var j = 0; j < (prodReferences).length; j++) {
                var target = prodReferences[j]["target"];
                memoryTargets.push(target);

            }
            
            //Find the prodRef(preselectedTarget) which shd be selected by default of page load 
            //using product/Code and product/size attributes of device-detail page hybris response 
            var memoryVariantsList = memoryTargets;
            var preselectedTarget = null;
            for (var i = 0; i < $(memoryVariantsList).length; i++) {
            	var memoryVariants = memoryVariantsList[i];
            	if(code == memoryVariants.code && size == memoryVariants.size){
            		preselectedTarget = memoryVariants;
            	}
            }
            
            //Add 'active' class for the device color which shd be preselected on page load
            $(".device-details-left input:radio[name=devicecolor]").each(function() {
                if (null !== preselectedTarget && $(this).val().toLowerCase() == preselectedTarget.productColour.name.toLowerCase()) {
                    $(this).parent().addClass('active');
                }
            })
        }
    }
    // on selection of color all memory varinats having that color will get displayed, 
    //by default the memory variant shd be preselected based on the product/Code and product/size attributes of device-detail page hybris response 
    $(".device-details-left input:radio[name=devicecolor]").on('click', function() {
        $("input:radio[name=devicecolor]").siblings('label').find('span').css('visibility', 'hidden');
        selectedColor = $(this).val();
        var selectedColorUndescore = $(this).val().replace(" ","_");       
        $(this).siblings('label').find('span').css('visibility', 'visible');
        var deviceDetailJsonString = $('.device-detail-response').val();
        var devicegProductRefData = [];
        var memoryTargets = [];
        if (typeof deviceDetailJsonString != undefined) {
            deviceDetailData = JSON.parse(deviceDetailJsonString);
            var prodReferences = deviceDetailData["productReferences"];
            var code = deviceDetailData["code"];
            var size = deviceDetailData["size"];
            for (var j = 0; j < (prodReferences).length; j++) {
                var target = prodReferences[j]["target"];
      
                if (target["productColour"].code.toLowerCase() == selectedColor.toLowerCase() || target["productColour"].code.toLowerCase() == selectedColorUndescore.toLowerCase()) {
                    memoryTargets.push(target);
                }
            }
        }
        $(".overlay-inner .storage-selection").html('');
        var memoryVariantsList = memoryTargets;
        memoryVariantsList.sort(function (a, b) {
        	var storage1 = parseInt(a.size);
        	var storage2 = parseInt(b.size);
        	
        	if(isNaN(storage1) || isNaN(storage2)){
        		return 0;
        	}
        	return storage1 - storage2;
        	
        });
        for (var i = 0; i < $(memoryVariantsList).length; i++) {
            var memoryVariant = memoryVariantsList[i];
            var memoryVariantSize = memoryVariant.size;
            if(typeof memoryVariantSize !="undefined") {
            	memoryVariantSize = memoryVariant.size;
            }
            else {
            	memoryVariantSize = '';
            }
            var gstExcluded =memoryVariant.gstExcluded;
            if(typeof gstExcluded != 'undefined') {
            	if(gstExcluded ==true) {
            		gstExcluded= 'excl GST';	
            	}
            	else {
            		gstExcluded= '';
            	}
            	
            }
           
            var memoryVariantFormattedPrice = memoryVariant.price.formattedValue;
            if(typeof memoryVariantFormattedPrice !='undefined') {
            	memoryVariantFormattedPrice = memoryVariant.price.formattedValue;
            }
            else {
            	memoryVariantFormattedPrice = '';
            }
            var memoryVariantProductColourCode = memoryVariant.productColour.code;
            if(typeof memoryVariantProductColourCode !='undefined') {
            	memoryVariantProductColourCode = memoryVariant.productColour.code;
            }
            else {
            	memoryVariantProductColourCode = '';
            }
            var memoryVariantCode = memoryVariant.code;  
            if(typeof memoryVariantCode !='undefined') {
            	memoryVariantCode = memoryVariant.code;
            }
            else {
            	memoryVariantCode = '';
            }
            var mempryVariantPrice;
            if(typeof mempryVariantPrice !='undefined') {
            	mempryVariantPrice = memoryVariant.price.value;
            }
            else {
            	mempryVariantPrice = '';
            }   
            if(memoryVariantSize !== ''){
            	var variant = $('<fieldset><input type="radio" class="storage-option device-storage' + i + '"value=' + memoryVariantSize + ' id="storage' + i + '" name="devicestorage">' +
                        '<label for="storage' + i + '"><span class="big-size">' + memoryVariantSize + ' </span><span class="small-size"></span><span class="detailpage-product-price"> ' + memoryVariantFormattedPrice + ' </span></br>' +
                        '<span style="font-size: 12px">'+gstExcluded+'</span></label><input type="hidden" value="' + memoryVariantProductColourCode + '" class="device-color-code" />' +
                        '<input type="hidden" value=' + memoryVariantCode + ' class="device-code" /> <input type="hidden" value=' + memoryVariantFormattedPrice + ' class="device-price" /></fieldset>');
             $(".overlay-inner .storage-selection").append(variant);

            }
            
        }  
        
        //Find the prodRef(preselectedTarget) which shd be selected by default of page load - using productCode and size of device-detail page hybris response
        var preselectedTarget = null;
        for (var i = 0; i < $(memoryVariantsList).length; i++) {
        	var memoryVariant = memoryVariantsList[i];
        	if(code == memoryVariant.code && size == memoryVariant.size){
        		preselectedTarget = memoryVariant;
        	}
        }
        //Add 'preselectedMemoraryVariant' class for the memory variant which shd be preselected on page load
        $(".device-details-left input:radio[name=devicestorage]").each(function() {
        	if(null !== preselectedTarget && $(this).val() == preselectedTarget.size){
                 $(this).addClass('preselectedMemoryVariant');
        	}
        });
    });
    
    //functionality for Tech-specs tab content changes on selection of memory variant
    $(document).on('click', '.device-details-left .storage-option', function() {

        $('.storage-option').each(function() {
            $(this).attr("checked", false);
           // $(this).next().css("border", "none");
            $(this).next().css("border", "1px solid #eee");
        });
        $(this).attr("checked", true);
        $(this).next().css("border", "2px solid #149ee8");
        var price = $(this).siblings('.device-price').val();
        $(".variant-price").text(price);
        var currentPage = $(".currentPageClass").val();
        var deviceCode =  $(this).siblings('.device-code').val();
        var data = {
            "path": currentPage,
            "deviceCode": deviceCode  
        };
        $.ajax({
            url: '/bin/sparkdigital/product/features',
            data: data,
            dataType: 'json',
            type: "POST",
            success: function(returnData) {
                if (returnData != undefined) {
                    $(".device-features").html("");
                    for (var i = 0; i < returnData.length; i++) {
                        var div = $("<label class='purple spec-category-title'>" + returnData[i].key + "</label>");
                        var row = $("<div class='row'></div>");
                        var classificationItem = returnData[i].value;
                        for (var j = 0; j < classificationItem.length; j++) {
                            var features = classificationItem[j].features;
                            var featuresAvailable = false;
                            for(var featureIndex = 0; featureIndex < features.length; featureIndex++){
                            	if(features[featureIndex].featureValues[0].value !== 'false'){
                            		featuresAvailable = true;
                            		break;
                            	}
                            }
                            if(featuresAvailable){
                            	 var title = $("<div class='col-xs-12 col-sm-6 col-lg-4'><strong class='spec-section-title'>" + classificationItem[j].name + "</strong><div>");
                                 if (features.length > 0) {
                                	 var appendFeatures = $("<ul>");
                                     for (var k = 0; k < features.length; k++) {
                                    	var featureItem = '';
                                     	if(features[k].featureValues[0].value !='true' && features[k].featureValues[0].value !='false' ) {
	                                     	if(typeof features[k].featureUnit !='undefined') {
	                                     		featureItem = $(" <li>" + features[k].featureValues[0].value + " "+features[k].featureUnit.symbol + " "+ features[k].name + "</li>");
	                                     	}
	                                     	else {
	                                             featureItem = $(" <li>" + features[k].featureValues[0].value +" "+ features[k].name + "</li>");
	                                     	}
                                     	}else {
                                     		if(features[k].featureValues[0].value =='true') {
                                                 featureItem = $(" <li>" + " "+ " "+ features[k].name + "</li>");
                                     		}
                                     	}
                                     	if(featureItem !== ''){
                                     		$(appendFeatures).append(featureItem);
                                     	}
                                     }
                                     $(appendFeatures).append("</ul>");
                                 }
                                 $(title).append(appendFeatures).append("</div></div>");
                                 $(row).append(title);
                            }
                           
                        }
                        $(".device-features").append(div).append(row);
                    }
                }
            },
            error: function(xhr, ajaxOptions, thrownError) {
            },
            complete: function() {
            }
        });
    });
}
})();  




(function(){
	
	function dynamicContentHeight(getHeight, setHeight){
		var $featureImg = getHeight.height();
		setHeight.height($featureImg);
		featureImg= null;
	}
	
	var mqVarArticleRef2 = window.matchMedia( "(min-width: 640px)" );
	if($(".ref-article-media").length){
		if (mqVarArticleRef2.matches) {
			$(".ref-article-media div a img").each(function (){
			var getHeightArticalRef = $(this);
			var setHeightArticalRef = $(this).parents(".reference-outer-wrap").children(".article-ref-data");
			dynamicContentHeight(getHeightArticalRef, setHeightArticalRef);
			});
		}
	}
	
})();
(function() {
  var MutationObserver, Util, WeakMap, getComputedStyle, getComputedStyleRX,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Util = (function() {
    function Util() {}

    Util.prototype.extend = function(custom, defaults) {
      var key, value;
      for (key in defaults) {
        value = defaults[key];
        if (custom[key] == null) {
          custom[key] = value;
        }
      }
      return custom;
    };

    Util.prototype.isMobile = function(agent) {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);
    };

    Util.prototype.createEvent = function(event, bubble, cancel, detail) {
      var customEvent;
      if (bubble == null) {
        bubble = false;
      }
      if (cancel == null) {
        cancel = false;
      }
      if (detail == null) {
        detail = null;
      }
      if (document.createEvent != null) {
        customEvent = document.createEvent('CustomEvent');
        customEvent.initCustomEvent(event, bubble, cancel, detail);
      } else if (document.createEventObject != null) {
        customEvent = document.createEventObject();
        customEvent.eventType = event;
      } else {
        customEvent.eventName = event;
      }
      return customEvent;
    };

    Util.prototype.emitEvent = function(elem, event) {
      if (elem.dispatchEvent != null) {
        return elem.dispatchEvent(event);
      } else if (event in (elem != null)) {
        return elem[event]();
      } else if (("on" + event) in (elem != null)) {
        return elem["on" + event]();
      }
    };

    Util.prototype.addEvent = function(elem, event, fn) {
      if (elem.addEventListener != null) {
        return elem.addEventListener(event, fn, false);
      } else if (elem.attachEvent != null) {
        return elem.attachEvent("on" + event, fn);
      } else {
        return elem[event] = fn;
      }
    };

    Util.prototype.removeEvent = function(elem, event, fn) {
      if (elem.removeEventListener != null) {
        return elem.removeEventListener(event, fn, false);
      } else if (elem.detachEvent != null) {
        return elem.detachEvent("on" + event, fn);
      } else {
        return delete elem[event];
      }
    };

    Util.prototype.innerHeight = function() {
      if ('innerHeight' in window) {
        return window.innerHeight;
      } else {
        return document.documentElement.clientHeight;
      }
    };

    return Util;

  })();

  WeakMap = this.WeakMap || this.MozWeakMap || (WeakMap = (function() {
    function WeakMap() {
      this.keys = [];
      this.values = [];
    }

    WeakMap.prototype.get = function(key) {
      var i, item, j, len, ref;
      ref = this.keys;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        if (item === key) {
          return this.values[i];
        }
      }
    };

    WeakMap.prototype.set = function(key, value) {
      var i, item, j, len, ref;
      ref = this.keys;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        if (item === key) {
          this.values[i] = value;
          return;
        }
      }
      this.keys.push(key);
      return this.values.push(value);
    };

    return WeakMap;

  })());

  MutationObserver = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (MutationObserver = (function() {
    function MutationObserver() {
      if (typeof console !== "undefined" && console !== null) {
        console.warn('MutationObserver is not supported by your browser.');
      }
      if (typeof console !== "undefined" && console !== null) {
        console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.');
      }
    }

    MutationObserver.notSupported = true;

    MutationObserver.prototype.observe = function() {};

    return MutationObserver;

  })());

  getComputedStyle = this.getComputedStyle || function(el, pseudo) {
    this.getPropertyValue = function(prop) {
      var ref;
      if (prop === 'float') {
        prop = 'styleFloat';
      }
      if (getComputedStyleRX.test(prop)) {
        prop.replace(getComputedStyleRX, function(_, _char) {
          return _char.toUpperCase();
        });
      }
      return ((ref = el.currentStyle) != null ? ref[prop] : void 0) || null;
    };
    return this;
  };

  getComputedStyleRX = /(\-([a-z]){1})/g;

  this.WOW = (function() {
    WOW.prototype.defaults = {
      boxClass: 'wow',
      animateClass: 'animated',
      offset: 0,
      mobile: true,
      live: true,
      callback: null,
      scrollContainer: null
    };

    function WOW(options) {
      if (options == null) {
        options = {};
      }
      this.scrollCallback = bind(this.scrollCallback, this);
      this.scrollHandler = bind(this.scrollHandler, this);
      this.resetAnimation = bind(this.resetAnimation, this);
      this.start = bind(this.start, this);
      this.scrolled = true;
      this.config = this.util().extend(options, this.defaults);
      if (options.scrollContainer != null) {
        this.config.scrollContainer = document.querySelector(options.scrollContainer);
      }
      this.animationNameCache = new WeakMap();
      this.wowEvent = this.util().createEvent(this.config.boxClass);
    }

    WOW.prototype.init = function() {
      var ref;
      this.element = window.document.documentElement;
      if ((ref = document.readyState) === "interactive" || ref === "complete") {
        this.start();
      } else {
        this.util().addEvent(document, 'DOMContentLoaded', this.start);
      }
      return this.finished = [];
    };

    WOW.prototype.start = function() {
      var box, j, len, ref;
      this.stopped = false;
      this.boxes = (function() {
        var j, len, ref, results;
        ref = this.element.querySelectorAll("." + this.config.boxClass);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          box = ref[j];
          results.push(box);
        }
        return results;
      }).call(this);
      this.all = (function() {
        var j, len, ref, results;
        ref = this.boxes;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          box = ref[j];
          results.push(box);
        }
        return results;
      }).call(this);
      if (this.boxes.length) {
        if (this.disabled()) {
          this.resetStyle();
        } else {
          ref = this.boxes;
          for (j = 0, len = ref.length; j < len; j++) {
            box = ref[j];
            this.applyStyle(box, true);
          }
        }
      }
      if (!this.disabled()) {
        this.util().addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);
        this.util().addEvent(window, 'resize', this.scrollHandler);
        this.interval = setInterval(this.scrollCallback, 50);
      }
      if (this.config.live) {
        return new MutationObserver((function(_this) {
          return function(records) {
            var k, len1, node, record, results;
            results = [];
            for (k = 0, len1 = records.length; k < len1; k++) {
              record = records[k];
              results.push((function() {
                var l, len2, ref1, results1;
                ref1 = record.addedNodes || [];
                results1 = [];
                for (l = 0, len2 = ref1.length; l < len2; l++) {
                  node = ref1[l];
                  results1.push(this.doSync(node));
                }
                return results1;
              }).call(_this));
            }
            return results;
          };
        })(this)).observe(document.body, {
          childList: true,
          subtree: true
        });
      }
    };

    WOW.prototype.stop = function() {
      this.stopped = true;
      this.util().removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);
      this.util().removeEvent(window, 'resize', this.scrollHandler);
      if (this.interval != null) {
        return clearInterval(this.interval);
      }
    };

    WOW.prototype.sync = function(element) {
      if (MutationObserver.notSupported) {
        return this.doSync(this.element);
      }
    };

    WOW.prototype.doSync = function(element) {
      var box, j, len, ref, results;
      if (element == null) {
        element = this.element;
      }
      if (element.nodeType !== 1) {
        return;
      }
      element = element.parentNode || element;
      ref = element.querySelectorAll("." + this.config.boxClass);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        box = ref[j];
        if (indexOf.call(this.all, box) < 0) {
          this.boxes.push(box);
          this.all.push(box);
          if (this.stopped || this.disabled()) {
            this.resetStyle();
          } else {
            this.applyStyle(box, true);
          }
          results.push(this.scrolled = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    WOW.prototype.show = function(box) {
      this.applyStyle(box);
      box.className = box.className + " " + this.config.animateClass;
      if (this.config.callback != null) {
        this.config.callback(box);
      }
      this.util().emitEvent(box, this.wowEvent);
      this.util().addEvent(box, 'animationend', this.resetAnimation);
      this.util().addEvent(box, 'oanimationend', this.resetAnimation);
      this.util().addEvent(box, 'webkitAnimationEnd', this.resetAnimation);
      this.util().addEvent(box, 'MSAnimationEnd', this.resetAnimation);
      return box;
    };

    WOW.prototype.applyStyle = function(box, hidden) {
      var delay, duration, iteration;
      duration = box.getAttribute('data-wow-duration');
      delay = box.getAttribute('data-wow-delay');
      iteration = box.getAttribute('data-wow-iteration');
      return this.animate((function(_this) {
        return function() {
          return _this.customStyle(box, hidden, duration, delay, iteration);
        };
      })(this));
    };

    WOW.prototype.animate = (function() {
      if ('requestAnimationFrame' in window) {
        return function(callback) {
          return window.requestAnimationFrame(callback);
        };
      } else {
        return function(callback) {
          return callback();
        };
      }
    })();

    WOW.prototype.resetStyle = function() {
      var box, j, len, ref, results;
      ref = this.boxes;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        box = ref[j];
        results.push(box.style.visibility = 'visible');
      }
      return results;
    };

    WOW.prototype.resetAnimation = function(event) {
      var target;
      if (event.type.toLowerCase().indexOf('animationend') >= 0) {
        target = event.target || event.srcElement;
        return target.className = target.className.replace(this.config.animateClass, '').trim();
      }
    };

    WOW.prototype.customStyle = function(box, hidden, duration, delay, iteration) {
      if (hidden) {
        this.cacheAnimationName(box);
      }
      box.style.visibility = hidden ? 'hidden' : 'visible';
      if (duration) {
        this.vendorSet(box.style, {
          animationDuration: duration
        });
      }
      if (delay) {
        this.vendorSet(box.style, {
          animationDelay: delay
        });
      }
      if (iteration) {
        this.vendorSet(box.style, {
          animationIterationCount: iteration
        });
      }
      this.vendorSet(box.style, {
        animationName: hidden ? 'none' : this.cachedAnimationName(box)
      });
      return box;
    };

    WOW.prototype.vendors = ["moz", "webkit"];

    WOW.prototype.vendorSet = function(elem, properties) {
      var name, results, value, vendor;
      results = [];
      for (name in properties) {
        value = properties[name];
        elem["" + name] = value;
        results.push((function() {
          var j, len, ref, results1;
          ref = this.vendors;
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            vendor = ref[j];
            results1.push(elem["" + vendor + (name.charAt(0).toUpperCase()) + (name.substr(1))] = value);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    WOW.prototype.vendorCSS = function(elem, property) {
      var j, len, ref, result, style, vendor;
      style = getComputedStyle(elem);
      result = style.getPropertyCSSValue(property);
      ref = this.vendors;
      for (j = 0, len = ref.length; j < len; j++) {
        vendor = ref[j];
        result = result || style.getPropertyCSSValue("-" + vendor + "-" + property);
      }
      return result;
    };

    WOW.prototype.animationName = function(box) {
      var animationName, error;
      try {
        animationName = this.vendorCSS(box, 'animation-name').cssText;
      } catch (error) {
        animationName = getComputedStyle(box).getPropertyValue('animation-name');
      }
      if (animationName === 'none') {
        return '';
      } else {
        return animationName;
      }
    };

    WOW.prototype.cacheAnimationName = function(box) {
      return this.animationNameCache.set(box, this.animationName(box));
    };

    WOW.prototype.cachedAnimationName = function(box) {
      return this.animationNameCache.get(box);
    };

    WOW.prototype.scrollHandler = function() {
      return this.scrolled = true;
    };

    WOW.prototype.scrollCallback = function() {
      var box;
      if (this.scrolled) {
        this.scrolled = false;
        this.boxes = (function() {
          var j, len, ref, results;
          ref = this.boxes;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            box = ref[j];
            if (!(box)) {
              continue;
            }
            if (this.isVisible(box)) {
              this.show(box);
              continue;
            }
            results.push(box);
          }
          return results;
        }).call(this);
        if (!(this.boxes.length || this.config.live)) {
          return this.stop();
        }
      }
    };

    WOW.prototype.offsetTop = function(element) {
      var top;
      while (element.offsetTop === void 0) {
        element = element.parentNode;
      }
      top = element.offsetTop;
      while (element = element.offsetParent) {
        top += element.offsetTop;
      }
      return top;
    };

    WOW.prototype.isVisible = function(box) {
      var bottom, offset, top, viewBottom, viewTop;
      offset = box.getAttribute('data-wow-offset') || this.config.offset;
      viewTop = (this.config.scrollContainer && this.config.scrollContainer.scrollTop) || window.pageYOffset;
      viewBottom = viewTop + Math.min(this.element.clientHeight, this.util().innerHeight()) - offset;
      top = this.offsetTop(box);
      bottom = top + box.clientHeight;
      return top <= viewBottom && bottom >= viewTop;
    };

    WOW.prototype.util = function() {
      return this._util != null ? this._util : this._util = new Util();
    };

    WOW.prototype.disabled = function() {
      return !this.config.mobile && this.util().isMobile(navigator.userAgent);
    };

    return WOW;

  })();

}).call(this);

wow = new WOW(
  {
	animateClass: 'animated',
	offset:       200,
	callback:     function(box) {
	}
  }
);
wow.init();

/*!
 * jQuery Cookie Plugin v1.3
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2011, Klaus Hartl
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.opensource.org/licenses/GPL-2.0
 */
(function ($, document, undefined) {

  var pluses = /\+/g;

  function raw(s) {
    return s;
  }

  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  var config = $.cookie = function (key, value, options) {

    // write
    if (value !== undefined) {
      options = $.extend({}, config.defaults, options);

      if (value === null) {
        options.expires = -1;
      }

      if (typeof options.expires === 'number') {
        var days = options.expires, t = options.expires = new Date();
        t.setDate(t.getDate() + days);
      }

      value = config.json ? JSON.stringify(value) : String(value);

      return (document.cookie = [
        encodeURIComponent(key), '=', config.raw ? value : encodeURIComponent(value),
        options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
        options.path    ? '; path=' + options.path : '',
        options.domain  ? '; domain=' + options.domain : '',
        options.secure  ? '; secure' : ''
      ].join(''));
    }

    // read
    var decode = config.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, l = cookies.length; i < l; i++) {
      var parts = cookies[i].split('=');
      if (decode(parts.shift()) === key) {
        var cookie = decode(parts.join('='));
        return config.json ? JSON.parse(cookie) : cookie;
      }
    }

    return null;
  };

  config.defaults = {};

  $.removeCookie = function (key, options) {
    if ($.cookie(key) !== null) {
      $.cookie(key, null, options);
      return true;
    }
    return false;
  };

})(jQuery, document);
/*! jQuery Validation Plugin - v1.13.1 - 10/14/2014
 * http://jqueryvalidation.org/
 * Copyright (c) 2014 Jrn Zaefferer; Licensed MIT */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a(jQuery)}(function(a){a.extend(a.fn,{validate:function(b){if(!this.length)return void(b&&b.debug&&window.console&&console.warn("Nothing selected, can't validate, returning nothing."));var c=a.data(this[0],"validator");return c?c:(this.attr("novalidate","novalidate"),c=new a.validator(b,this[0]),a.data(this[0],"validator",c),c.settings.onsubmit&&(this.validateDelegate(":submit","click",function(b){c.settings.submitHandler&&(c.submitButton=b.target),a(b.target).hasClass("cancel")&&(c.cancelSubmit=!0),void 0!==a(b.target).attr("formnovalidate")&&(c.cancelSubmit=!0)}),this.submit(function(b){function d(){var d,e;return c.settings.submitHandler?(c.submitButton&&(d=a("<input type='hidden'/>").attr("name",c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)),e=c.settings.submitHandler.call(c,c.currentForm,b),c.submitButton&&d.remove(),void 0!==e?e:!1):!0}return c.settings.debug&&b.preventDefault(),c.cancelSubmit?(c.cancelSubmit=!1,d()):c.form()?c.pendingRequest?(c.formSubmitted=!0,!1):d():(c.focusInvalid(),!1)})),c)},valid:function(){var b,c;return a(this[0]).is("form")?b=this.validate().form():(b=!0,c=a(this[0].form).validate(),this.each(function(){b=c.element(this)&&b})),b},removeAttrs:function(b){var c={},d=this;return a.each(b.split(/\s/),function(a,b){c[b]=d.attr(b),d.removeAttr(b)}),c},rules:function(b,c){var d,e,f,g,h,i,j=this[0];if(b)switch(d=a.data(j.form,"validator").settings,e=d.rules,f=a.validator.staticRules(j),b){case"add":a.extend(f,a.validator.normalizeRule(c)),delete f.messages,e[j.name]=f,c.messages&&(d.messages[j.name]=a.extend(d.messages[j.name],c.messages));break;case"remove":return c?(i={},a.each(c.split(/\s/),function(b,c){i[c]=f[c],delete f[c],"required"===c&&a(j).removeAttr("aria-required")}),i):(delete e[j.name],f)}return g=a.validator.normalizeRules(a.extend({},a.validator.classRules(j),a.validator.attributeRules(j),a.validator.dataRules(j),a.validator.staticRules(j)),j),g.required&&(h=g.required,delete g.required,g=a.extend({required:h},g),a(j).attr("aria-required","true")),g.remote&&(h=g.remote,delete g.remote,g=a.extend(g,{remote:h})),g}}),a.extend(a.expr[":"],{blank:function(b){return!a.trim(""+a(b).val())},filled:function(b){return!!a.trim(""+a(b).val())},unchecked:function(b){return!a(b).prop("checked")}}),a.validator=function(b,c){this.settings=a.extend(!0,{},a.validator.defaults,b),this.currentForm=c,this.init()},a.validator.format=function(b,c){return 1===arguments.length?function(){var c=a.makeArray(arguments);return c.unshift(b),a.validator.format.apply(this,c)}:(arguments.length>2&&c.constructor!==Array&&(c=a.makeArray(arguments).slice(1)),c.constructor!==Array&&(c=[c]),a.each(c,function(a,c){b=b.replace(new RegExp("\\{"+a+"\\}","g"),function(){return c})}),b)},a.extend(a.validator,{defaults:{messages:{},groups:{},rules:{},errorClass:"error",validClass:"valid",errorElement:"label",focusCleanup:!1,focusInvalid:!0,errorContainer:a([]),errorLabelContainer:a([]),onsubmit:!0,ignore:":hidden",ignoreTitle:!1,onfocusin:function(a){this.lastActive=a,this.settings.focusCleanup&&(this.settings.unhighlight&&this.settings.unhighlight.call(this,a,this.settings.errorClass,this.settings.validClass),this.hideThese(this.errorsFor(a)))},onfocusout:function(a){this.checkable(a)||!(a.name in this.submitted)&&this.optional(a)||this.element(a)},onkeyup:function(a,b){(9!==b.which||""!==this.elementValue(a))&&(a.name in this.submitted||a===this.lastElement)&&this.element(a)},onclick:function(a){a.name in this.submitted?this.element(a):a.parentNode.name in this.submitted&&this.element(a.parentNode)},highlight:function(b,c,d){"radio"===b.type?this.findByName(b.name).addClass(c).removeClass(d):a(b).addClass(c).removeClass(d)},unhighlight:function(b,c,d){"radio"===b.type?this.findByName(b.name).removeClass(c).addClass(d):a(b).removeClass(c).addClass(d)}},setDefaults:function(b){a.extend(a.validator.defaults,b)},messages:{required:"This field is required.",remote:"Please fix this field.",email:"Please enter a valid email address.",url:"Please enter a valid URL.",date:"Please enter a valid date.",dateISO:"Please enter a valid date ( ISO ).",number:"Please enter a valid number.",digits:"Please enter only digits.",creditcard:"Please enter a valid credit card number.",equalTo:"Please enter the same value again.",maxlength:a.validator.format("Please enter no more than {0} characters."),minlength:a.validator.format("Please enter at least {0} characters."),rangelength:a.validator.format("Please enter a value between {0} and {1} characters long."),range:a.validator.format("Please enter a value between {0} and {1}."),max:a.validator.format("Please enter a value less than or equal to {0}."),min:a.validator.format("Please enter a value greater than or equal to {0}.")},autoCreateRanges:!1,prototype:{init:function(){function b(b){var c=a.data(this[0].form,"validator"),d="on"+b.type.replace(/^validate/,""),e=c.settings;e[d]&&!this.is(e.ignore)&&e[d].call(c,this[0],b)}this.labelContainer=a(this.settings.errorLabelContainer),this.errorContext=this.labelContainer.length&&this.labelContainer||a(this.currentForm),this.containers=a(this.settings.errorContainer).add(this.settings.errorLabelContainer),this.submitted={},this.valueCache={},this.pendingRequest=0,this.pending={},this.invalid={},this.reset();var c,d=this.groups={};a.each(this.settings.groups,function(b,c){"string"==typeof c&&(c=c.split(/\s/)),a.each(c,function(a,c){d[c]=b})}),c=this.settings.rules,a.each(c,function(b,d){c[b]=a.validator.normalizeRule(d)}),a(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox']","focusin focusout keyup",b).validateDelegate("select, option, [type='radio'], [type='checkbox']","click",b),this.settings.invalidHandler&&a(this.currentForm).bind("invalid-form.validate",this.settings.invalidHandler),a(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required","true")},form:function(){return this.checkForm(),a.extend(this.submitted,this.errorMap),this.invalid=a.extend({},this.errorMap),this.valid()||a(this.currentForm).triggerHandler("invalid-form",[this]),this.showErrors(),this.valid()},checkForm:function(){this.prepareForm();for(var a=0,b=this.currentElements=this.elements();b[a];a++)this.check(b[a]);return this.valid()},element:function(b){var c=this.clean(b),d=this.validationTargetFor(c),e=!0;return this.lastElement=d,void 0===d?delete this.invalid[c.name]:(this.prepareElement(d),this.currentElements=a(d),e=this.check(d)!==!1,e?delete this.invalid[d.name]:this.invalid[d.name]=!0),a(b).attr("aria-invalid",!e),this.numberOfInvalids()||(this.toHide=this.toHide.add(this.containers)),this.showErrors(),e},showErrors:function(b){if(b){a.extend(this.errorMap,b),this.errorList=[];for(var c in b)this.errorList.push({message:b[c],element:this.findByName(c)[0]});this.successList=a.grep(this.successList,function(a){return!(a.name in b)})}this.settings.showErrors?this.settings.showErrors.call(this,this.errorMap,this.errorList):this.defaultShowErrors()},resetForm:function(){a.fn.resetForm&&a(this.currentForm).resetForm(),this.submitted={},this.lastElement=null,this.prepareForm(),this.hideErrors(),this.elements().removeClass(this.settings.errorClass).removeData("previousValue").removeAttr("aria-invalid")},numberOfInvalids:function(){return this.objectLength(this.invalid)},objectLength:function(a){var b,c=0;for(b in a)c++;return c},hideErrors:function(){this.hideThese(this.toHide)},hideThese:function(a){a.not(this.containers).text(""),this.addWrapper(a).hide()},valid:function(){return 0===this.size()},size:function(){return this.errorList.length},focusInvalid:function(){if(this.settings.focusInvalid)try{a(this.findLastActive()||this.errorList.length&&this.errorList[0].element||[]).filter(":visible").focus().trigger("focusin")}catch(b){}},findLastActive:function(){var b=this.lastActive;return b&&1===a.grep(this.errorList,function(a){return a.element.name===b.name}).length&&b},elements:function(){var b=this,c={};return a(this.currentForm).find("input, select, textarea").not(":submit, :reset, :image, [disabled], [readonly]").not(this.settings.ignore).filter(function(){return!this.name&&b.settings.debug&&window.console&&console.error("%o has no name assigned",this),this.name in c||!b.objectLength(a(this).rules())?!1:(c[this.name]=!0,!0)})},clean:function(b){return a(b)[0]},errors:function(){var b=this.settings.errorClass.split(" ").join(".");return a(this.settings.errorElement+"."+b,this.errorContext)},reset:function(){this.successList=[],this.errorList=[],this.errorMap={},this.toShow=a([]),this.toHide=a([]),this.currentElements=a([])},prepareForm:function(){this.reset(),this.toHide=this.errors().add(this.containers)},prepareElement:function(a){this.reset(),this.toHide=this.errorsFor(a)},elementValue:function(b){var c,d=a(b),e=b.type;return"radio"===e||"checkbox"===e?a("input[name='"+b.name+"']:checked").val():"number"===e&&"undefined"!=typeof b.validity?b.validity.badInput?!1:d.val():(c=d.val(),"string"==typeof c?c.replace(/\r/g,""):c)},check:function(b){b=this.validationTargetFor(this.clean(b));var c,d,e,f=a(b).rules(),g=a.map(f,function(a,b){return b}).length,h=!1,i=this.elementValue(b);for(d in f){e={method:d,parameters:f[d]};try{if(c=a.validator.methods[d].call(this,i,b,e.parameters),"dependency-mismatch"===c&&1===g){h=!0;continue}if(h=!1,"pending"===c)return void(this.toHide=this.toHide.not(this.errorsFor(b)));if(!c)return this.formatAndAdd(b,e),!1}catch(j){throw this.settings.debug&&window.console&&console.log("Exception occurred when checking element "+b.id+", check the '"+e.method+"' method.",j),j}}if(!h)return this.objectLength(f)&&this.successList.push(b),!0},customDataMessage:function(b,c){return a(b).data("msg"+c.charAt(0).toUpperCase()+c.substring(1).toLowerCase())||a(b).data("msg")},customMessage:function(a,b){var c=this.settings.messages[a];return c&&(c.constructor===String?c:c[b])},findDefined:function(){for(var a=0;a<arguments.length;a++)if(void 0!==arguments[a])return arguments[a];return void 0},defaultMessage:function(b,c){return this.findDefined(this.customMessage(b.name,c),this.customDataMessage(b,c),!this.settings.ignoreTitle&&b.title||void 0,a.validator.messages[c],"<strong>Warning: No message defined for "+b.name+"</strong>")},formatAndAdd:function(b,c){var d=this.defaultMessage(b,c.method),e=/\$?\{(\d+)\}/g;"function"==typeof d?d=d.call(this,c.parameters,b):e.test(d)&&(d=a.validator.format(d.replace(e,"{$1}"),c.parameters)),this.errorList.push({message:d,element:b,method:c.method}),this.errorMap[b.name]=d,this.submitted[b.name]=d},addWrapper:function(a){return this.settings.wrapper&&(a=a.add(a.parent(this.settings.wrapper))),a},defaultShowErrors:function(){var a,b,c;for(a=0;this.errorList[a];a++)c=this.errorList[a],this.settings.highlight&&this.settings.highlight.call(this,c.element,this.settings.errorClass,this.settings.validClass),this.showLabel(c.element,c.message);if(this.errorList.length&&(this.toShow=this.toShow.add(this.containers)),this.settings.success)for(a=0;this.successList[a];a++)this.showLabel(this.successList[a]);if(this.settings.unhighlight)for(a=0,b=this.validElements();b[a];a++)this.settings.unhighlight.call(this,b[a],this.settings.errorClass,this.settings.validClass);this.toHide=this.toHide.not(this.toShow),this.hideErrors(),this.addWrapper(this.toShow).show()},validElements:function(){return this.currentElements.not(this.invalidElements())},invalidElements:function(){return a(this.errorList).map(function(){return this.element})},showLabel:function(b,c){var d,e,f,g=this.errorsFor(b),h=this.idOrName(b),i=a(b).attr("aria-describedby");g.length?(g.removeClass(this.settings.validClass).addClass(this.settings.errorClass),g.html(c)):(g=a("<"+this.settings.errorElement+">").attr("id",h+"-error").addClass(this.settings.errorClass).html(c||""),d=g,this.settings.wrapper&&(d=g.hide().show().wrap("<"+this.settings.wrapper+"/>").parent()),this.labelContainer.length?this.labelContainer.append(d):this.settings.errorPlacement?this.settings.errorPlacement(d,a(b)):d.insertAfter(b),g.is("label")?g.attr("for",h):0===g.parents("label[for='"+h+"']").length&&(f=g.attr("id").replace(/(:|\.|\[|\])/g,"\\$1"),i?i.match(new RegExp("\\b"+f+"\\b"))||(i+=" "+f):i=f,a(b).attr("aria-describedby",i),e=this.groups[b.name],e&&a.each(this.groups,function(b,c){c===e&&a("[name='"+b+"']",this.currentForm).attr("aria-describedby",g.attr("id"))}))),!c&&this.settings.success&&(g.text(""),"string"==typeof this.settings.success?g.addClass(this.settings.success):this.settings.success(g,b)),this.toShow=this.toShow.add(g)},errorsFor:function(b){var c=this.idOrName(b),d=a(b).attr("aria-describedby"),e="label[for='"+c+"'], label[for='"+c+"'] *";return d&&(e=e+", #"+d.replace(/\s+/g,", #")),this.errors().filter(e)},idOrName:function(a){return this.groups[a.name]||(this.checkable(a)?a.name:a.id||a.name)},validationTargetFor:function(b){return this.checkable(b)&&(b=this.findByName(b.name)),a(b).not(this.settings.ignore)[0]},checkable:function(a){return/radio|checkbox/i.test(a.type)},findByName:function(b){return a(this.currentForm).find("[name='"+b+"']")},getLength:function(b,c){switch(c.nodeName.toLowerCase()){case"select":return a("option:selected",c).length;case"input":if(this.checkable(c))return this.findByName(c.name).filter(":checked").length}return b.length},depend:function(a,b){return this.dependTypes[typeof a]?this.dependTypes[typeof a](a,b):!0},dependTypes:{"boolean":function(a){return a},string:function(b,c){return!!a(b,c.form).length},"function":function(a,b){return a(b)}},optional:function(b){var c=this.elementValue(b);return!a.validator.methods.required.call(this,c,b)&&"dependency-mismatch"},startRequest:function(a){this.pending[a.name]||(this.pendingRequest++,this.pending[a.name]=!0)},stopRequest:function(b,c){this.pendingRequest--,this.pendingRequest<0&&(this.pendingRequest=0),delete this.pending[b.name],c&&0===this.pendingRequest&&this.formSubmitted&&this.form()?(a(this.currentForm).submit(),this.formSubmitted=!1):!c&&0===this.pendingRequest&&this.formSubmitted&&(a(this.currentForm).triggerHandler("invalid-form",[this]),this.formSubmitted=!1)},previousValue:function(b){return a.data(b,"previousValue")||a.data(b,"previousValue",{old:null,valid:!0,message:this.defaultMessage(b,"remote")})}},classRuleSettings:{required:{required:!0},email:{email:!0},url:{url:!0},date:{date:!0},dateISO:{dateISO:!0},number:{number:!0},digits:{digits:!0},creditcard:{creditcard:!0}},addClassRules:function(b,c){b.constructor===String?this.classRuleSettings[b]=c:a.extend(this.classRuleSettings,b)},classRules:function(b){var c={},d=a(b).attr("class");return d&&a.each(d.split(" "),function(){this in a.validator.classRuleSettings&&a.extend(c,a.validator.classRuleSettings[this])}),c},attributeRules:function(b){var c,d,e={},f=a(b),g=b.getAttribute("type");for(c in a.validator.methods)"required"===c?(d=b.getAttribute(c),""===d&&(d=!0),d=!!d):d=f.attr(c),/min|max/.test(c)&&(null===g||/number|range|text/.test(g))&&(d=Number(d)),d||0===d?e[c]=d:g===c&&"range"!==g&&(e[c]=!0);return e.maxlength&&/-1|2147483647|524288/.test(e.maxlength)&&delete e.maxlength,e},dataRules:function(b){var c,d,e={},f=a(b);for(c in a.validator.methods)d=f.data("rule"+c.charAt(0).toUpperCase()+c.substring(1).toLowerCase()),void 0!==d&&(e[c]=d);return e},staticRules:function(b){var c={},d=a.data(b.form,"validator");return d.settings.rules&&(c=a.validator.normalizeRule(d.settings.rules[b.name])||{}),c},normalizeRules:function(b,c){return a.each(b,function(d,e){if(e===!1)return void delete b[d];if(e.param||e.depends){var f=!0;switch(typeof e.depends){case"string":f=!!a(e.depends,c.form).length;break;case"function":f=e.depends.call(c,c)}f?b[d]=void 0!==e.param?e.param:!0:delete b[d]}}),a.each(b,function(d,e){b[d]=a.isFunction(e)?e(c):e}),a.each(["minlength","maxlength"],function(){b[this]&&(b[this]=Number(b[this]))}),a.each(["rangelength","range"],function(){var c;b[this]&&(a.isArray(b[this])?b[this]=[Number(b[this][0]),Number(b[this][1])]:"string"==typeof b[this]&&(c=b[this].replace(/[\[\]]/g,"").split(/[\s,]+/),b[this]=[Number(c[0]),Number(c[1])]))}),a.validator.autoCreateRanges&&(null!=b.min&&null!=b.max&&(b.range=[b.min,b.max],delete b.min,delete b.max),null!=b.minlength&&null!=b.maxlength&&(b.rangelength=[b.minlength,b.maxlength],delete b.minlength,delete b.maxlength)),b},normalizeRule:function(b){if("string"==typeof b){var c={};a.each(b.split(/\s/),function(){c[this]=!0}),b=c}return b},addMethod:function(b,c,d){a.validator.methods[b]=c,a.validator.messages[b]=void 0!==d?d:a.validator.messages[b],c.length<3&&a.validator.addClassRules(b,a.validator.normalizeRule(b))},methods:{required:function(b,c,d){if(!this.depend(d,c))return"dependency-mismatch";if("select"===c.nodeName.toLowerCase()){var e=a(c).val();return e&&e.length>0}return this.checkable(c)?this.getLength(b,c)>0:a.trim(b).length>0},email:function(a,b){return this.optional(b)||/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a)},url:function(a,b){return this.optional(b)||/^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(a)},date:function(a,b){return this.optional(b)||!/Invalid|NaN/.test(new Date(a).toString())},dateISO:function(a,b){return this.optional(b)||/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(a)},number:function(a,b){return this.optional(b)||/^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(a)},digits:function(a,b){return this.optional(b)||/^\d+$/.test(a)},creditcard:function(a,b){if(this.optional(b))return"dependency-mismatch";if(/[^0-9 \-]+/.test(a))return!1;var c,d,e=0,f=0,g=!1;if(a=a.replace(/\D/g,""),a.length<13||a.length>19)return!1;for(c=a.length-1;c>=0;c--)d=a.charAt(c),f=parseInt(d,10),g&&(f*=2)>9&&(f-=9),e+=f,g=!g;return e%10===0},minlength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||e>=d},maxlength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||d>=e},rangelength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||e>=d[0]&&e<=d[1]},min:function(a,b,c){return this.optional(b)||a>=c},max:function(a,b,c){return this.optional(b)||c>=a},range:function(a,b,c){return this.optional(b)||a>=c[0]&&a<=c[1]},equalTo:function(b,c,d){var e=a(d);return this.settings.onfocusout&&e.unbind(".validate-equalTo").bind("blur.validate-equalTo",function(){a(c).valid()}),b===e.val()},remote:function(b,c,d){if(this.optional(c))return"dependency-mismatch";var e,f,g=this.previousValue(c);return this.settings.messages[c.name]||(this.settings.messages[c.name]={}),g.originalMessage=this.settings.messages[c.name].remote,this.settings.messages[c.name].remote=g.message,d="string"==typeof d&&{url:d}||d,g.old===b?g.valid:(g.old=b,e=this,this.startRequest(c),f={},f[c.name]=b,a.ajax(a.extend(!0,{url:d,mode:"abort",port:"validate"+c.name,dataType:"json",data:f,context:e.currentForm,success:function(d){var f,h,i,j=d===!0||"true"===d;e.settings.messages[c.name].remote=g.originalMessage,j?(i=e.formSubmitted,e.prepareElement(c),e.formSubmitted=i,e.successList.push(c),delete e.invalid[c.name],e.showErrors()):(f={},h=d||e.defaultMessage(c,"remote"),f[c.name]=g.message=a.isFunction(h)?h(b):h,e.invalid[c.name]=!0,e.showErrors(f)),g.valid=j,e.stopRequest(c,j)}},d)),"pending")}}}),a.format=function(){throw"$.format has been deprecated. Please use $.validator.format instead."};var b,c={};a.ajaxPrefilter?a.ajaxPrefilter(function(a,b,d){var e=a.port;"abort"===a.mode&&(c[e]&&c[e].abort(),c[e]=d)}):(b=a.ajax,a.ajax=function(d){var e=("mode"in d?d:a.ajaxSettings).mode,f=("port"in d?d:a.ajaxSettings).port;return"abort"===e?(c[f]&&c[f].abort(),c[f]=b.apply(this,arguments),c[f]):b.apply(this,arguments)}),a.extend(a.fn,{validateDelegate:function(b,c,d){return this.bind(c,function(c){var e=a(c.target);return e.is(b)?d.apply(e,arguments):void 0})}})});
/*
  html2canvas 0.5.0-alpha1 <http://html2canvas.hertzen.com>
  Copyright (c) 2015 Niklas von Hertzen

  Released under MIT License
*/

(function(window, document, exports, global, define, undefined){

/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   2.0.1
 */

(function(){function r(a,b){n[l]=a;n[l+1]=b;l+=2;2===l&&A()}function s(a){return"function"===typeof a}function F(){return function(){process.nextTick(t)}}function G(){var a=0,b=new B(t),c=document.createTextNode("");b.observe(c,{characterData:!0});return function(){c.data=a=++a%2}}function H(){var a=new MessageChannel;a.port1.onmessage=t;return function(){a.port2.postMessage(0)}}function I(){return function(){setTimeout(t,1)}}function t(){for(var a=0;a<l;a+=2)(0,n[a])(n[a+1]),n[a]=void 0,n[a+1]=void 0;
l=0}function p(){}function J(a,b,c,d){try{a.call(b,c,d)}catch(e){return e}}function K(a,b,c){r(function(a){var e=!1,f=J(c,b,function(c){e||(e=!0,b!==c?q(a,c):m(a,c))},function(b){e||(e=!0,g(a,b))});!e&&f&&(e=!0,g(a,f))},a)}function L(a,b){1===b.a?m(a,b.b):2===a.a?g(a,b.b):u(b,void 0,function(b){q(a,b)},function(b){g(a,b)})}function q(a,b){if(a===b)g(a,new TypeError("You cannot resolve a promise with itself"));else if("function"===typeof b||"object"===typeof b&&null!==b)if(b.constructor===a.constructor)L(a,
b);else{var c;try{c=b.then}catch(d){v.error=d,c=v}c===v?g(a,v.error):void 0===c?m(a,b):s(c)?K(a,b,c):m(a,b)}else m(a,b)}function M(a){a.f&&a.f(a.b);x(a)}function m(a,b){void 0===a.a&&(a.b=b,a.a=1,0!==a.e.length&&r(x,a))}function g(a,b){void 0===a.a&&(a.a=2,a.b=b,r(M,a))}function u(a,b,c,d){var e=a.e,f=e.length;a.f=null;e[f]=b;e[f+1]=c;e[f+2]=d;0===f&&a.a&&r(x,a)}function x(a){var b=a.e,c=a.a;if(0!==b.length){for(var d,e,f=a.b,g=0;g<b.length;g+=3)d=b[g],e=b[g+c],d?C(c,d,e,f):e(f);a.e.length=0}}function D(){this.error=
null}function C(a,b,c,d){var e=s(c),f,k,h,l;if(e){try{f=c(d)}catch(n){y.error=n,f=y}f===y?(l=!0,k=f.error,f=null):h=!0;if(b===f){g(b,new TypeError("A promises callback cannot return that same promise."));return}}else f=d,h=!0;void 0===b.a&&(e&&h?q(b,f):l?g(b,k):1===a?m(b,f):2===a&&g(b,f))}function N(a,b){try{b(function(b){q(a,b)},function(b){g(a,b)})}catch(c){g(a,c)}}function k(a,b,c,d){this.n=a;this.c=new a(p,d);this.i=c;this.o(b)?(this.m=b,this.d=this.length=b.length,this.l(),0===this.length?m(this.c,
this.b):(this.length=this.length||0,this.k(),0===this.d&&m(this.c,this.b))):g(this.c,this.p())}function h(a){O++;this.b=this.a=void 0;this.e=[];if(p!==a){if(!s(a))throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(!(this instanceof h))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");N(this,a)}}var E=Array.isArray?Array.isArray:function(a){return"[object Array]"===
Object.prototype.toString.call(a)},l=0,w="undefined"!==typeof window?window:{},B=w.MutationObserver||w.WebKitMutationObserver,w="undefined"!==typeof Uint8ClampedArray&&"undefined"!==typeof importScripts&&"undefined"!==typeof MessageChannel,n=Array(1E3),A;A="undefined"!==typeof process&&"[object process]"==={}.toString.call(process)?F():B?G():w?H():I();var v=new D,y=new D;k.prototype.o=function(a){return E(a)};k.prototype.p=function(){return Error("Array Methods must be provided an Array")};k.prototype.l=
function(){this.b=Array(this.length)};k.prototype.k=function(){for(var a=this.length,b=this.c,c=this.m,d=0;void 0===b.a&&d<a;d++)this.j(c[d],d)};k.prototype.j=function(a,b){var c=this.n;"object"===typeof a&&null!==a?a.constructor===c&&void 0!==a.a?(a.f=null,this.g(a.a,b,a.b)):this.q(c.resolve(a),b):(this.d--,this.b[b]=this.h(a))};k.prototype.g=function(a,b,c){var d=this.c;void 0===d.a&&(this.d--,this.i&&2===a?g(d,c):this.b[b]=this.h(c));0===this.d&&m(d,this.b)};k.prototype.h=function(a){return a};
k.prototype.q=function(a,b){var c=this;u(a,void 0,function(a){c.g(1,b,a)},function(a){c.g(2,b,a)})};var O=0;h.all=function(a,b){return(new k(this,a,!0,b)).c};h.race=function(a,b){function c(a){q(e,a)}function d(a){g(e,a)}var e=new this(p,b);if(!E(a))return (g(e,new TypeError("You must pass an array to race.")), e);for(var f=a.length,h=0;void 0===e.a&&h<f;h++)u(this.resolve(a[h]),void 0,c,d);return e};h.resolve=function(a,b){if(a&&"object"===typeof a&&a.constructor===this)return a;var c=new this(p,b);
q(c,a);return c};h.reject=function(a,b){var c=new this(p,b);g(c,a);return c};h.prototype={constructor:h,then:function(a,b){var c=this.a;if(1===c&&!a||2===c&&!b)return this;var d=new this.constructor(p),e=this.b;if(c){var f=arguments[c-1];r(function(){C(c,d,f,e)})}else u(this,d,a,b);return d},"catch":function(a){return this.then(null,a)}};var z={Promise:h,polyfill:function(){var a;a="undefined"!==typeof global?global:"undefined"!==typeof window&&window.document?window:self;"Promise"in a&&"resolve"in
a.Promise&&"reject"in a.Promise&&"all"in a.Promise&&"race"in a.Promise&&function(){var b;new a.Promise(function(a){b=a});return s(b)}()||(a.Promise=h)}};"function"===typeof define&&define.amd?define(function(){return z}):"undefined"!==typeof module&&module.exports?module.exports=z:"undefined"!==typeof this&&(this.ES6Promise=z);}).call(window);
if (window) {
    window.ES6Promise.polyfill();
}


if (typeof(document) === "undefined" || typeof(Object.create) !== "function" || typeof(document.createElement("canvas").getContext) !== "function") {
    (window || module.exports).html2canvas = function() {
        return Promise.reject("No canvas support");
    };
    return;
}

/*! https://mths.be/punycode v1.3.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		var labels = string.split(regexSeparators);
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

var html2canvasNodeAttribute = "data-html2canvas-node";
var html2canvasCanvasCloneAttribute = "data-html2canvas-canvas-clone";
var html2canvasCanvasCloneIndex = 0;
var html2canvasCloneIndex = 0;

window.html2canvas = function(nodeList, options) {
    var index = html2canvasCloneIndex++;
    options = options || {};
    if (options.logging) {
        window.html2canvas.logging = true;
        window.html2canvas.start = Date.now();
    }

    options.async = typeof(options.async) === "undefined" ? true : options.async;
    options.allowTaint = typeof(options.allowTaint) === "undefined" ? false : options.allowTaint;
    options.removeContainer = typeof(options.removeContainer) === "undefined" ? true : options.removeContainer;
    options.javascriptEnabled = typeof(options.javascriptEnabled) === "undefined" ? false : options.javascriptEnabled;
    options.imageTimeout = typeof(options.imageTimeout) === "undefined" ? 10000 : options.imageTimeout;
    options.renderer = typeof(options.renderer) === "function" ? options.renderer : CanvasRenderer;
    options.strict = !!options.strict;

    if (typeof(nodeList) === "string") {
        if (typeof(options.proxy) !== "string") {
            return Promise.reject("Proxy must be used when rendering url");
        }
        var width = options.width != null ? options.width : window.innerWidth;
        var height = options.height != null ? options.height : window.innerHeight;
        return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function(container) {
            return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);
        });
    }

    var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];
    node.setAttribute(html2canvasNodeAttribute + index, index);
    return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight, index).then(function(canvas) {
        if (typeof(options.onrendered) === "function") {
            log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
            options.onrendered(canvas);
        }
        return canvas;
    });
};

window.html2canvas.punycode = this.punycode;
window.html2canvas.proxy = {};

function renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {
    return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then(function(container) {
        log("Document cloned");
        var attributeName = html2canvasNodeAttribute + html2canvasIndex;
        var selector = "[" + attributeName + "='" + html2canvasIndex + "']";
        document.querySelector(selector).removeAttribute(attributeName);
        var clonedWindow = container.contentWindow;
        var node = clonedWindow.document.querySelector(selector);
        var oncloneHandler = (typeof(options.onclone) === "function") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
        return oncloneHandler.then(function() {
            return renderWindow(node, container, options, windowWidth, windowHeight);
        });
    });
}

function renderWindow(node, container, options, windowWidth, windowHeight) {
    var clonedWindow = container.contentWindow;
    var support = new Support(clonedWindow.document);
    var imageLoader = new ImageLoader(options, support);
    var bounds = getBounds(node);
    var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
    var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
    var renderer = new options.renderer(width, height, imageLoader, options, document);
    var parser = new NodeParser(node, renderer, support, imageLoader, options);
    return parser.ready.then(function() {
        log("Finished rendering");
        var canvas;

        if (options.type === "view") {
            canvas = crop(renderer.canvas, {width: renderer.canvas.width, height: renderer.canvas.height, top: 0, left: 0, x: 0, y: 0});
        } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {
            canvas = renderer.canvas;
        } else {
            canvas = crop(renderer.canvas, {width:  options.width != null ? options.width : bounds.width, height: options.height != null ? options.height : bounds.height, top: bounds.top, left: bounds.left, x: clonedWindow.pageXOffset, y: clonedWindow.pageYOffset});
        }

        cleanupContainer(container, options);
        return canvas;
    });
}

function cleanupContainer(container, options) {
    if (options.removeContainer) {
        container.parentNode.removeChild(container);
        log("Cleaned up container");
    }
}

function crop(canvas, bounds) {
    var croppedCanvas = document.createElement("canvas");
    var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));
    var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));
    var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));
    var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));
    croppedCanvas.width = bounds.width;
    croppedCanvas.height =  bounds.height;
    log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", (x2-x1), "height:", (y2-y1));
    log("Resulting crop with width", bounds.width, "and height", bounds.height, " with x", x1, "and y", y1);
    croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, x2-x1, y2-y1, bounds.x, bounds.y, x2-x1, y2-y1);
    return croppedCanvas;
}

function documentWidth (doc) {
    return Math.max(
        Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
        Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
        Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
    );
}

function documentHeight (doc) {
    return Math.max(
        Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
        Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
        Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
    );
}

function smallImage() {
    return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
}

function isIE9() {
    return document.documentMode && document.documentMode <= 9;
}

// https://github.com/niklasvh/html2canvas/issues/503
function cloneNodeIE9(node, javascriptEnabled) {
    var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);

    var child = node.firstChild;
    while(child) {
        if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {
            clone.appendChild(cloneNodeIE9(child, javascriptEnabled));
        }
        child = child.nextSibling;
    }

    return clone;
}

function createWindowClone(ownerDocument, containerDocument, width, height, options, x ,y) {
    labelCanvasElements(ownerDocument);
    var documentElement = isIE9() ? cloneNodeIE9(ownerDocument.documentElement, options.javascriptEnabled) : ownerDocument.documentElement.cloneNode(true);
    var container = containerDocument.createElement("iframe");

    container.className = "html2canvas-container";
    container.style.visibility = "hidden";
    container.style.position = "fixed";
    container.style.left = "-10000px";
    container.style.top = "0px";
    container.style.border = "0";
    container.width = width;
    container.height = height;
    container.scrolling = "no"; // ios won't scroll without it
    containerDocument.body.appendChild(container);

    return new Promise(function(resolve) {
        var documentClone = container.contentWindow.document;

        cloneNodeValues(ownerDocument.documentElement, documentElement, "textarea");
        cloneNodeValues(ownerDocument.documentElement, documentElement, "select");

        /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
         if window url is about:blank, we can assign the url to current by writing onto the document
         */
        container.contentWindow.onload = container.onload = function() {
            var interval = setInterval(function() {
                if (documentClone.body.childNodes.length > 0) {
                    cloneCanvasContents(ownerDocument, documentClone);
                    clearInterval(interval);
                    if (options.type === "view") {
                        container.contentWindow.scrollTo(x, y);
                    }
                    resolve(container);
                }
            }, 50);
        };

        documentClone.open();
        documentClone.write("<!DOCTYPE html><html></html>");
        // Chrome scrolls the parent document for some reason after the write to the cloned window???
        restoreOwnerScroll(ownerDocument, x, y);
        documentClone.replaceChild(options.javascriptEnabled === true ? documentClone.adoptNode(documentElement) : removeScriptNodes(documentClone.adoptNode(documentElement)), documentClone.documentElement);
        documentClone.close();
    });
}

function cloneNodeValues(document, clone, nodeName) {
    var originalNodes = document.getElementsByTagName(nodeName);
    var clonedNodes = clone.getElementsByTagName(nodeName);
    var count = originalNodes.length;
    for (var i = 0; i < count; i++) {
        clonedNodes[i].value = originalNodes[i].value;
    }
}

function restoreOwnerScroll(ownerDocument, x, y) {
    if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
        ownerDocument.defaultView.scrollTo(x, y);
    }
}

function loadUrlDocument(src, proxy, document, width, height, options) {
    return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {
        return createWindowClone(doc, document, width, height, options, 0, 0);
    });
}

function documentFromHTML(src) {
    return function(html) {
        var parser = new DOMParser(), doc;
        try {
            doc = parser.parseFromString(html, "text/html");
        } catch(e) {
            log("DOMParser not supported, falling back to createHTMLDocument");
            doc = document.implementation.createHTMLDocument("");
            try {
                doc.open();
                doc.write(html);
                doc.close();
            } catch(ee) {
                log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
                doc.body.innerHTML = html; // ie9 doesnt support writing to documentElement
            }
        }

        var b = doc.querySelector("base");
        if (!b || !b.href.host) {
            var base = doc.createElement("base");
            base.href = src;
            doc.head.insertBefore(base, doc.head.firstChild);
        }

        return doc;
    };
}


function labelCanvasElements(ownerDocument) {
    [].slice.call(ownerDocument.querySelectorAll("canvas"), 0).forEach(function(canvas) {
        canvas.setAttribute(html2canvasCanvasCloneAttribute, "canvas-" + html2canvasCanvasCloneIndex++);
    });
}

function cloneCanvasContents(ownerDocument, documentClone) {
    [].slice.call(ownerDocument.querySelectorAll("[" + html2canvasCanvasCloneAttribute + "]"), 0).forEach(function(canvas) {
        try {
            var clonedCanvas = documentClone.querySelector('[' + html2canvasCanvasCloneAttribute + '="' + canvas.getAttribute(html2canvasCanvasCloneAttribute) + '"]');
            if (clonedCanvas) {
                clonedCanvas.width = canvas.width;
                clonedCanvas.height = canvas.height;
                clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
            }
        } catch(e) {
            log("Unable to copy canvas content from", canvas, e);
        }
        canvas.removeAttribute(html2canvasCanvasCloneAttribute);
    });
}

function removeScriptNodes(parent) {
    [].slice.call(parent.childNodes, 0).filter(isElementNode).forEach(function(node) {
        if (node.tagName === "SCRIPT") {
            parent.removeChild(node);
        } else {
            removeScriptNodes(node);
        }
    });
    return parent;
}

function isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
}

function absoluteUrl(url) {
    var link = document.createElement("a");
    link.href = url;
    link.href = link.href;
    return link;
}

// http://dev.w3.org/csswg/css-color/

function Color(value) {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = null;
    var result = this.fromArray(value) ||
        this.namedColor(value) ||
        this.rgb(value) ||
        this.rgba(value) ||
        this.hex6(value) ||
        this.hex3(value);
}

Color.prototype.darken = function(amount) {
    var a = 1 - amount;
    return  new Color([
        Math.round(this.r * a),
        Math.round(this.g * a),
        Math.round(this.b * a),
        this.a
    ]);
};

Color.prototype.isTransparent = function() {
    return this.a === 0;
};

Color.prototype.isBlack = function() {
    return this.r === 0 && this.g === 0 && this.b === 0;
};

Color.prototype.fromArray = function(array) {
    if (Array.isArray(array)) {
        this.r = Math.min(array[0], 255);
        this.g = Math.min(array[1], 255);
        this.b = Math.min(array[2], 255);
        if (array.length > 3) {
            this.a = array[3];
        }
    }

    return (Array.isArray(array));
};

var _hex3 = /^#([a-f0-9]{3})$/i;

Color.prototype.hex3 = function(value) {
    var match = null;
    if ((match = value.match(_hex3)) !== null) {
        this.r = parseInt(match[1][0] + match[1][0], 16);
        this.g = parseInt(match[1][1] + match[1][1], 16);
        this.b = parseInt(match[1][2] + match[1][2], 16);
    }
    return match !== null;
};

var _hex6 = /^#([a-f0-9]{6})$/i;

Color.prototype.hex6 = function(value) {
    var match = null;
    if ((match = value.match(_hex6)) !== null) {
        this.r = parseInt(match[1].substring(0, 2), 16);
        this.g = parseInt(match[1].substring(2, 4), 16);
        this.b = parseInt(match[1].substring(4, 6), 16);
    }
    return match !== null;
};


var _rgb = /^rgb\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3})\)$/;

Color.prototype.rgb = function(value) {
    var match = null;
    if ((match = value.match(_rgb)) !== null) {
        this.r = Number(match[1]);
        this.g = Number(match[2]);
        this.b = Number(match[3]);
    }
    return match !== null;
};

var _rgba = /^rgba\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3}) *, *(\d+\.?\d*)\)$/;

Color.prototype.rgba = function(value) {
    var match = null;
    if ((match = value.match(_rgba)) !== null) {
        this.r = Number(match[1]);
        this.g = Number(match[2]);
        this.b = Number(match[3]);
        this.a = Number(match[4]);
    }
    return match !== null;
};

Color.prototype.toString = function() {
    return this.a !== null && this.a !== 1 ?
    "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")" :
    "rgb(" + [this.r, this.g, this.b].join(",") + ")";
};

Color.prototype.namedColor = function(value) {
    var color = colors[value.toLowerCase()];
    if (color) {
        this.r = color[0];
        this.g = color[1];
        this.b = color[2];
    } else if (value.toLowerCase() === "transparent") {
        this.r = this.g = this.b = this.a = 0;
        return true;
    }

    return !!color;
};

Color.prototype.isColor = true;

// JSON.stringify([].slice.call($$('.named-color-table tr'), 1).map(function(row) { return [row.childNodes[3].textContent, row.childNodes[5].textContent.trim().split(",").map(Number)] }).reduce(function(data, row) {data[row[0]] = row[1]; return data}, {}))
var colors = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
};


function DummyImageContainer(src) {
    this.src = src;
    log("DummyImageContainer for", src);
    if (!this.promise || !this.image) {
        log("Initiating DummyImageContainer");
        DummyImageContainer.prototype.image = new Image();
        var image = this.image;
        DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {
            image.onload = resolve;
            image.onerror = reject;
            image.src = smallImage();
            if (image.complete === true) {
                resolve(image);
            }
        });
    }
}

function Font(family, size) {
    var container = document.createElement('div'),
        img = document.createElement('img'),
        span = document.createElement('span'),
        sampleText = 'Hidden Text',
        baseline,
        middle;

    container.style.visibility = "hidden";
    container.style.fontFamily = family;
    container.style.fontSize = size;
    container.style.margin = 0;
    container.style.padding = 0;

    document.body.appendChild(container);

    img.src = smallImage();
    img.width = 1;
    img.height = 1;

    img.style.margin = 0;
    img.style.padding = 0;
    img.style.verticalAlign = "baseline";

    span.style.fontFamily = family;
    span.style.fontSize = size;
    span.style.margin = 0;
    span.style.padding = 0;

    span.appendChild(document.createTextNode(sampleText));
    container.appendChild(span);
    container.appendChild(img);
    baseline = (img.offsetTop - span.offsetTop) + 1;

    container.removeChild(span);
    container.appendChild(document.createTextNode(sampleText));

    container.style.lineHeight = "normal";
    img.style.verticalAlign = "super";

    middle = (img.offsetTop-container.offsetTop) + 1;

    document.body.removeChild(container);

    this.baseline = baseline;
    this.lineWidth = 1;
    this.middle = middle;
}

function FontMetrics() {
    this.data = {};
}

FontMetrics.prototype.getMetrics = function(family, size) {
    if (this.data[family + "-" + size] === undefined) {
        this.data[family + "-" + size] = new Font(family, size);
    }
    return this.data[family + "-" + size];
};

function FrameContainer(container, sameOrigin, options) {
    this.image = null;
    this.src = container;
    var self = this;
    var bounds = getBounds(container);
    this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {
        if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
            container.contentWindow.onload = container.onload = function() {
                resolve(container);
            };
        } else {
            resolve(container);
        }
    })).then(function(container) {
        return html2canvas(container.contentWindow.document.documentElement, {type: 'view', width: container.width, height: container.height, proxy: options.proxy, javascriptEnabled: options.javascriptEnabled, removeContainer: options.removeContainer, allowTaint: options.allowTaint, imageTimeout: options.imageTimeout / 2});
    }).then(function(canvas) {
        return self.image = canvas;
    });
}

FrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {
    var container = this.src;
    return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
};

function GradientContainer(imageData) {
    this.src = imageData.value;
    this.colorStops = [];
    this.type = null;
    this.x0 = 0.5;
    this.y0 = 0.5;
    this.x1 = 0.5;
    this.y1 = 0.5;
    this.promise = Promise.resolve(true);
}

GradientContainer.prototype.TYPES = {
    LINEAR: 1,
    RADIAL: 2
};

function ImageContainer(src, cors) {
    this.src = src;
    this.image = new Image();
    var self = this;
    this.tainted = null;
    this.promise = new Promise(function(resolve, reject) {
        self.image.onload = resolve;
        self.image.onerror = reject;
        if (cors) {
            self.image.crossOrigin = "anonymous";
        }
        self.image.src = src;
        if (self.image.complete === true) {
            resolve(self.image);
        }
    });
}

function ImageLoader(options, support) {
    this.link = null;
    this.options = options;
    this.support = support;
    this.origin = this.getOrigin(window.location.href);
}

ImageLoader.prototype.findImages = function(nodes) {
    var images = [];
    nodes.reduce(function(imageNodes, container) {
        switch(container.node.nodeName) {
        case "IMG":
            return imageNodes.concat([{
                args: [container.node.src],
                method: "url"
            }]);
        case "svg":
        case "IFRAME":
            return imageNodes.concat([{
                args: [container.node],
                method: container.node.nodeName
            }]);
        }
        return imageNodes;
    }, []).forEach(this.addImage(images, this.loadImage), this);
    return images;
};

ImageLoader.prototype.findBackgroundImage = function(images, container) {
    container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
    return images;
};

ImageLoader.prototype.addImage = function(images, callback) {
    return function(newImage) {
        newImage.args.forEach(function(image) {
            if (!this.imageExists(images, image)) {
                images.splice(0, 0, callback.call(this, newImage));
                log('Added image #' + (images.length), typeof(image) === "string" ? image.substring(0, 100) : image);
            }
        }, this);
    };
};

ImageLoader.prototype.hasImageBackground = function(imageData) {
    return imageData.method !== "none";
};

ImageLoader.prototype.loadImage = function(imageData) {
    if (imageData.method === "url") {
        var src = imageData.args[0];
        if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
            return new SVGContainer(src);
        } else if (src.match(/data:image\/.*;base64,/i)) {
            return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
        } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
            return new ImageContainer(src, false);
        } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
            return new ImageContainer(src, true);
        } else if (this.options.proxy) {
            return new ProxyImageContainer(src, this.options.proxy);
        } else {
            return new DummyImageContainer(src);
        }
    } else if (imageData.method === "linear-gradient") {
        return new LinearGradientContainer(imageData);
    } else if (imageData.method === "gradient") {
        return new WebkitGradientContainer(imageData);
    } else if (imageData.method === "svg") {
        return new SVGNodeContainer(imageData.args[0], this.support.svg);
    } else if (imageData.method === "IFRAME") {
        return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
    } else {
        return new DummyImageContainer(imageData);
    }
};

ImageLoader.prototype.isSVG = function(src) {
    return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
};

ImageLoader.prototype.imageExists = function(images, src) {
    return images.some(function(image) {
        return image.src === src;
    });
};

ImageLoader.prototype.isSameOrigin = function(url) {
    return (this.getOrigin(url) === this.origin);
};

ImageLoader.prototype.getOrigin = function(url) {
    var link = this.link || (this.link = document.createElement("a"));
    link.href = url;
    link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
    return link.protocol + link.hostname + link.port;
};

ImageLoader.prototype.getPromise = function(container) {
    return this.timeout(container, this.options.imageTimeout)['catch'](function() {
        var dummy = new DummyImageContainer(container.src);
        return dummy.promise.then(function(image) {
            container.image = image;
        });
    });
};

ImageLoader.prototype.get = function(src) {
    var found = null;
    return this.images.some(function(img) {
        return (found = img).src === src;
    }) ? found : null;
};

ImageLoader.prototype.fetch = function(nodes) {
    this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
    this.images.forEach(function(image, index) {
        image.promise.then(function() {
            log("Succesfully loaded image #"+ (index+1), image);
        }, function(e) {
            log("Failed loading image #"+ (index+1), image, e);
        });
    });
    this.ready = Promise.all(this.images.map(this.getPromise, this));
    log("Finished searching images");
    return this;
};

ImageLoader.prototype.timeout = function(container, timeout) {
    var timer;
    var promise = Promise.race([container.promise, new Promise(function(res, reject) {
        timer = setTimeout(function() {
            log("Timed out loading image", container);
            reject(container);
        }, timeout);
    })]).then(function(container) {
        clearTimeout(timer);
        return container;
    });
    promise['catch'](function() {
        clearTimeout(timer);
    });
    return promise;
};

function LinearGradientContainer(imageData) {
    GradientContainer.apply(this, arguments);
    this.type = this.TYPES.LINEAR;

    var hasDirection = imageData.args[0].match(this.stepRegExp) === null;

    if (hasDirection) {
        imageData.args[0].split(" ").reverse().forEach(function(position) {
            switch(position) {
            case "left":
                this.x0 = 0;
                this.x1 = 1;
                break;
            case "top":
                this.y0 = 0;
                this.y1 = 1;
                break;
            case "right":
                this.x0 = 1;
                this.x1 = 0;
                break;
            case "bottom":
                this.y0 = 1;
                this.y1 = 0;
                break;
            case "to":
                var y0 = this.y0;
                var x0 = this.x0;
                this.y0 = this.y1;
                this.x0 = this.x1;
                this.x1 = x0;
                this.y1 = y0;
                break;
            }
        }, this);
    } else {
        this.y0 = 0;
        this.y1 = 1;
    }

    this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {
        var colorStopMatch = colorStop.match(this.stepRegExp);
        return {
            color: new Color(colorStopMatch[1]),
            stop: colorStopMatch[3] === "%" ? colorStopMatch[2] / 100 : null
        };
    }, this);

    if (this.colorStops[0].stop === null) {
        this.colorStops[0].stop = 0;
    }

    if (this.colorStops[this.colorStops.length - 1].stop === null) {
        this.colorStops[this.colorStops.length - 1].stop = 1;
    }

    this.colorStops.forEach(function(colorStop, index) {
        if (colorStop.stop === null) {
            this.colorStops.slice(index).some(function(find, count) {
                if (find.stop !== null) {
                    colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;
                    return true;
                } else {
                    return false;
                }
            }, this);
        }
    }, this);
}

LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);

LinearGradientContainer.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/;

function log() {
    if (window.html2canvas.logging && window.console && window.console.log) {
        Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - window.html2canvas.start) + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
    }
}

function NodeContainer(node, parent) {
    this.node = node;
    this.parent = parent;
    this.stack = null;
    this.bounds = null;
    this.borders = null;
    this.clip = [];
    this.backgroundClip = [];
    this.offsetBounds = null;
    this.visible = null;
    this.computedStyles = null;
    this.colors = {};
    this.styles = {};
    this.backgroundImages = null;
    this.transformData = null;
    this.transformMatrix = null;
    this.isPseudoElement = false;
    this.opacity = null;
}

NodeContainer.prototype.cloneTo = function(stack) {
    stack.visible = this.visible;
    stack.borders = this.borders;
    stack.bounds = this.bounds;
    stack.clip = this.clip;
    stack.backgroundClip = this.backgroundClip;
    stack.computedStyles = this.computedStyles;
    stack.styles = this.styles;
    stack.backgroundImages = this.backgroundImages;
    stack.opacity = this.opacity;
};

NodeContainer.prototype.getOpacity = function() {
    return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;
};

NodeContainer.prototype.assignStack = function(stack) {
    this.stack = stack;
    stack.children.push(this);
};

NodeContainer.prototype.isElementVisible = function() {
    return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (
        this.css('display') !== "none" &&
        this.css('visibility') !== "hidden" &&
        !this.node.hasAttribute("data-html2canvas-ignore") &&
        (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden")
    );
};

NodeContainer.prototype.css = function(attribute) {
    if (!this.computedStyles) {
        this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
    }

    return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
};

NodeContainer.prototype.prefixedCss = function(attribute) {
    var prefixes = ["webkit", "moz", "ms", "o"];
    var value = this.css(attribute);
    if (value === undefined) {
        prefixes.some(function(prefix) {
            value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
            return value !== undefined;
        }, this);
    }
    return value === undefined ? null : value;
};

NodeContainer.prototype.computedStyle = function(type) {
    return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
};

NodeContainer.prototype.cssInt = function(attribute) {
    var value = parseInt(this.css(attribute), 10);
    return (isNaN(value)) ? 0 : value; // borders in old IE are throwing 'medium' for demo.html
};

NodeContainer.prototype.color = function(attribute) {
    return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));
};

NodeContainer.prototype.cssFloat = function(attribute) {
    var value = parseFloat(this.css(attribute));
    return (isNaN(value)) ? 0 : value;
};

NodeContainer.prototype.fontWeight = function() {
    var weight = this.css("fontWeight");
    switch(parseInt(weight, 10)){
    case 401:
        weight = "bold";
        break;
    case 400:
        weight = "normal";
        break;
    }
    return weight;
};

NodeContainer.prototype.parseClip = function() {
    var matches = this.css('clip').match(this.CLIP);
    if (matches) {
        return {
            top: parseInt(matches[1], 10),
            right: parseInt(matches[2], 10),
            bottom: parseInt(matches[3], 10),
            left: parseInt(matches[4], 10)
        };
    }
    return null;
};

NodeContainer.prototype.parseBackgroundImages = function() {
    return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
};

NodeContainer.prototype.cssList = function(property, index) {
    var value = (this.css(property) || '').split(',');
    value = value[index || 0] || value[0] || 'auto';
    value = value.trim().split(' ');
    if (value.length === 1) {
        value = [value[0], value[0]];
    }
    return value;
};

NodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {
    var size = this.cssList("backgroundSize", index);
    var width, height;

    if (isPercentage(size[0])) {
        width = bounds.width * parseFloat(size[0]) / 100;
    } else if (/contain|cover/.test(size[0])) {
        var targetRatio = bounds.width / bounds.height, currentRatio = image.width / image.height;
        return (targetRatio < currentRatio ^ size[0] === 'contain') ?  {width: bounds.height * currentRatio, height: bounds.height} : {width: bounds.width, height: bounds.width / currentRatio};
    } else {
        width = parseInt(size[0], 10);
    }

    if (size[0] === 'auto' && size[1] === 'auto') {
        height = image.height;
    } else if (size[1] === 'auto') {
        height = width / image.width * image.height;
    } else if (isPercentage(size[1])) {
        height =  bounds.height * parseFloat(size[1]) / 100;
    } else {
        height = parseInt(size[1], 10);
    }

    if (size[0] === 'auto') {
        width = height / image.height * image.width;
    }

    return {width: width, height: height};
};

NodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {
    var position = this.cssList('backgroundPosition', index);
    var left, top;

    if (isPercentage(position[0])){
        left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
    } else {
        left = parseInt(position[0], 10);
    }

    if (position[1] === 'auto') {
        top = left / image.width * image.height;
    } else if (isPercentage(position[1])){
        top =  (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
    } else {
        top = parseInt(position[1], 10);
    }

    if (position[0] === 'auto') {
        left = top / image.height * image.width;
    }

    return {left: left, top: top};
};

NodeContainer.prototype.parseBackgroundRepeat = function(index) {
    return this.cssList("backgroundRepeat", index)[0];
};

NodeContainer.prototype.parseTextShadows = function() {
    var textShadow = this.css("textShadow");
    var results = [];

    if (textShadow && textShadow !== 'none') {
        var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
        for (var i = 0; shadows && (i < shadows.length); i++) {
            var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
            results.push({
                color: new Color(s[0]),
                offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
                offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
                blur: s[3] ? s[3].replace('px', '') : 0
            });
        }
    }
    return results;
};

NodeContainer.prototype.parseTransform = function() {
    if (!this.transformData) {
        if (this.hasTransform()) {
            var offset = this.parseBounds();
            var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
            origin[0] += offset.left;
            origin[1] += offset.top;
            this.transformData = {
                origin: origin,
                matrix: this.parseTransformMatrix()
            };
        } else {
            this.transformData = {
                origin: [0, 0],
                matrix: [1, 0, 0, 1, 0, 0]
            };
        }
    }
    return this.transformData;
};

NodeContainer.prototype.parseTransformMatrix = function() {
    if (!this.transformMatrix) {
        var transform = this.prefixedCss("transform");
        var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
        this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
    }
    return this.transformMatrix;
};

NodeContainer.prototype.parseBounds = function() {
    return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
};

NodeContainer.prototype.hasTransform = function() {
    return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || (this.parent && this.parent.hasTransform());
};

NodeContainer.prototype.getValue = function() {
    var value = this.node.value || "";
    if (this.node.tagName === "SELECT") {
        value = selectionValue(this.node);
    } else if (this.node.type === "password") {
        value = Array(value.length + 1).join('\u2022'); // jshint ignore:line
    }
    return value.length === 0 ? (this.node.placeholder || "") : value;
};

NodeContainer.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/;
NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

function selectionValue(node) {
    var option = node.options[node.selectedIndex || 0];
    return option ? (option.text || "") : "";
}

function parseMatrix(match) {
    if (match && match[1] === "matrix") {
        return match[2].split(",").map(function(s) {
            return parseFloat(s.trim());
        });
    }
}

function isPercentage(value) {
    return value.toString().indexOf("%") !== -1;
}

function parseBackgrounds(backgroundImage) {
    var whitespace = ' \r\n\t',
        method, definition, prefix, prefix_i, block, results = [],
        mode = 0, numParen = 0, quote, args;
    var appendResult = function() {
        if(method) {
            if (definition.substr(0, 1) === '"') {
                definition = definition.substr(1, definition.length - 2);
            }
            if (definition) {
                args.push(definition);
            }
            if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1 ) + 1) > 0) {
                prefix = method.substr(0, prefix_i);
                method = method.substr(prefix_i);
            }
            results.push({
                prefix: prefix,
                method: method.toLowerCase(),
                value: block,
                args: args,
                image: null
            });
        }
        args = [];
        method = prefix = definition = block = '';
    };
    args = [];
    method = prefix = definition = block = '';
    backgroundImage.split("").forEach(function(c) {
        if (mode === 0 && whitespace.indexOf(c) > -1) {
            return;
        }
        switch(c) {
        case '"':
            if(!quote) {
                quote = c;
            } else if(quote === c) {
                quote = null;
            }
            break;
        case '(':
            if(quote) {
                break;
            } else if(mode === 0) {
                mode = 1;
                block += c;
                return;
            } else {
                numParen++;
            }
            break;
        case ')':
            if (quote) {
                break;
            } else if(mode === 1) {
                if(numParen === 0) {
                    mode = 0;
                    block += c;
                    appendResult();
                    return;
                } else {
                    numParen--;
                }
            }
            break;

        case ',':
            if (quote) {
                break;
            } else if(mode === 0) {
                appendResult();
                return;
            } else if (mode === 1) {
                if (numParen === 0 && !method.match(/^url$/i)) {
                    args.push(definition);
                    definition = '';
                    block += c;
                    return;
                }
            }
            break;
        }

        block += c;
        if (mode === 0) {
            method += c;
        } else {
            definition += c;
        }
    });

    appendResult();
    return results;
}

function removePx(str) {
    return str.replace("px", "");
}

function asFloat(str) {
    return parseFloat(str);
}

function getBounds(node) {
    if (node.getBoundingClientRect) {
        var clientRect = node.getBoundingClientRect();
        var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
        return {
            top: clientRect.top,
            bottom: clientRect.bottom || (clientRect.top + clientRect.height),
            right: clientRect.left + width,
            left: clientRect.left,
            width:  width,
            height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
        };
    }
    return {};
}

function offsetBounds(node) {
    var parent = node.offsetParent ? offsetBounds(node.offsetParent) : {top: 0, left: 0};

    return {
        top: node.offsetTop + parent.top,
        bottom: node.offsetTop + node.offsetHeight + parent.top,
        right: node.offsetLeft + parent.left + node.offsetWidth,
        left: node.offsetLeft + parent.left,
        width: node.offsetWidth,
        height: node.offsetHeight
    };
}

function NodeParser(element, renderer, support, imageLoader, options) {
    log("Starting NodeParser");
    this.renderer = renderer;
    this.options = options;
    this.range = null;
    this.support = support;
    this.renderQueue = [];
    this.stack = new StackingContext(true, 1, element.ownerDocument, null);
    var parent = new NodeContainer(element, null);
    if (options.background) {
        renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));
    }
    if (element === element.ownerDocument.documentElement) {
        // http://www.w3.org/TR/css3-background/#special-backgrounds
        var canvasBackground = new NodeContainer(parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
        renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));
    }
    parent.visibile = parent.isElementVisible();
    this.createPseudoHideStyles(element.ownerDocument);
    this.disableAnimations(element.ownerDocument);
    this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {
        return container.visible = container.isElementVisible();
    }).map(this.getPseudoElements, this));
    this.fontMetrics = new FontMetrics();
    log("Fetched nodes, total:", this.nodes.length);
    log("Calculate overflow clips");
    this.calculateOverflowClips();
    log("Start fetching images");
    this.images = imageLoader.fetch(this.nodes.filter(isElement));
    this.ready = this.images.ready.then(bind(function() {
        log("Images loaded, starting parsing");
        log("Creating stacking contexts");
        this.createStackingContexts();
        log("Sorting stacking contexts");
        this.sortStackingContexts(this.stack);
        this.parse(this.stack);
        log("Render queue created with " + this.renderQueue.length + " items");
        return new Promise(bind(function(resolve) {
            if (!options.async) {
                this.renderQueue.forEach(this.paint, this);
                resolve();
            } else if (typeof(options.async) === "function") {
                options.async.call(this, this.renderQueue, resolve);
            } else if (this.renderQueue.length > 0){
                this.renderIndex = 0;
                this.asyncRenderer(this.renderQueue, resolve);
            } else {
                resolve();
            }
        }, this));
    }, this));
}

NodeParser.prototype.calculateOverflowClips = function() {
    this.nodes.forEach(function(container) {
        if (isElement(container)) {
            if (isPseudoElement(container)) {
                container.appendToDOM();
            }
            container.borders = this.parseBorders(container);
            var clip = (container.css('overflow') === "hidden") ? [container.borders.clip] : [];
            var cssClip = container.parseClip();
            if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
                clip.push([["rect",
                        container.bounds.left + cssClip.left,
                        container.bounds.top + cssClip.top,
                        cssClip.right - cssClip.left,
                        cssClip.bottom - cssClip.top
                ]]);
            }
            container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
            container.backgroundClip = (container.css('overflow') !== "hidden") ? container.clip.concat([container.borders.clip]) : container.clip;
            if (isPseudoElement(container)) {
                container.cleanDOM();
            }
        } else if (isTextNode(container)) {
            container.clip = hasParentClip(container) ? container.parent.clip : [];
        }
        if (!isPseudoElement(container)) {
            container.bounds = null;
        }
    }, this);
};

function hasParentClip(container) {
    return container.parent && container.parent.clip.length;
}

NodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {
    asyncTimer = asyncTimer || Date.now();
    this.paint(queue[this.renderIndex++]);
    if (queue.length === this.renderIndex) {
        resolve();
    } else if (asyncTimer + 20 > Date.now()) {
        this.asyncRenderer(queue, resolve, asyncTimer);
    } else {
        setTimeout(bind(function() {
            this.asyncRenderer(queue, resolve);
        }, this), 0);
    }
};

NodeParser.prototype.createPseudoHideStyles = function(document) {
    this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' +
        '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
};

NodeParser.prototype.disableAnimations = function(document) {
    this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' +
        '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
};

NodeParser.prototype.createStyles = function(document, styles) {
    var hidePseudoElements = document.createElement('style');
    hidePseudoElements.innerHTML = styles;
    document.body.appendChild(hidePseudoElements);
};

NodeParser.prototype.getPseudoElements = function(container) {
    var nodes = [[container]];
    if (container.node.nodeType === Node.ELEMENT_NODE) {
        var before = this.getPseudoElement(container, ":before");
        var after = this.getPseudoElement(container, ":after");

        if (before) {
            nodes.push(before);
        }

        if (after) {
            nodes.push(after);
        }
    }
    return flatten(nodes);
};

function toCamelCase(str) {
    return str.replace(/(\-[a-z])/g, function(match){
        return match.toUpperCase().replace('-','');
    });
}

NodeParser.prototype.getPseudoElement = function(container, type) {
    var style = container.computedStyle(type);
    if(!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
        return null;
    }

    var content = stripQuotes(style.content);
    var isImage = content.substr(0, 3) === 'url';
    var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
    var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);

    for (var i = style.length-1; i >= 0; i--) {
        var property = toCamelCase(style.item(i));
        pseudoNode.style[property] = style[property];
    }

    pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;

    if (isImage) {
        pseudoNode.src = parseBackgrounds(content)[0].args[0];
        return [pseudoContainer];
    } else {
        var text = document.createTextNode(content);
        pseudoNode.appendChild(text);
        return [pseudoContainer, new TextContainer(text, pseudoContainer)];
    }
};


NodeParser.prototype.getChildren = function(parentContainer) {
    return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {
        var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
        return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;
    }, this));
};

NodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {
    var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
    container.cloneTo(stack);
    var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
    parentStack.contexts.push(stack);
    container.stack = stack;
};

NodeParser.prototype.createStackingContexts = function() {
    this.nodes.forEach(function(container) {
        if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
            this.newStackingContext(container, true);
        } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {
            this.newStackingContext(container, false);
        } else {
            container.assignStack(container.parent.stack);
        }
    }, this);
};

NodeParser.prototype.isBodyWithTransparentRoot = function(container) {
    return container.node.nodeName === "BODY" && container.parent.color('backgroundColor').isTransparent();
};

NodeParser.prototype.isRootElement = function(container) {
    return container.parent === null;
};

NodeParser.prototype.sortStackingContexts = function(stack) {
    stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
    stack.contexts.forEach(this.sortStackingContexts, this);
};

NodeParser.prototype.parseTextBounds = function(container) {
    return function(text, index, textList) {
        if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
            if (this.support.rangeBounds && !container.parent.hasTransform()) {
                var offset = textList.slice(0, index).join("").length;
                return this.getRangeBounds(container.node, offset, text.length);
            } else if (container.node && typeof(container.node.data) === "string") {
                var replacementNode = container.node.splitText(text.length);
                var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
                container.node = replacementNode;
                return bounds;
            }
        } else if(!this.support.rangeBounds || container.parent.hasTransform()){
            container.node = container.node.splitText(text.length);
        }
        return {};
    };
};

NodeParser.prototype.getWrapperBounds = function(node, transform) {
    var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
    var parent = node.parentNode,
        backupText = node.cloneNode(true);

    wrapper.appendChild(node.cloneNode(true));
    parent.replaceChild(wrapper, node);
    var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
    parent.replaceChild(backupText, wrapper);
    return bounds;
};

NodeParser.prototype.getRangeBounds = function(node, offset, length) {
    var range = this.range || (this.range = node.ownerDocument.createRange());
    range.setStart(node, offset);
    range.setEnd(node, offset + length);
    return range.getBoundingClientRect();
};

function ClearTransform() {}

NodeParser.prototype.parse = function(stack) {
    // http://www.w3.org/TR/CSS21/visuren.html#z-index
    var negativeZindex = stack.contexts.filter(negativeZIndex); // 2. the child stacking contexts with negative stack levels (most negative first).
    var descendantElements = stack.children.filter(isElement);
    var descendantNonFloats = descendantElements.filter(not(isFloating));
    var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); // 3 the in-flow, non-inline-level, non-positioned descendants.
    var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); // 4. the non-positioned floats.
    var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
    var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.
    var text = stack.children.filter(isTextNode).filter(hasText);
    var positiveZindex = stack.contexts.filter(positiveZIndex); // 7. the child stacking contexts with positive stack levels (least positive first).
    negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats)
        .concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {
            this.renderQueue.push(container);
            if (isStackingContext(container)) {
                this.parse(container);
                this.renderQueue.push(new ClearTransform());
            }
        }, this);
};

NodeParser.prototype.paint = function(container) {
    try {
        if (container instanceof ClearTransform) {
            this.renderer.ctx.restore();
        } else if (isTextNode(container)) {
            if (isPseudoElement(container.parent)) {
                container.parent.appendToDOM();
            }
            this.paintText(container);
            if (isPseudoElement(container.parent)) {
                container.parent.cleanDOM();
            }
        } else {
            this.paintNode(container);
        }
    } catch(e) {
        log(e);
        if (this.options.strict) {
            throw e;
        }
    }
};

NodeParser.prototype.paintNode = function(container) {
    if (isStackingContext(container)) {
        this.renderer.setOpacity(container.opacity);
        this.renderer.ctx.save();
        if (container.hasTransform()) {
            this.renderer.setTransform(container.parseTransform());
        }
    }

    if (container.node.nodeName === "INPUT" && container.node.type === "checkbox") {
        this.paintCheckbox(container);
    } else if (container.node.nodeName === "INPUT" && container.node.type === "radio") {
        this.paintRadio(container);
    } else {
        this.paintElement(container);
    }
};

NodeParser.prototype.paintElement = function(container) {
    var bounds = container.parseBounds();
    this.renderer.clip(container.backgroundClip, function() {
        this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
    }, this);

    this.renderer.clip(container.clip, function() {
        this.renderer.renderBorders(container.borders.borders);
    }, this);

    this.renderer.clip(container.backgroundClip, function() {
        switch (container.node.nodeName) {
        case "svg":
        case "IFRAME":
            var imgContainer = this.images.get(container.node);
            if (imgContainer) {
                this.renderer.renderImage(container, bounds, container.borders, imgContainer);
            } else {
                log("Error loading <" + container.node.nodeName + ">", container.node);
            }
            break;
        case "IMG":
            var imageContainer = this.images.get(container.node.src);
            if (imageContainer) {
                this.renderer.renderImage(container, bounds, container.borders, imageContainer);
            } else {
                log("Error loading <img>", container.node.src);
            }
            break;
        case "CANVAS":
            this.renderer.renderImage(container, bounds, container.borders, {image: container.node});
            break;
        case "SELECT":
        case "INPUT":
        case "TEXTAREA":
            this.paintFormValue(container);
            break;
        }
    }, this);
};

NodeParser.prototype.paintCheckbox = function(container) {
    var b = container.parseBounds();

    var size = Math.min(b.width, b.height);
    var bounds = {width: size - 1, height: size - 1, top: b.top, left: b.left};
    var r = [3, 3];
    var radius = [r, r, r, r];
    var borders = [1,1,1,1].map(function(w) {
        return {color: new Color('#A5A5A5'), width: w};
    });

    var borderPoints = calculateCurvePoints(bounds, radius, borders);

    this.renderer.clip(container.backgroundClip, function() {
        this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color("#DEDEDE"));
        this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius));
        if (container.node.checked) {
            this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', (size - 3) + "px", 'arial');
            this.renderer.text("\u2714", bounds.left + size / 6, bounds.top + size - 1);
        }
    }, this);
};

NodeParser.prototype.paintRadio = function(container) {
    var bounds = container.parseBounds();

    var size = Math.min(bounds.width, bounds.height) - 2;

    this.renderer.clip(container.backgroundClip, function() {
        this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5'));
        if (container.node.checked) {
            this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));
        }
    }, this);
};

NodeParser.prototype.paintFormValue = function(container) {
    var value = container.getValue();
    if (value.length > 0) {
        var document = container.node.ownerDocument;
        var wrapper = document.createElement('html2canvaswrapper');
        var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color',
            'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom',
            'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth',
            'boxSizing', 'whiteSpace', 'wordWrap'];

        properties.forEach(function(property) {
            try {
                wrapper.style[property] = container.css(property);
            } catch(e) {
                // Older IE has issues with "border"
                log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
            }
        });
        var bounds = container.parseBounds();
        wrapper.style.position = "fixed";
        wrapper.style.left = bounds.left + "px";
        wrapper.style.top = bounds.top + "px";
        wrapper.textContent = value;
        document.body.appendChild(wrapper);
        this.paintText(new TextContainer(wrapper.firstChild, container));
        document.body.removeChild(wrapper);
    }
};

NodeParser.prototype.paintText = function(container) {
    container.applyTextTransform();
    var characters = window.html2canvas.punycode.ucs2.decode(container.node.data);
    var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {
        return window.html2canvas.punycode.ucs2.encode([character]);
    });

    var weight = container.parent.fontWeight();
    var size = container.parent.css('fontSize');
    var family = container.parent.css('fontFamily');
    var shadows = container.parent.parseTextShadows();

    this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
    if (shadows.length) {
        // TODO: support multiple text shadows
        this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
    } else {
        this.renderer.clearShadow();
    }

    this.renderer.clip(container.parent.clip, function() {
        textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {
            if (bounds) {
                this.renderer.text(textList[index], bounds.left, bounds.bottom);
                this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
            }
        }, this);
    }, this);
};

NodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {
    switch(container.css("textDecoration").split(" ")[0]) {
    case "underline":
        // Draws a line at the baseline of the font
        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
        this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color("color"));
        break;
    case "overline":
        this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color("color"));
        break;
    case "line-through":
        // TODO try and find exact position for line-through
        this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color("color"));
        break;
    }
};

var borderColorTransforms = {
    inset: [
        ["darken", 0.60],
        ["darken", 0.10],
        ["darken", 0.10],
        ["darken", 0.60]
    ]
};

NodeParser.prototype.parseBorders = function(container) {
    var nodeBounds = container.parseBounds();
    var radius = getBorderRadiusData(container);
    var borders = ["Top", "Right", "Bottom", "Left"].map(function(side, index) {
        var style = container.css('border' + side + 'Style');
        var color = container.color('border' + side + 'Color');
        if (style === "inset" && color.isBlack()) {
            color = new Color([255, 255, 255, color.a]); // this is wrong, but
        }
        var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null;
        return {
            width: container.cssInt('border' + side + 'Width'),
            color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color,
            args: null
        };
    });
    var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);

    return {
        clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
        borders: calculateBorders(borders, nodeBounds, borderPoints, radius)
    };
};

function calculateBorders(borders, nodeBounds, borderPoints, radius) {
    return borders.map(function(border, borderSide) {
        if (border.width > 0) {
            var bx = nodeBounds.left;
            var by = nodeBounds.top;
            var bw = nodeBounds.width;
            var bh = nodeBounds.height - (borders[2].width);

            switch(borderSide) {
            case 0:
                // top border
                bh = borders[0].width;
                border.args = drawSide({
                        c1: [bx, by],
                        c2: [bx + bw, by],
                        c3: [bx + bw - borders[1].width, by + bh],
                        c4: [bx + borders[3].width, by + bh]
                    }, radius[0], radius[1],
                    borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                break;
            case 1:
                // right border
                bx = nodeBounds.left + nodeBounds.width - (borders[1].width);
                bw = borders[1].width;

                border.args = drawSide({
                        c1: [bx + bw, by],
                        c2: [bx + bw, by + bh + borders[2].width],
                        c3: [bx, by + bh],
                        c4: [bx, by + borders[0].width]
                    }, radius[1], radius[2],
                    borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                break;
            case 2:
                // bottom border
                by = (by + nodeBounds.height) - (borders[2].width);
                bh = borders[2].width;
                border.args = drawSide({
                        c1: [bx + bw, by + bh],
                        c2: [bx, by + bh],
                        c3: [bx + borders[3].width, by],
                        c4: [bx + bw - borders[3].width, by]
                    }, radius[2], radius[3],
                    borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                break;
            case 3:
                // left border
                bw = borders[3].width;
                border.args = drawSide({
                        c1: [bx, by + bh + borders[2].width],
                        c2: [bx, by],
                        c3: [bx + bw, by + borders[0].width],
                        c4: [bx + bw, by + bh]
                    }, radius[3], radius[0],
                    borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                break;
            }
        }
        return border;
    });
}

NodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {
    var backgroundClip = container.css('backgroundClip'),
        borderArgs = [];

    switch(backgroundClip) {
    case "content-box":
    case "padding-box":
        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
        break;

    default:
        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
        break;
    }

    return borderArgs;
};

function getCurvePoints(x, y, r1, r2) {
    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
    var ox = (r1) * kappa, // control point offset horizontal
        oy = (r2) * kappa, // control point offset vertical
        xm = x + r1, // x-middle
        ym = y + r2; // y-middle
    return {
        topLeft: bezierCurve({x: x, y: ym}, {x: x, y: ym - oy}, {x: xm - ox, y: y}, {x: xm, y: y}),
        topRight: bezierCurve({x: x, y: y}, {x: x + ox,y: y}, {x: xm, y: ym - oy}, {x: xm, y: ym}),
        bottomRight: bezierCurve({x: xm, y: y}, {x: xm, y: y + oy}, {x: x + ox, y: ym}, {x: x, y: ym}),
        bottomLeft: bezierCurve({x: xm, y: ym}, {x: xm - ox, y: ym}, {x: x, y: y + oy}, {x: x, y:y})
    };
}

function calculateCurvePoints(bounds, borderRadius, borders) {
    var x = bounds.left,
        y = bounds.top,
        width = bounds.width,
        height = bounds.height,

        tlh = borderRadius[0][0],
        tlv = borderRadius[0][1],
        trh = borderRadius[1][0],
        trv = borderRadius[1][1],
        brh = borderRadius[2][0],
        brv = borderRadius[2][1],
        blh = borderRadius[3][0],
        blv = borderRadius[3][1];

    var topWidth = width - trh,
        rightHeight = height - brv,
        bottomWidth = width - brh,
        leftHeight = height - blv;

    return {
        topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
        topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
        topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
        topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
        bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
        bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width),  brv - borders[2].width).bottomRight.subdivide(0.5),
        bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
        bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
    };
}

function bezierCurve(start, startControl, endControl, end) {
    var lerp = function (a, b, t) {
        return {
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t
        };
    };

    return {
        start: start,
        startControl: startControl,
        endControl: endControl,
        end: end,
        subdivide: function(t) {
            var ab = lerp(start, startControl, t),
                bc = lerp(startControl, endControl, t),
                cd = lerp(endControl, end, t),
                abbc = lerp(ab, bc, t),
                bccd = lerp(bc, cd, t),
                dest = lerp(abbc, bccd, t);
            return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
        },
        curveTo: function(borderArgs) {
            borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
        },
        curveToReversed: function(borderArgs) {
            borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
        }
    };
}

function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
    var borderArgs = [];

    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
        outer1[1].curveTo(borderArgs);
    } else {
        borderArgs.push([ "line", borderData.c1[0], borderData.c1[1]]);
    }

    if (radius2[0] > 0 || radius2[1] > 0) {
        borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
        outer2[0].curveTo(borderArgs);
        borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
        inner2[0].curveToReversed(borderArgs);
    } else {
        borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
        borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
    }

    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
        inner1[1].curveToReversed(borderArgs);
    } else {
        borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
    }

    return borderArgs;
}

function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
        corner1[0].curveTo(borderArgs);
        corner1[1].curveTo(borderArgs);
    } else {
        borderArgs.push(["line", x, y]);
    }

    if (radius2[0] > 0 || radius2[1] > 0) {
        borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
    }
}

function negativeZIndex(container) {
    return container.cssInt("zIndex") < 0;
}

function positiveZIndex(container) {
    return container.cssInt("zIndex") > 0;
}

function zIndex0(container) {
    return container.cssInt("zIndex") === 0;
}

function inlineLevel(container) {
    return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
}

function isStackingContext(container) {
    return (container instanceof StackingContext);
}

function hasText(container) {
    return container.node.data.trim().length > 0;
}

function noLetterSpacing(container) {
    return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing")));
}

function getBorderRadiusData(container) {
    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
        var value = container.css('border' + side + 'Radius');
        var arr = value.split(" ");
        if (arr.length <= 1) {
            arr[1] = arr[0];
        }
        return arr.map(asInt);
    });
}

function renderableNode(node) {
    return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);
}

function isPositionedForStacking(container) {
    var position = container.css("position");
    var zIndex = (["absolute", "relative", "fixed"].indexOf(position) !== -1) ? container.css("zIndex") : "auto";
    return zIndex !== "auto";
}

function isPositioned(container) {
    return container.css("position") !== "static";
}

function isFloating(container) {
    return container.css("float") !== "none";
}

function isInlineBlock(container) {
    return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
}

function not(callback) {
    var context = this;
    return function() {
        return !callback.apply(context, arguments);
    };
}

function isElement(container) {
    return container.node.nodeType === Node.ELEMENT_NODE;
}

function isPseudoElement(container) {
    return container.isPseudoElement === true;
}

function isTextNode(container) {
    return container.node.nodeType === Node.TEXT_NODE;
}

function zIndexSort(contexts) {
    return function(a, b) {
        return (a.cssInt("zIndex") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt("zIndex") + (contexts.indexOf(b) / contexts.length));
    };
}

function hasOpacity(container) {
    return container.getOpacity() < 1;
}

function bind(callback, context) {
    return function() {
        return callback.apply(context, arguments);
    };
}

function asInt(value) {
    return parseInt(value, 10);
}

function getWidth(border) {
    return border.width;
}

function nonIgnoredElement(nodeContainer) {
    return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1);
}

function flatten(arrays) {
    return [].concat.apply([], arrays);
}

function stripQuotes(content) {
    var first = content.substr(0, 1);
    return (first === content.substr(content.length - 1) && first.match(/'|"/)) ? content.substr(1, content.length - 2) : content;
}

function getWords(characters) {
    var words = [], i = 0, onWordBoundary = false, word;
    while(characters.length) {
        if (isWordBoundary(characters[i]) === onWordBoundary) {
            word = characters.splice(0, i);
            if (word.length) {
                words.push(window.html2canvas.punycode.ucs2.encode(word));
            }
            onWordBoundary =! onWordBoundary;
            i = 0;
        } else {
            i++;
        }

        if (i >= characters.length) {
            word = characters.splice(0, i);
            if (word.length) {
                words.push(window.html2canvas.punycode.ucs2.encode(word));
            }
        }
    }
    return words;
}

function isWordBoundary(characterCode) {
    return [
        32, // <space>
        13, // \r
        10, // \n
        9, // \t
        45 // -
    ].indexOf(characterCode) !== -1;
}

function hasUnicode(string) {
    return (/[^\u0000-\u00ff]/).test(string);
}

function Proxy(src, proxyUrl, document) {
    if (!proxyUrl) {
        return Promise.reject("No proxy configured");
    }
    var callback = createCallback(supportsCORS);
    var url = createProxyUrl(proxyUrl, src, callback);

    return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {
        return decode64(response.content);
    }));
}
var proxyCount = 0;

var supportsCORS = ('withCredentials' in new XMLHttpRequest());
var supportsCORSImage = ('crossOrigin' in new Image());

function ProxyURL(src, proxyUrl, document) {
    var callback = createCallback(supportsCORSImage);
    var url = createProxyUrl(proxyUrl, src, callback);
    return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {
        return "data:" + response.type + ";base64," + response.content;
    }));
}

function jsonp(document, url, callback) {
    return new Promise(function(resolve, reject) {
        var s = document.createElement("script");
        var cleanup = function() {
            delete window.html2canvas.proxy[callback];
            document.body.removeChild(s);
        };
        window.html2canvas.proxy[callback] = function(response) {
            cleanup();
            resolve(response);
        };
        s.src = url;
        s.onerror = function(e) {
            cleanup();
            reject(e);
        };
        document.body.appendChild(s);
    });
}

function createCallback(useCORS) {
    return !useCORS ? "html2canvas_" + Date.now() + "_" + (++proxyCount) + "_" + Math.round(Math.random() * 100000) : "";
}

function createProxyUrl(proxyUrl, src, callback) {
    return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
}

function ProxyImageContainer(src, proxy) {
    var link = document.createElement("a");
    link.href = src;
    src = link.href;
    this.src = src;
    this.image = new Image();
    var self = this;
    this.promise = new Promise(function(resolve, reject) {
        self.image.crossOrigin = "Anonymous";
        self.image.onload = resolve;
        self.image.onerror = reject;

        new ProxyURL(src, proxy, document).then(function(url) {
            self.image.src = url;
        })['catch'](reject);
    });
}

function PseudoElementContainer(node, parent, type) {
    NodeContainer.call(this, node, parent);
    this.isPseudoElement = true;
    this.before = type === ":before";
}

PseudoElementContainer.prototype.cloneTo = function(stack) {
    PseudoElementContainer.prototype.cloneTo.call(this, stack);
    stack.isPseudoElement = true;
    stack.before = this.before;
};

PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);

PseudoElementContainer.prototype.appendToDOM = function() {
    if (this.before) {
        this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
    } else {
        this.parent.node.appendChild(this.node);
    }
    this.parent.node.className += " " + this.getHideClass();
};

PseudoElementContainer.prototype.cleanDOM = function() {
    this.node.parentNode.removeChild(this.node);
    this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
};

PseudoElementContainer.prototype.getHideClass = function() {
    return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
};

PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

function Renderer(width, height, images, options, document) {
    this.width = width;
    this.height = height;
    this.images = images;
    this.options = options;
    this.document = document;
}

Renderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {
    var paddingLeft = container.cssInt('paddingLeft'),
        paddingTop = container.cssInt('paddingTop'),
        paddingRight = container.cssInt('paddingRight'),
        paddingBottom = container.cssInt('paddingBottom'),
        borders = borderData.borders;

    var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
    var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
    this.drawImage(
        imageContainer,
        0,
        0,
        imageContainer.image.width || width,
        imageContainer.image.height || height,
        bounds.left + paddingLeft + borders[3].width,
        bounds.top + paddingTop + borders[0].width,
        width,
        height
    );
};

Renderer.prototype.renderBackground = function(container, bounds, borderData) {
    if (bounds.height > 0 && bounds.width > 0) {
        this.renderBackgroundColor(container, bounds);
        this.renderBackgroundImage(container, bounds, borderData);
    }
};

Renderer.prototype.renderBackgroundColor = function(container, bounds) {
    var color = container.color("backgroundColor");
    if (!color.isTransparent()) {
        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);
    }
};

Renderer.prototype.renderBorders = function(borders) {
    borders.forEach(this.renderBorder, this);
};

Renderer.prototype.renderBorder = function(data) {
    if (!data.color.isTransparent() && data.args !== null) {
        this.drawShape(data.args, data.color);
    }
};

Renderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {
    var backgroundImages = container.parseBackgroundImages();
    backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {
        switch(backgroundImage.method) {
        case "url":
            var image = this.images.get(backgroundImage.args[0]);
            if (image) {
                this.renderBackgroundRepeating(container, bounds, image, arr.length - (index+1), borderData);
            } else {
                log("Error loading background-image", backgroundImage.args[0]);
            }
            break;
        case "linear-gradient":
        case "gradient":
            var gradientImage = this.images.get(backgroundImage.value);
            if (gradientImage) {
                this.renderBackgroundGradient(gradientImage, bounds, borderData);
            } else {
                log("Error loading background-image", backgroundImage.args[0]);
            }
            break;
        case "none":
            break;
        default:
            log("Unknown background-image type", backgroundImage.args[0]);
        }
    }, this);
};

Renderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {
    var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
    var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
    var repeat = container.parseBackgroundRepeat(index);
    switch (repeat) {
    case "repeat-x":
    case "repeat no-repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
        break;
    case "repeat-y":
    case "no-repeat repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
        break;
    case "no-repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
        break;
    default:
        this.renderBackgroundRepeat(imageContainer, position, size, {top: bounds.top, left: bounds.left}, borderData[3], borderData[0]);
        break;
    }
};

function StackingContext(hasOwnStacking, opacity, element, parent) {
    NodeContainer.call(this, element, parent);
    this.ownStacking = hasOwnStacking;
    this.contexts = [];
    this.children = [];
    this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
}

StackingContext.prototype = Object.create(NodeContainer.prototype);

StackingContext.prototype.getParentStack = function(context) {
    var parentStack = (this.parent) ? this.parent.stack : null;
    return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;
};

function Support(document) {
    this.rangeBounds = this.testRangeBounds(document);
    this.cors = this.testCORS();
    this.svg = this.testSVG();
}

Support.prototype.testRangeBounds = function(document) {
    var range, testElement, rangeBounds, rangeHeight, support = false;

    if (document.createRange) {
        range = document.createRange();
        if (range.getBoundingClientRect) {
            testElement = document.createElement('boundtest');
            testElement.style.height = "123px";
            testElement.style.display = "block";
            document.body.appendChild(testElement);

            range.selectNode(testElement);
            rangeBounds = range.getBoundingClientRect();
            rangeHeight = rangeBounds.height;

            if (rangeHeight === 123) {
                support = true;
            }
            document.body.removeChild(testElement);
        }
    }

    return support;
};

Support.prototype.testCORS = function() {
    return typeof((new Image()).crossOrigin) !== "undefined";
};

Support.prototype.testSVG = function() {
    var img = new Image();
    var canvas = document.createElement("canvas");
    var ctx =  canvas.getContext("2d");
    img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";

    try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
    } catch(e) {
        return false;
    }
    return true;
};

function SVGContainer(src) {
    this.src = src;
    this.image = null;
    var self = this;

    this.promise = this.hasFabric().then(function() {
        return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));
    }).then(function(svg) {
        return new Promise(function(resolve) {
            html2canvas.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
        });
    });
}

SVGContainer.prototype.hasFabric = function() {
    return !html2canvas.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
};

SVGContainer.prototype.inlineFormatting = function(src) {
    return (/^data:image\/svg\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);
};

SVGContainer.prototype.removeContentType = function(src) {
    return src.replace(/^data:image\/svg\+xml(;base64)?,/,'');
};

SVGContainer.prototype.isInline = function(src) {
    return (/^data:image\/svg\+xml/i.test(src));
};

SVGContainer.prototype.createCanvas = function(resolve) {
    var self = this;
    return function (objects, options) {
        var canvas = new html2canvas.fabric.StaticCanvas('c');
        self.image = canvas.lowerCanvasEl;
        canvas
            .setWidth(options.width)
            .setHeight(options.height)
            .add(html2canvas.fabric.util.groupSVGElements(objects, options))
            .renderAll();
        resolve(canvas.lowerCanvasEl);
    };
};

SVGContainer.prototype.decode64 = function(str) {
    return (typeof(window.atob) === "function") ? window.atob(str) : decode64(str);
};

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

function decode64(base64) {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var len = base64.length, i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;

    var output = "";

    for (i = 0; i < len; i+=4) {
        encoded1 = chars.indexOf(base64[i]);
        encoded2 = chars.indexOf(base64[i+1]);
        encoded3 = chars.indexOf(base64[i+2]);
        encoded4 = chars.indexOf(base64[i+3]);

        byte1 = (encoded1 << 2) | (encoded2 >> 4);
        byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        byte3 = ((encoded3 & 3) << 6) | encoded4;
        if (encoded3 === 64) {
            output += String.fromCharCode(byte1);
        } else if (encoded4 === 64 || encoded4 === -1) {
            output += String.fromCharCode(byte1, byte2);
        } else{
            output += String.fromCharCode(byte1, byte2, byte3);
        }
    }

    return output;
}

function SVGNodeContainer(node, native) {
    this.src = node;
    this.image = null;
    var self = this;

    this.promise = native ? new Promise(function(resolve, reject) {
        self.image = new Image();
        self.image.onload = resolve;
        self.image.onerror = reject;
        self.image.src = "data:image/svg+xml," + (new XMLSerializer()).serializeToString(node);
        if (self.image.complete === true) {
            resolve(self.image);
        }
    }) : this.hasFabric().then(function() {
        return new Promise(function(resolve) {
            html2canvas.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
        });
    });
}

SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

function TextContainer(node, parent) {
    NodeContainer.call(this, node, parent);
}

TextContainer.prototype = Object.create(NodeContainer.prototype);

TextContainer.prototype.applyTextTransform = function() {
    this.node.data = this.transform(this.parent.css("textTransform"));
};

TextContainer.prototype.transform = function(transform) {
    var text = this.node.data;
    switch(transform){
        case "lowercase":
            return text.toLowerCase();
        case "capitalize":
            return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
        case "uppercase":
            return text.toUpperCase();
        default:
            return text;
    }
};

function capitalize(m, p1, p2) {
    if (m.length > 0) {
        return p1 + p2.toUpperCase();
    }
}

function WebkitGradientContainer(imageData) {
    GradientContainer.apply(this, arguments);
    this.type = (imageData.args[0] === "linear") ? this.TYPES.LINEAR : this.TYPES.RADIAL;
}

WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

function XHR(url) {
    return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url);

        xhr.onload = function() {
            if (xhr.status === 200) {
                resolve(xhr.responseText);
            } else {
                reject(new Error(xhr.statusText));
            }
        };

        xhr.onerror = function() {
            reject(new Error("Network Error"));
        };

        xhr.send();
    });
}

function CanvasRenderer(width, height) {
    Renderer.apply(this, arguments);
    this.canvas = this.options.canvas || this.document.createElement("canvas");
    if (!this.options.canvas) {
        this.canvas.width = width;
        this.canvas.height = height;
    }
    this.ctx = this.canvas.getContext("2d");
    this.taintCtx = this.document.createElement("canvas").getContext("2d");
    this.ctx.textBaseline = "bottom";
    this.variables = {};
    log("Initialized CanvasRenderer with size", width, "x", height);
}

CanvasRenderer.prototype = Object.create(Renderer.prototype);

CanvasRenderer.prototype.setFillStyle = function(fillStyle) {
    this.ctx.fillStyle = typeof(fillStyle) === "object" && !!fillStyle.isColor ? fillStyle.toString() : fillStyle;
    return this.ctx;
};

CanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {
    this.setFillStyle(color).fillRect(left, top, width, height);
};

CanvasRenderer.prototype.circle = function(left, top, size, color) {
    this.setFillStyle(color);
    this.ctx.beginPath();
    this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI*2, true);
    this.ctx.closePath();
    this.ctx.fill();
};

CanvasRenderer.prototype.circleStroke = function(left, top, size, color, stroke, strokeColor) {
    this.circle(left, top, size, color);
    this.ctx.strokeStyle = strokeColor.toString();
    this.ctx.stroke();
};

CanvasRenderer.prototype.drawShape = function(shape, color) {
    this.shape(shape);
    this.setFillStyle(color).fill();
};

CanvasRenderer.prototype.taints = function(imageContainer) {
    if (imageContainer.tainted === null) {
        this.taintCtx.drawImage(imageContainer.image, 0, 0);
        try {
            this.taintCtx.getImageData(0, 0, 1, 1);
            imageContainer.tainted = false;
        } catch(e) {
            this.taintCtx = document.createElement("canvas").getContext("2d");
            imageContainer.tainted = true;
        }
    }

    return imageContainer.tainted;
};

CanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (!this.taints(imageContainer) || this.options.allowTaint) {
        this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
    }
};

CanvasRenderer.prototype.clip = function(shapes, callback, context) {
    this.ctx.save();
    shapes.filter(hasEntries).forEach(function(shape) {
        this.shape(shape).clip();
    }, this);
    callback.call(context);
    this.ctx.restore();
};

CanvasRenderer.prototype.shape = function(shape) {
    this.ctx.beginPath();
    shape.forEach(function(point, index) {
        if (point[0] === "rect") {
            this.ctx.rect.apply(this.ctx, point.slice(1));
        } else {
            this.ctx[(index === 0) ? "moveTo" : point[0] + "To" ].apply(this.ctx, point.slice(1));
        }
    }, this);
    this.ctx.closePath();
    return this.ctx;
};

CanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {
    this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
};

CanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {
    this.setVariable("shadowColor", color.toString())
        .setVariable("shadowOffsetY", offsetX)
        .setVariable("shadowOffsetX", offsetY)
        .setVariable("shadowBlur", blur);
};

CanvasRenderer.prototype.clearShadow = function() {
    this.setVariable("shadowColor", "rgba(0,0,0,0)");
};

CanvasRenderer.prototype.setOpacity = function(opacity) {
    this.ctx.globalAlpha = opacity;
};

CanvasRenderer.prototype.setTransform = function(transform) {
    this.ctx.translate(transform.origin[0], transform.origin[1]);
    this.ctx.transform.apply(this.ctx, transform.matrix);
    this.ctx.translate(-transform.origin[0], -transform.origin[1]);
};

CanvasRenderer.prototype.setVariable = function(property, value) {
    if (this.variables[property] !== value) {
        this.variables[property] = this.ctx[property] = value;
    }

    return this;
};

CanvasRenderer.prototype.text = function(text, left, bottom) {
    this.ctx.fillText(text, left, bottom);
};

CanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
    var shape = [
        ["line", Math.round(left), Math.round(top)],
        ["line", Math.round(left + width), Math.round(top)],
        ["line", Math.round(left + width), Math.round(height + top)],
        ["line", Math.round(left), Math.round(height + top)]
    ];
    this.clip([shape], function() {
        this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
    }, this);
};

CanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
    var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft), offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
    this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
    this.ctx.translate(offsetX, offsetY);
    this.ctx.fill();
    this.ctx.translate(-offsetX, -offsetY);
};

CanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {
    if (gradientImage instanceof LinearGradientContainer) {
        var gradient = this.ctx.createLinearGradient(
            bounds.left + bounds.width * gradientImage.x0,
            bounds.top + bounds.height * gradientImage.y0,
            bounds.left +  bounds.width * gradientImage.x1,
            bounds.top +  bounds.height * gradientImage.y1);
        gradientImage.colorStops.forEach(function(colorStop) {
            gradient.addColorStop(colorStop.stop, colorStop.color.toString());
        });
        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
    }
};

CanvasRenderer.prototype.resizeImage = function(imageContainer, size) {
    var image = imageContainer.image;
    if(image.width === size.width && image.height === size.height) {
        return image;
    }

    var ctx, canvas = document.createElement('canvas');
    canvas.width = size.width;
    canvas.height = size.height;
    ctx = canvas.getContext("2d");
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height );
    return canvas;
};

function hasEntries(array) {
    return array.length > 0;
}

}).call({}, typeof(window) !== "undefined" ? window : undefined, typeof(document) !== "undefined" ? document : undefined);
/*!
 * jScrollPane - v2.0.23 - 2016-01-28
 * http://jscrollpane.kelvinluck.com/
 *
 * Copyright (c) 2014 Kelvin Luck
 * Dual licensed under the MIT or GPL licenses.
 */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):"object"==typeof exports?module.exports=a(require("jquery")):a(jQuery)}(function(a){a.fn.jScrollPane=function(b){function c(b,c){function d(c){var f,h,j,k,l,o,p=!1,q=!1;if(N=c,void 0===O)l=b.scrollTop(),o=b.scrollLeft(),b.css({overflow:"hidden",padding:0}),P=b.innerWidth()+rb,Q=b.innerHeight(),b.width(P),O=a('<div class="jspPane" />').css("padding",qb).append(b.children()),R=a('<div class="jspContainer" />').css({width:P+"px",height:Q+"px"}).append(O).appendTo(b);else{if(b.css("width",""),p=N.stickToBottom&&A(),q=N.stickToRight&&B(),k=b.innerWidth()+rb!=P||b.outerHeight()!=Q,k&&(P=b.innerWidth()+rb,Q=b.innerHeight(),R.css({width:P+"px",height:Q+"px"})),!k&&sb==S&&O.outerHeight()==T)return void b.width(P);sb=S,O.css("width",""),b.width(P),R.find(">.jspVerticalBar,>.jspHorizontalBar").remove().end()}O.css("overflow","auto"),S=c.contentWidth?c.contentWidth:O[0].scrollWidth,T=O[0].scrollHeight,O.css("overflow",""),U=S/P,V=T/Q,W=V>1,X=U>1,X||W?(b.addClass("jspScrollable"),f=N.maintainPosition&&($||bb),f&&(h=y(),j=z()),e(),g(),i(),f&&(w(q?S-P:h,!1),v(p?T-Q:j,!1)),F(),C(),L(),N.enableKeyboardNavigation&&H(),N.clickOnTrack&&m(),J(),N.hijackInternalLinks&&K()):(b.removeClass("jspScrollable"),O.css({top:0,left:0,width:R.width()-rb}),D(),G(),I(),n()),N.autoReinitialise&&!pb?pb=setInterval(function(){d(N)},N.autoReinitialiseDelay):!N.autoReinitialise&&pb&&clearInterval(pb),l&&b.scrollTop(0)&&v(l,!1),o&&b.scrollLeft(0)&&w(o,!1),b.trigger("jsp-initialised",[X||W])}function e(){W&&(R.append(a('<div class="jspVerticalBar" />').append(a('<div class="jspCap jspCapTop" />'),a('<div class="jspTrack" />').append(a('<div class="jspDrag" />').append(a('<div class="jspDragTop" />'),a('<div class="jspDragBottom" />'))),a('<div class="jspCap jspCapBottom" />'))),cb=R.find(">.jspVerticalBar"),db=cb.find(">.jspTrack"),Y=db.find(">.jspDrag"),N.showArrows&&(hb=a('<a class="jspArrow jspArrowUp" />').bind("mousedown.jsp",k(0,-1)).bind("click.jsp",E),ib=a('<a class="jspArrow jspArrowDown" />').bind("mousedown.jsp",k(0,1)).bind("click.jsp",E),N.arrowScrollOnHover&&(hb.bind("mouseover.jsp",k(0,-1,hb)),ib.bind("mouseover.jsp",k(0,1,ib))),j(db,N.verticalArrowPositions,hb,ib)),fb=Q,R.find(">.jspVerticalBar>.jspCap:visible,>.jspVerticalBar>.jspArrow").each(function(){fb-=a(this).outerHeight()}),Y.hover(function(){Y.addClass("jspHover")},function(){Y.removeClass("jspHover")}).bind("mousedown.jsp",function(b){a("html").bind("dragstart.jsp selectstart.jsp",E),Y.addClass("jspActive");var c=b.pageY-Y.position().top;return a("html").bind("mousemove.jsp",function(a){p(a.pageY-c,!1)}).bind("mouseup.jsp mouseleave.jsp",o),!1}),f())}function f(){db.height(fb+"px"),$=0,eb=N.verticalGutter+db.outerWidth(),O.width(P-eb-rb);try{0===cb.position().left&&O.css("margin-left",eb+"px")}catch(a){}}function g(){X&&(R.append(a('<div class="jspHorizontalBar" />').append(a('<div class="jspCap jspCapLeft" />'),a('<div class="jspTrack" />').append(a('<div class="jspDrag" />').append(a('<div class="jspDragLeft" />'),a('<div class="jspDragRight" />'))),a('<div class="jspCap jspCapRight" />'))),jb=R.find(">.jspHorizontalBar"),kb=jb.find(">.jspTrack"),_=kb.find(">.jspDrag"),N.showArrows&&(nb=a('<a class="jspArrow jspArrowLeft" />').bind("mousedown.jsp",k(-1,0)).bind("click.jsp",E),ob=a('<a class="jspArrow jspArrowRight" />').bind("mousedown.jsp",k(1,0)).bind("click.jsp",E),N.arrowScrollOnHover&&(nb.bind("mouseover.jsp",k(-1,0,nb)),ob.bind("mouseover.jsp",k(1,0,ob))),j(kb,N.horizontalArrowPositions,nb,ob)),_.hover(function(){_.addClass("jspHover")},function(){_.removeClass("jspHover")}).bind("mousedown.jsp",function(b){a("html").bind("dragstart.jsp selectstart.jsp",E),_.addClass("jspActive");var c=b.pageX-_.position().left;return a("html").bind("mousemove.jsp",function(a){r(a.pageX-c,!1)}).bind("mouseup.jsp mouseleave.jsp",o),!1}),lb=R.innerWidth(),h())}function h(){R.find(">.jspHorizontalBar>.jspCap:visible,>.jspHorizontalBar>.jspArrow").each(function(){lb-=a(this).outerWidth()}),kb.width(lb+"px"),bb=0}function i(){if(X&&W){var b=kb.outerHeight(),c=db.outerWidth();fb-=b,a(jb).find(">.jspCap:visible,>.jspArrow").each(function(){lb+=a(this).outerWidth()}),lb-=c,Q-=c,P-=b,kb.parent().append(a('<div class="jspCorner" />').css("width",b+"px")),f(),h()}X&&O.width(R.outerWidth()-rb+"px"),T=O.outerHeight(),V=T/Q,X&&(mb=Math.ceil(1/U*lb),mb>N.horizontalDragMaxWidth?mb=N.horizontalDragMaxWidth:mb<N.horizontalDragMinWidth&&(mb=N.horizontalDragMinWidth),_.width(mb+"px"),ab=lb-mb,s(bb)),W&&(gb=Math.ceil(1/V*fb),gb>N.verticalDragMaxHeight?gb=N.verticalDragMaxHeight:gb<N.verticalDragMinHeight&&(gb=N.verticalDragMinHeight),Y.height(gb+"px"),Z=fb-gb,q($))}function j(a,b,c,d){var e,f="before",g="after";"os"==b&&(b=/Mac/.test(navigator.platform)?"after":"split"),b==f?g=b:b==g&&(f=b,e=c,c=d,d=e),a[f](c)[g](d)}function k(a,b,c){return function(){return l(a,b,this,c),this.blur(),!1}}function l(b,c,d,e){d=a(d).addClass("jspActive");var f,g,h=!0,i=function(){0!==b&&tb.scrollByX(b*N.arrowButtonSpeed),0!==c&&tb.scrollByY(c*N.arrowButtonSpeed),g=setTimeout(i,h?N.initialDelay:N.arrowRepeatFreq),h=!1};i(),f=e?"mouseout.jsp":"mouseup.jsp",e=e||a("html"),e.bind(f,function(){d.removeClass("jspActive"),g&&clearTimeout(g),g=null,e.unbind(f)})}function m(){n(),W&&db.bind("mousedown.jsp",function(b){if(void 0===b.originalTarget||b.originalTarget==b.currentTarget){var c,d=a(this),e=d.offset(),f=b.pageY-e.top-$,g=!0,h=function(){var a=d.offset(),e=b.pageY-a.top-gb/2,j=Q*N.scrollPagePercent,k=Z*j/(T-Q);if(0>f)$-k>e?tb.scrollByY(-j):p(e);else{if(!(f>0))return void i();e>$+k?tb.scrollByY(j):p(e)}c=setTimeout(h,g?N.initialDelay:N.trackClickRepeatFreq),g=!1},i=function(){c&&clearTimeout(c),c=null,a(document).unbind("mouseup.jsp",i)};return h(),a(document).bind("mouseup.jsp",i),!1}}),X&&kb.bind("mousedown.jsp",function(b){if(void 0===b.originalTarget||b.originalTarget==b.currentTarget){var c,d=a(this),e=d.offset(),f=b.pageX-e.left-bb,g=!0,h=function(){var a=d.offset(),e=b.pageX-a.left-mb/2,j=P*N.scrollPagePercent,k=ab*j/(S-P);if(0>f)bb-k>e?tb.scrollByX(-j):r(e);else{if(!(f>0))return void i();e>bb+k?tb.scrollByX(j):r(e)}c=setTimeout(h,g?N.initialDelay:N.trackClickRepeatFreq),g=!1},i=function(){c&&clearTimeout(c),c=null,a(document).unbind("mouseup.jsp",i)};return h(),a(document).bind("mouseup.jsp",i),!1}})}function n(){kb&&kb.unbind("mousedown.jsp"),db&&db.unbind("mousedown.jsp")}function o(){a("html").unbind("dragstart.jsp selectstart.jsp mousemove.jsp mouseup.jsp mouseleave.jsp"),Y&&Y.removeClass("jspActive"),_&&_.removeClass("jspActive")}function p(c,d){if(W){0>c?c=0:c>Z&&(c=Z);var e=new a.Event("jsp-will-scroll-y");if(b.trigger(e,[c]),!e.isDefaultPrevented()){var f=c||0,g=0===f,h=f==Z,i=c/Z,j=-i*(T-Q);void 0===d&&(d=N.animateScroll),d?tb.animate(Y,"top",c,q,function(){b.trigger("jsp-user-scroll-y",[-j,g,h])}):(Y.css("top",c),q(c),b.trigger("jsp-user-scroll-y",[-j,g,h]))}}}function q(a){void 0===a&&(a=Y.position().top),R.scrollTop(0),$=a||0;var c=0===$,d=$==Z,e=a/Z,f=-e*(T-Q);(ub!=c||wb!=d)&&(ub=c,wb=d,b.trigger("jsp-arrow-change",[ub,wb,vb,xb])),t(c,d),O.css("top",f),b.trigger("jsp-scroll-y",[-f,c,d]).trigger("scroll")}function r(c,d){if(X){0>c?c=0:c>ab&&(c=ab);var e=new a.Event("jsp-will-scroll-x");if(b.trigger(e,[c]),!e.isDefaultPrevented()){var f=c||0,g=0===f,h=f==ab,i=c/ab,j=-i*(S-P);void 0===d&&(d=N.animateScroll),d?tb.animate(_,"left",c,s,function(){b.trigger("jsp-user-scroll-x",[-j,g,h])}):(_.css("left",c),s(c),b.trigger("jsp-user-scroll-x",[-j,g,h]))}}}function s(a){void 0===a&&(a=_.position().left),R.scrollTop(0),bb=a||0;var c=0===bb,d=bb==ab,e=a/ab,f=-e*(S-P);(vb!=c||xb!=d)&&(vb=c,xb=d,b.trigger("jsp-arrow-change",[ub,wb,vb,xb])),u(c,d),O.css("left",f),b.trigger("jsp-scroll-x",[-f,c,d]).trigger("scroll")}function t(a,b){N.showArrows&&(hb[a?"addClass":"removeClass"]("jspDisabled"),ib[b?"addClass":"removeClass"]("jspDisabled"))}function u(a,b){N.showArrows&&(nb[a?"addClass":"removeClass"]("jspDisabled"),ob[b?"addClass":"removeClass"]("jspDisabled"))}function v(a,b){var c=a/(T-Q);p(c*Z,b)}function w(a,b){var c=a/(S-P);r(c*ab,b)}function x(b,c,d){var e,f,g,h,i,j,k,l,m,n=0,o=0;try{e=a(b)}catch(p){return}for(f=e.outerHeight(),g=e.outerWidth(),R.scrollTop(0),R.scrollLeft(0);!e.is(".jspPane");)if(n+=e.position().top,o+=e.position().left,e=e.offsetParent(),/^body|html$/i.test(e[0].nodeName))return;h=z(),j=h+Q,h>n||c?l=n-N.horizontalGutter:n+f>j&&(l=n-Q+f+N.horizontalGutter),isNaN(l)||v(l,d),i=y(),k=i+P,i>o||c?m=o-N.horizontalGutter:o+g>k&&(m=o-P+g+N.horizontalGutter),isNaN(m)||w(m,d)}function y(){return-O.position().left}function z(){return-O.position().top}function A(){var a=T-Q;return a>20&&a-z()<10}function B(){var a=S-P;return a>20&&a-y()<10}function C(){R.unbind(zb).bind(zb,function(a,b,c,d){bb||(bb=0),$||($=0);var e=bb,f=$,g=a.deltaFactor||N.mouseWheelSpeed;return tb.scrollBy(c*g,-d*g,!1),e==bb&&f==$})}function D(){R.unbind(zb)}function E(){return!1}function F(){O.find(":input,a").unbind("focus.jsp").bind("focus.jsp",function(a){x(a.target,!1)})}function G(){O.find(":input,a").unbind("focus.jsp")}function H(){function c(){var a=bb,b=$;switch(d){case 40:tb.scrollByY(N.keyboardSpeed,!1);break;case 38:tb.scrollByY(-N.keyboardSpeed,!1);break;case 34:case 32:tb.scrollByY(Q*N.scrollPagePercent,!1);break;case 33:tb.scrollByY(-Q*N.scrollPagePercent,!1);break;case 39:tb.scrollByX(N.keyboardSpeed,!1);break;case 37:tb.scrollByX(-N.keyboardSpeed,!1)}return e=a!=bb||b!=$}var d,e,f=[];X&&f.push(jb[0]),W&&f.push(cb[0]),O.bind("focus.jsp",function(){b.focus()}),b.attr("tabindex",0).unbind("keydown.jsp keypress.jsp").bind("keydown.jsp",function(b){if(b.target===this||f.length&&a(b.target).closest(f).length){var g=bb,h=$;switch(b.keyCode){case 40:case 38:case 34:case 32:case 33:case 39:case 37:d=b.keyCode,c();break;case 35:v(T-Q),d=null;break;case 36:v(0),d=null}return e=b.keyCode==d&&g!=bb||h!=$,!e}}).bind("keypress.jsp",function(b){return b.keyCode==d&&c(),b.target===this||f.length&&a(b.target).closest(f).length?!e:void 0}),N.hideFocus?(b.css("outline","none"),"hideFocus"in R[0]&&b.attr("hideFocus",!0)):(b.css("outline",""),"hideFocus"in R[0]&&b.attr("hideFocus",!1))}function I(){b.attr("tabindex","-1").removeAttr("tabindex").unbind("keydown.jsp keypress.jsp"),O.unbind(".jsp")}function J(){if(location.hash&&location.hash.length>1){var b,c,d=escape(location.hash.substr(1));try{b=a("#"+d+', a[name="'+d+'"]')}catch(e){return}b.length&&O.find(d)&&(0===R.scrollTop()?c=setInterval(function(){R.scrollTop()>0&&(x(b,!0),a(document).scrollTop(R.position().top),clearInterval(c))},50):(x(b,!0),a(document).scrollTop(R.position().top)))}}function K(){a(document.body).data("jspHijack")||(a(document.body).data("jspHijack",!0),a(document.body).delegate('a[href*="#"]',"click",function(b){var c,d,e,f,g,h,i=this.href.substr(0,this.href.indexOf("#")),j=location.href;if(-1!==location.href.indexOf("#")&&(j=location.href.substr(0,location.href.indexOf("#"))),i===j){c=escape(this.href.substr(this.href.indexOf("#")+1));try{d=a("#"+c+', a[name="'+c+'"]')}catch(k){return}d.length&&(e=d.closest(".jspScrollable"),f=e.data("jsp"),f.scrollToElement(d,!0),e[0].scrollIntoView&&(g=a(window).scrollTop(),h=d.offset().top,(g>h||h>g+a(window).height())&&e[0].scrollIntoView()),b.preventDefault())}}))}function L(){var a,b,c,d,e,f=!1;R.unbind("touchstart.jsp touchmove.jsp touchend.jsp click.jsp-touchclick").bind("touchstart.jsp",function(g){var h=g.originalEvent.touches[0];a=y(),b=z(),c=h.pageX,d=h.pageY,e=!1,f=!0}).bind("touchmove.jsp",function(g){if(f){var h=g.originalEvent.touches[0],i=bb,j=$;return tb.scrollTo(a+c-h.pageX,b+d-h.pageY),e=e||Math.abs(c-h.pageX)>5||Math.abs(d-h.pageY)>5,i==bb&&j==$}}).bind("touchend.jsp",function(){f=!1}).bind("click.jsp-touchclick",function(){return e?(e=!1,!1):void 0})}function M(){var a=z(),c=y();b.removeClass("jspScrollable").unbind(".jsp"),O.unbind(".jsp"),b.replaceWith(yb.append(O.children())),yb.scrollTop(a),yb.scrollLeft(c),pb&&clearInterval(pb)}var N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,_,ab,bb,cb,db,eb,fb,gb,hb,ib,jb,kb,lb,mb,nb,ob,pb,qb,rb,sb,tb=this,ub=!0,vb=!0,wb=!1,xb=!1,yb=b.clone(!1,!1).empty(),zb=a.fn.mwheelIntent?"mwheelIntent.jsp":"mousewheel.jsp";"border-box"===b.css("box-sizing")?(qb=0,rb=0):(qb=b.css("paddingTop")+" "+b.css("paddingRight")+" "+b.css("paddingBottom")+" "+b.css("paddingLeft"),rb=(parseInt(b.css("paddingLeft"),10)||0)+(parseInt(b.css("paddingRight"),10)||0)),a.extend(tb,{reinitialise:function(b){b=a.extend({},N,b),d(b)},scrollToElement:function(a,b,c){x(a,b,c)},scrollTo:function(a,b,c){w(a,c),v(b,c)},scrollToX:function(a,b){w(a,b)},scrollToY:function(a,b){v(a,b)},scrollToPercentX:function(a,b){w(a*(S-P),b)},scrollToPercentY:function(a,b){v(a*(T-Q),b)},scrollBy:function(a,b,c){tb.scrollByX(a,c),tb.scrollByY(b,c)},scrollByX:function(a,b){var c=y()+Math[0>a?"floor":"ceil"](a),d=c/(S-P);r(d*ab,b)},scrollByY:function(a,b){var c=z()+Math[0>a?"floor":"ceil"](a),d=c/(T-Q);p(d*Z,b)},positionDragX:function(a,b){r(a,b)},positionDragY:function(a,b){p(a,b)},animate:function(a,b,c,d,e){var f={};f[b]=c,a.animate(f,{duration:N.animateDuration,easing:N.animateEase,queue:!1,step:d,complete:e})},getContentPositionX:function(){return y()},getContentPositionY:function(){return z()},getContentWidth:function(){return S},getContentHeight:function(){return T},getPercentScrolledX:function(){return y()/(S-P)},getPercentScrolledY:function(){return z()/(T-Q)},getIsScrollableH:function(){return X},getIsScrollableV:function(){return W},getContentPane:function(){return O},scrollToBottom:function(a){p(Z,a)},hijackInternalLinks:a.noop,destroy:function(){M()}}),d(c)}return b=a.extend({},a.fn.jScrollPane.defaults,b),a.each(["arrowButtonSpeed","trackClickSpeed","keyboardSpeed"],function(){b[this]=b[this]||b.speed}),this.each(function(){var d=a(this),e=d.data("jsp");e?e.reinitialise(b):(a("script",d).filter('[type="text/javascript"],:not([type])').remove(),e=new c(d,b),d.data("jsp",e))})},a.fn.jScrollPane.defaults={showArrows:!1,maintainPosition:!0,stickToBottom:!1,stickToRight:!1,clickOnTrack:!0,autoReinitialise:!1,autoReinitialiseDelay:500,verticalDragMinHeight:0,verticalDragMaxHeight:99999,horizontalDragMinWidth:0,horizontalDragMaxWidth:99999,contentWidth:void 0,animateScroll:!1,animateDuration:300,animateEase:"linear",hijackInternalLinks:!1,verticalGutter:4,horizontalGutter:4,mouseWheelSpeed:3,arrowButtonSpeed:0,arrowRepeatFreq:50,arrowScrollOnHover:!1,trackClickSpeed:0,trackClickRepeatFreq:70,verticalArrowPositions:"split",horizontalArrowPositions:"split",enableKeyboardNavigation:!0,hideFocus:!1,keyboardSpeed:0,initialDelay:300,speed:30,scrollPagePercent:.8}});
/*!
 * jQuery Mousewheel 3.1.12
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

/*! jQuery slidePanel - v0.2.0 - 2015-06-05
 * https://github.com/amazingSurge/jquery-slidePanel
 * Copyright (c) 2015 amazingSurge; Licensed GPL */
(function($, document, window, undefined) {
    "use strict";

    var SlidePanel = $.slidePanel = function() {
        SlidePanel.show.apply(this, arguments);
    };

    if (!Date.now) {
        Date.now = function() {
            return new Date().getTime();
        };
    }

    function getTime() {
        if (typeof window.performance !== 'undefined' && window.performance.now) {
            return window.performance.now();
        } else {
            return Date.now();
        }
    }

    var vendors = ['webkit', 'moz'];
    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
        var vp = vendors[i];
        window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = (window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame']);
    }
    if (/iP(ad|hone|od).*OS (6|7|8)/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
        var lastTime = 0;
        window.requestAnimationFrame = function(callback) {
            var now = getTime();
            var nextTime = Math.max(lastTime + 16, now);
            return setTimeout(function() {
                    callback(lastTime = nextTime);
                },
                nextTime - now);
        };
        window.cancelAnimationFrame = clearTimeout;
    }

    var Support = (function() {
        var style = $('<support>').get(0).style,
            prefixes = ['webkit', 'Moz', 'O', 'ms'],
            events = {
                transition: {
                    end: {
                        WebkitTransition: 'webkitTransitionEnd',
                        MozTransition: 'transitionend',
                        OTransition: 'oTransitionEnd',
                        transition: 'transitionend'
                    }
                },
                animation: {
                    end: {
                        WebkitAnimation: 'webkitAnimationEnd',
                        MozAnimation: 'animationend',
                        OAnimation: 'oAnimationEnd',
                        animation: 'animationend'
                    }
                }
            },
            tests = {
                csstransforms: function() {
                    return !!test('transform');
                },
                csstransforms3d: function() {
                    return !!test('perspective');
                },
                csstransitions: function() {
                    return !!test('transition');
                },
                cssanimations: function() {
                    return !!test('animation');
                }
            };

        function test(property, prefixed) {
            var result = false,
                upper = property.charAt(0).toUpperCase() + property.slice(1);

            if (style[property] !== undefined) {
                result = property;
            }
            if (!result) {
                $.each(prefixes, function(i, prefix) {
                    if (style[prefix + upper] !== undefined) {
                        result = '-' + prefix.toLowerCase() + '-' + upper;
                        return false;
                    }
                });
            }

            if (prefixed) {
                return result;
            }
            if (result) {
                return true;
            } else {
                return false;
            }
        }

        function prefixed(property) {
            return test(property, true);
        }
        var support = {};
        if (tests.csstransitions()) {
            /* jshint -W053 */
            support.transition = new String(prefixed('transition'))
            support.transition.end = events.transition.end[support.transition];
        }

        if (tests.cssanimations()) {
            /* jshint -W053 */
            support.animation = new String(prefixed('animation'))
            support.animation.end = events.animation.end[support.animation];
        }

        if (tests.csstransforms()) {
            /* jshint -W053 */
            support.transform = new String(prefixed('transform'));
            support.transform3d = tests.csstransforms3d();
        }

        if (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch) {
            support.touch = true;
        } else {
            support.touch = false;
        }

        if (window.PointerEvent || window.MSPointerEvent) {
            support.pointer = true;
        } else {
            support.pointer = false;
        }

        support.prefixPointerEvent = function(pointerEvent) {
            return window.MSPointerEvent ?
                'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) :
                pointerEvent;
        }

        return support;
    })();

    function isPercentage(n) {
        return typeof n === 'string' && n.indexOf('%') != -1;
    }

    function isPx(n) {
        return typeof n === 'string' && n.indexOf('px') != -1;
    }

    function convertMatrixToArray(value) {
        if (value && (value.substr(0, 6) == "matrix")) {
            return value.replace(/^.*\((.*)\)$/g, "$1").replace(/px/g, '').split(/, +/);
        }
        return false;
    }

    function getHashCode(object) {
        if (typeof object !== 'string') {
            object = JSON.stringify(object);
        }

        var hash = 0,
            i, chr, len;
        if (object.length === 0) return hash;
        for (i = 0, len = object.length; i < len; i++) {
            chr = object.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }

        return hash;
    }

    function easingBezier(mX1, mY1, mX2, mY2) {
        function a(aA1, aA2) {
            return 1.0 - 3.0 * aA2 + 3.0 * aA1;
        }

        function b(aA1, aA2) {
            return 3.0 * aA2 - 6.0 * aA1;
        }

        function c(aA1) {
            return 3.0 * aA1;
        }

        // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
        function calcBezier(aT, aA1, aA2) {
            return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;
        }

        // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
        function getSlope(aT, aA1, aA2) {
            return 3.0 * a(aA1, aA2) * aT * aT + 2.0 * b(aA1, aA2) * aT + c(aA1);
        }

        function getTForX(aX) {
            // Newton raphson iteration
            var aGuessT = aX;
            for (var i = 0; i < 4; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }

        if (mX1 === mY1 && mX2 === mY2) {
            return {
                css: 'linear',
                fn: function(aX) {
                    return aX;
                }
            };
        } else {
            return {
                css: 'cubic-bezier(' + mX1 + ',' + mY1 + ',' + mX2 + ',' + mY2 + ')',
                fn: function(aX) {
                    return calcBezier(getTForX(aX), mY1, mY2);
                }
            }
        }
    }

    var Easings = {
        'ease': easingBezier(0.25, 0.1, 0.25, 1.0),
        'linear': easingBezier(0.00, 0.0, 1.00, 1.0),
        'ease-in': easingBezier(0.42, 0.0, 1.00, 1.0),
        'ease-out': easingBezier(0.00, 0.0, 0.58, 1.0),
        'ease-in-out': easingBezier(0.42, 0.0, 0.58, 1.0)
    };

    SlidePanel.options = {
        skin: null,

        classes: {
            base: 'slidePanel',
            show: 'slidePanel-show',
            loading: 'slidePanel-loading',
            content: 'slidePanel-content',
            dragging: 'slidePanel-dragging',
            willClose: 'slidePanel-will-close'
        },

        closeSelector: null,

        template: function(options) {
            return '<div class="' + options.classes.base + ' ' + options.classes.base + '-' + options.direction + '">' +
                '<div class="' + options.classes.content + '"></div>' +
                '</div>';
        },

        loading: {
            appendTo: 'panel', // body, panel
            template: function(options) {
                return '<div class="' + options.classes.loading + '"></div>';
            },
            showCallback: function(options) {
                this.$el.addClass(options.classes.loading + '-show');
            },
            hideCallback: function(options) {
                this.$el.removeClass(options.classes.loading + '-show');
            }
        },

        contentFilter: function(content) {
            return content;
        },

        useCssTransforms3d: true,
        useCssTransforms: true,
        useCssTransitions: true,

        dragTolerance: 90,

        mouseDragHandler: null,
        mouseDrag: true,
        touchDrag: true,
        pointerDrag: true,

        direction: 'right', // top, bottom, left, right
        duration: '500',
        easing: 'ease', // linear, ease-in, ease-out, ease-in-out

        // callbacks
        beforeLoad: $.noop, // Before loading
        afterLoad: $.noop, // After loading
        beforeShow: $.noop, // Before opening
        afterShow: $.noop, // After opening
        onChange: $.noop, // On changing
        beforeChange: $.noop, // Before changing
        beforeHide: $.noop, // Before closing
        afterHide: $.noop, // After closing
        beforeDrag: $.noop, // Before drag
        afterDrag: $.noop // After drag
    };

    // View
    function View() {
        return this.initialize.apply(this, Array.prototype.slice.call(arguments));
    }

    $.extend(View.prototype, {
        initialize: function(options) {
            this.options = options;
            this._instance = null;
            this._showed = false;
            this._isLoading = false;

            this.build();
        },

        setLength: function() {
            switch (this.options.direction) {
                case 'top':
                case 'bottom':
                    this._length = this.$panel.outerHeight();
                    break;
                case 'left':
                case 'right':
                    this._length = this.$panel.outerWidth();
                    break;
            }
        },

        build: function() {
            if (this._builded) return;

            var options = this.options;

            var html = options.template.call(this, options);
            var self = this;

            this.$panel = $(html).appendTo('body');
            if (options.skin) {
                this.$panel.addClass(options.skin);
            }
            this.$content = this.$panel.find('.' + this.options.classes.content);

            if (options.closeSelector) {
                this.$panel.on('click', options.closeSelector, function() {
                    self.hide();
                    return false;
                });
            }
            this.loading = new Loading(this);

            this.setLength();
            this.setPosition(this.getHidePosition());

            if (options.mouseDrag || options.touchDrag || options.pointerDrag) {
                this.drag = new Drag(this);
            }

            this._builded = true;
        },

        getHidePosition: function() {
            var options = this.options;

            if (options.useCssTransforms || options.useCssTransforms3d) {
                switch (options.direction) {
                    case 'top':
                    case 'left':
                        return '-100';
                    case 'bottom':
                    case 'right':
                        return '100';
                }
            } else {
                switch (options.direction) {
                    case 'top':
                    case 'bottom':
                        return parseFloat(-(this._length / $(window).height()) * 100, 10);
                    case 'left':
                    case 'right':
                        return parseFloat(-(this._length / $(window).width()) * 100, 10);
                }
            }
        },

        empty: function() {
            this._instance = null;
            this.$content.empty();
        },

        load: function(object) {
            var self = this;
            var options = object.options;
            var previous = this._instance;

            _SlidePanel.trigger(this, 'beforeLoad', object);
            this.empty();

            function setContent(content) {
                content = options.contentFilter.call(this, content);
                self.$content.html(content);
                self.hideLoading();

                self._instance = object;

                _SlidePanel.trigger(self, 'afterLoad', object);
            }

            if (object.content) {
                setContent(object.content);
            } else if (object.url) {
                this.showLoading();

                $.ajax(object.url, object.settings || {}).done(function(data) {
                    setContent(data);
                });
            } else {
                setContent('');
            }
        },

        showLoading: function() {
            var self = this;
            this.loading.show(function() {
                self._isLoading = true;
            });
        },

        hideLoading: function() {
            var self = this;
            this.loading.hide(function() {
                self._isLoading = false;
            });
        },

        show: function(callback) {
            this.build();

            _SlidePanel.enter('show');
            _SlidePanel.trigger(this, 'beforeShow');

            $('html').addClass(this.options.classes.base + '-html');
            this.$panel.addClass(this.options.classes.show);

            var self = this;
            Animate.do(this, 0, function() {
                self._showed = true;
                _SlidePanel.trigger(self, 'afterShow');

                if ($.isFunction(callback)) {
                    callback.call(self);
                }
            });
        },

        change: function(object) {
            _SlidePanel.trigger(this, 'beforeShow');

            _SlidePanel.trigger(this, 'onChange', object, this._instance);

            this.load(object);

            _SlidePanel.trigger(this, 'afterShow');
        },

        revert: function(callback) {
            var self = this;
            Animate.do(this, 0, function() {
                if ($.isFunction(callback)) {
                    callback.call(self);
                }
            });
        },

        hide: function(callback) {
            _SlidePanel.leave('show');
            _SlidePanel.trigger(this, 'beforeHide');

            var self = this;

            Animate.do(this, this.getHidePosition(), function() {
                self.$panel.removeClass(self.options.classes.show);
                self._showed = false;
                self._instance = null;

                if (_SlidePanel._current === self) {
                    _SlidePanel._current = null;
                }

                if (!_SlidePanel.is('show')) {
                    $('html').removeClass(self.options.classes.base + '-html');
                }

                if ($.isFunction(callback)) {
                    callback.call(self);
                }

                _SlidePanel.trigger(self, 'afterHide');
            });
        },

        makePositionStyle: function(value) {
            var property, x = '0',
                y = '0';

            if (!isPercentage(value) && !isPx(value)) {
                value = value + '%';
            }

            if (this.options.useCssTransforms && Support.transform) {
                if (this.options.direction === 'left' || this.options.direction === 'right') {
                    x = value;
                } else {
                    y = value;
                }

                property = Support.transform.toString();

                if (this.options.useCssTransforms3d && Support.transform3d) {
                    value = "translate3d(" + x + "," + y + ",0)";
                } else {
                    value = "translate(" + x + "," + y + ")";
                }
            } else {
                property = this.options.direction;
            }
            var temp = {};
            temp[property] = value;
            return temp;
        },

        getPosition: function(px) {
            var value;

            if (this.options.useCssTransforms && Support.transform) {
                value = convertMatrixToArray(this.$panel.css(Support.transform));
                if (!value) {
                    return 0;
                }

                if (this.options.direction === 'left' || this.options.direction === 'right') {
                    value = value[12] || value[4];

                } else {
                    value = value[13] || value[5];
                }
            } else {
                value = this.$panel.css(this.options.direction);

                value = parseFloat(value.replace('px', ''));
            }

            if (px !== true) {
                value = (value / this._length) * 100;
            }

            return parseFloat(value, 10);
        },

        setPosition: function(value) {
            var style = this.makePositionStyle(value);
            this.$panel.css(style);
        }
    });

    // Loading
    function Loading() {
        return this.initialize.apply(this, Array.prototype.slice.call(arguments));
    };

    $.extend(Loading.prototype, {
        initialize: function(view) {
            this._view = view;
            this.build();
        },

        build: function() {
            if (this._builded) return;

            var options = this._view.options;
            var html = options.loading.template.call(this, options);
            this.$el = $(html);

            switch (options.loading.appendTo) {
                case 'panel':
                    this.$el.appendTo(this._view.$panel);
                    break;
                case 'body':
                    this.$el.appendTo('body');
                    break;
                default:
                    this.$el.appendTo(options.loading.appendTo);
            }

            this._builded = true;
        },

        show: function(callback) {
            this.build();
            var options = this._view.options;
            options.loading.showCallback.call(this, options);

            if ($.isFunction(callback)) {
                callback.call(this);
            }
        },

        hide: function(callback) {
            var options = this._view.options;
            options.loading.hideCallback.call(this, options);

            if ($.isFunction(callback)) {
                callback.call(this);
            }
        }
    });

    var Animate = {
        prepareTransition: function($el, property, duration, easing, delay) {
            var temp = [];
            if (property) {
                temp.push(property);
            }
            if (duration) {
                if ($.isNumeric(duration)) {
                    duration = duration + 'ms';
                }
                temp.push(duration);
            }
            if (easing) {
                temp.push(easing);
            } else {
                temp.push(this.easing.css);
            }
            if (delay) {
                temp.push(delay);
            }
            $el.css(Support.transition, temp.join(' '));
        },
        do: function(view, value, callback) {
            _SlidePanel.enter('animating');

            var duration = view.options.duration,
                easing = view.options.easing || 'ease';

            var self = this,
                style = view.makePositionStyle(value);
            for (var property in style) {
                break;
            }

            if (view.options.useCssTransitions && Support.transition) {
                setTimeout(function() {
                    self.prepareTransition(view.$panel, property, duration, easing);
                }, 20);

                view.$panel.one(Support.transition.end, function() {
                    if ($.isFunction(callback)) {
                        callback();
                    }

                    view.$panel.css(Support.transition, '');

                    _SlidePanel.leave('animating');
                });
                setTimeout(function() {
                    view.setPosition(value);
                }, 20);
            } else {
                var startTime = getTime();
                var start = view.getPosition();
                var end = value;

                var run = function(time) {
                    var percent = (time - startTime) / view.options.duration;

                    if (percent > 1) {
                        percent = 1;
                    }

                    percent = Easings[easing].fn(percent);

                    var current = parseFloat(start + percent * (end - start), 10);

                    view.setPosition(current);

                    if (percent === 1) {
                        window.cancelAnimationFrame(self._frameId);
                        self._frameId = null;

                        if ($.isFunction(callback)) {
                            callback();
                        }

                        _SlidePanel.leave('animating');
                    } else {
                        self._frameId = window.requestAnimationFrame(run);
                    }
                };

                self._frameId = window.requestAnimationFrame(run);
            }
        }
    }

    // Drag
    function Drag() {
        return this.initialize.apply(this, Array.prototype.slice.call(arguments));
    }

    $.extend(Drag.prototype, {
        initialize: function(view) {
            this._view = view;
            this.options = view.options;
            this._drag = {
                time: null,
                pointer: null
            };

            this.bindEvents();
        },
        bindEvents: function() {
            var self = this;
            var options = this.options,
                $panel = this._view.$panel;

            if (options.mouseDrag) {
                $panel.on(_SlidePanel.eventName('mousedown'), $.proxy(this.onDragStart, this));
                $panel.on(_SlidePanel.eventName('dragstart selectstart'), function() {
                    return false
                });
            }

            if (options.touchDrag && Support.touch) {
                $panel.on(_SlidePanel.eventName('touchstart'), $.proxy(this.onDragStart, this));
                $panel.on(_SlidePanel.eventName('touchcancel'), $.proxy(this.onDragEnd, this));
            }

            if (options.pointerDrag && Support.pointer) {
                $panel.on(_SlidePanel.eventName(Support.prefixPointerEvent('pointerdown')), $.proxy(this.onDragStart, this));
                $panel.on(_SlidePanel.eventName(Support.prefixPointerEvent('pointercancel')), $.proxy(this.onDragEnd, this));
            }
        },

        /**
         * Handles `touchstart` and `mousedown` events.
         */
        onDragStart: function(event) {
            var self = this;

            if (event.which === 3) {
                return;
            }

            var options = this.options;

            this._view.$panel.addClass(this.options.classes.dragging);

            this._position = this._view.getPosition(true);

            this._drag.time = new Date().getTime();
            this._drag.pointer = this.pointer(event);

            var callback = function() {
                _SlidePanel.enter('dragging');
                _SlidePanel.trigger(self._view, 'beforeDrag');
            }

            if (options.mouseDrag) {
                if (options.mouseDragHandler) {
                    if (!$(event.target).is(options.mouseDragHandler) && !($(event.target).parents(options.mouseDragHandler).length > 0)) {
                        return;
                    }
                }

                $(document).on(_SlidePanel.eventName('mouseup'), $.proxy(this.onDragEnd, this));

                $(document).one(_SlidePanel.eventName('mousemove'), $.proxy(function() {
                    $(document).on(_SlidePanel.eventName('mousemove'), $.proxy(this.onDragMove, this));

                    callback();
                }, this));
            }

            if (options.touchDrag && Support.touch) {
                $(document).on(_SlidePanel.eventName('touchend'), $.proxy(this.onDragEnd, this));

                $(document).one(_SlidePanel.eventName('touchmove'), $.proxy(function() {
                    $(document).on(_SlidePanel.eventName('touchmove'), $.proxy(this.onDragMove, this));

                    callback();
                }, this));
            }

            if (options.pointerDrag && Support.pointer) {
                $(document).on(_SlidePanel.eventName(Support.prefixPointerEvent('pointerup')), $.proxy(this.onDragEnd, this));

                $(document).one(_SlidePanel.eventName(Support.prefixPointerEvent('pointermove')), $.proxy(function() {
                    $(document).on(_SlidePanel.eventName(Support.prefixPointerEvent('pointermove')), $.proxy(this.onDragMove, this));

                    callback();
                }, this));
            }

            $(document).on(_SlidePanel.eventName('blur'), $.proxy(this.onDragEnd, this));

            event.preventDefault();
        },

        /**
         * Handles the `touchmove` and `mousemove` events.
         */
        onDragMove: function(event) {
            var distance = this.distance(this._drag.pointer, this.pointer(event));

            if (!_SlidePanel.is('dragging')) {
                return;
            }

            if (Math.abs(distance) > this.options.dragTolerance) {
                if (this._willClose !== true) {
                    this._willClose = true;
                    this._view.$panel.addClass(this.options.classes.willClose);
                }
            } else {
                if (this._willClose !== false) {
                    this._willClose = false;
                    this._view.$panel.removeClass(this.options.classes.willClose);
                }
            }

            if (!_SlidePanel.is('dragging')) {
                return;
            }

            event.preventDefault();
            this.move(distance);
        },

        /**
         * Handles the `touchend` and `mouseup` events.
         */
        onDragEnd: function(event) {
            var distance = this.distance(this._drag.pointer, this.pointer(event));

            $(document).off(_SlidePanel.eventName('mousemove mouseup touchmove touchend pointermove pointerup MSPointerMove MSPointerUp blur'));

            this._view.$panel.removeClass(this.options.classes.dragging);

            if (this._willClose === true) {
                this._willClose = false;
                this._view.$panel.removeClass(this.options.classes.willClose);
            }

            if (!_SlidePanel.is('dragging')) {
                return;
            }

            _SlidePanel.leave('dragging');

            _SlidePanel.trigger(this._view, 'afterDrag');

            if (Math.abs(distance) < this.options.dragTolerance) {
                this._view.revert();
            } else {
                _SlidePanel.hide();
            }
        },

        /**
         * Gets unified pointer coordinates from event.
         * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
         */
        pointer: function(event) {
            var result = {
                x: null,
                y: null
            };

            event = event.originalEvent || event || window.event;

            event = event.touches && event.touches.length ?
                event.touches[0] : event.changedTouches && event.changedTouches.length ?
                event.changedTouches[0] : event;

            if (event.pageX) {
                result.x = event.pageX;
                result.y = event.pageY;
            } else {
                result.x = event.clientX;
                result.y = event.clientY;
            }

            return result;
        },

        /**distance
         * Gets the distance of two pointer.
         */
        distance: function(first, second) {
            var d = this.options.direction;
            if (d === 'left' || d === 'right') {
                return second.x - first.x;
            } else {
                return second.y - first.y;
            }
        },

        move: function(value) {
            var position = this._position + value;

            if (this.options.direction === 'right' || this.options.direction === 'bottom') {
                if (position < 0) {
                    return;
                }
            } else {
                if (position > 0) {
                    return;
                }
            }

            if (!this.options.useCssTransforms && !this.options.useCssTransforms3d) {
                if (this.options.direction === 'right' || this.options.direction === 'bottom') {
                    position = -position;
                }
            }

            this._view.setPosition(position + 'px');
        }
    });

    // Instance
    function Instance() {
        return this.initialize.apply(this, Array.prototype.slice.call(arguments));
    };

    $.extend(Instance.prototype, {
        initialize: function(object) {
            var options = arguments[1] || {};

            if (typeof object === 'string') {
                object = {
                    url: object
                };
            } else if (object && object.nodeType == 1) {
                var $element = $(object);

                object = {
                    url: $element.attr('href'),
                    settings: $element.data('settings') || {},
                    options: $element.data() || {}
                }
            }

            if (object && object.options) {
                object.options = $.extend(true, options, object.options);
            } else {
                object.options = options;
            }

            object.options = $.extend(true, {}, SlidePanel.options, object.options);

            $.extend(this, object);

            return this;
        }
    });

    var _SlidePanel = {
        // Current state information.
        _states: {},
        _views: {},
        _current: null,

        /**
         * Checks whether the carousel is in a specific state or not.
         */
        is: function(state) {
            return this._states[state] && this._states[state] > 0;
        },

        /**
         * Enters a state.
         */
        enter: function(state) {
            if (this._states[state] === undefined) {
                this._states[state] = 0;
            }

            this._states[state]++;
        },

        /**
         * Leaves a state.
         */
        leave: function(state) {
            this._states[state]--;
        },

        trigger: function(view, event) {
            var method_arguments = Array.prototype.slice.call(arguments, 2),
                data = [view].concat(method_arguments);

            // event
            $(document).trigger('slidePanel::' + event, data);
            if ($.isFunction(view.options[event])) {
                view.options[event].apply(view, method_arguments);
            }
        },

        eventName: function(events) {
            if (typeof events !== 'string' || events === '') {
                return '.slidepanel';
            }
            events = events.split(' ');

            var length = events.length;
            for (var i = 0; i < length; i++) {
                events[i] = events[i] + '.slidepanel';
            }
            return events.join(' ');
        },

        show: function(object) {
            if (!(object instanceof Instance)) {
                switch (arguments.length) {
                    case 0:
                        object = new Instance();
                        break;
                    case 1:
                        object = new Instance(arguments[0]);
                        break;
                    case 2:
                        object = new Instance(arguments[0], arguments[1]);
                        break;
                }
            }

            var view = this.getView(object.options);
            var self = this;
            var callback = function() {
                view.show();
                view.load(object);
                self._current = view;
            }
            if (null !== this._current) {
                if (view === this._current) {
                    this._current.change(object);
                } else {
                    this._current.hide(callback);
                }
            } else {
                callback();
            }
        },

        getView: function(options) {
            var code = getHashCode(options);

            if (this._views.hasOwnProperty(code)) {
                return this._views[code];
            }

            return this._views[code] = new View(options);
        },

        hide: function(object) {
            if (object) {
                var view = this.getView(object.options);
                view.hide();
            } else {
                if (this._current !== null) {
                    var self = this;
                    this._current.hide();
                }
            }
        }
    };

    $.extend(SlidePanel, {
        is: function(state) {
            return _SlidePanel.is(state);
        },

        show: function(object, options) {
            _SlidePanel.show.apply(_SlidePanel, arguments);
            return this;
        },

        hide: function() {
            _SlidePanel.hide.apply(_SlidePanel, arguments);
            return this;
        }
    });

    $.fn.slidePanel = function(options) {
        if (typeof options === 'string') {
            var method = options;
            var method_arguments = Array.prototype.slice.call(arguments, 1);

            return this.each(function() {
                var instance = $.data(this, 'slidePanel');

                if (!(instance instanceof Instance)) {
                    instance = new Instance(this, method_arguments);
                    $.data(this, 'slidePanel', instance);
                }

                switch (method) {
                    case 'hide':
                        _SlidePanel.hide(instance);
                        break;
                    case 'show':
                        _SlidePanel.show(instance);
                        break;
                }
            });
        } else {
            return this.each(function() {
                if (!$.data(this, 'slidePanel')) {
                    $.data(this, 'slidePanel', new Instance(this, options));

                    $(this).on('click', function(e) {
                        var instance = $.data(this, 'slidePanel');
                        _SlidePanel.show(instance);

                        e.preventDefault();
                        e.stopPropagation();
                    });
                }
            });
        }
    };

})(jQuery, document, window);

(function($){

    $.session = {

        _id: null,

        _cookieCache: undefined,

        _init: function()
        {
            if (!window.name) {
                window.name = Math.random();
            }
            this._id = window.name;
            this._initCache();

            // See if we've changed protcols

            var matches = (new RegExp(this._generatePrefix() + "=([^;]+);")).exec(document.cookie);
            if (matches && document.location.protocol !== matches[1]) {
               this._clearSession();
               for (var key in this._cookieCache) {
                   try {
                   window.sessionStorage.setItem(key, this._cookieCache[key]);
                   } catch (e) {};
               }
            }

            document.cookie = this._generatePrefix() + "=" + document.location.protocol + ';path=/;expires=' + (new Date((new Date).getTime() + 120000)).toUTCString();

        },

        _generatePrefix: function()
        {
            return '__session:' + this._id + ':';
        },

        _initCache: function()
        {
            var cookies = document.cookie.split(';');
            this._cookieCache = {};
            for (var i in cookies) {
                var kv = cookies[i].split('=');
                if ((new RegExp(this._generatePrefix() + '.+')).test(kv[0]) && kv[1]) {
                    this._cookieCache[kv[0].split(':', 3)[2]] = kv[1];
                }
            }
        },

        _setFallback: function(key, value, onceOnly)
        {
            var cookie = this._generatePrefix() + key + "=" + value + "; path=/";
            if (onceOnly) {
                cookie += "; expires=" + (new Date(Date.now() + 120000)).toUTCString();
            }
            document.cookie = cookie;
            this._cookieCache[key] = value;
            return this;
        },

        _getFallback: function(key)
        {
            if (!this._cookieCache) {
                this._initCache();
            }
            return this._cookieCache[key];
        },

        _clearFallback: function()
        {
            for (var i in this._cookieCache) {
                document.cookie = this._generatePrefix() + i + '=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
            }
            this._cookieCache = {};
        },

        _deleteFallback: function(key)
        {
            document.cookie = this._generatePrefix() + key + '=; path=/; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
            delete this._cookieCache[key];
        },

        get: function(key)
        {
            return window.sessionStorage.getItem(key) || this._getFallback(key);
        },

        set: function(key, value, onceOnly)
        {
            try {
                window.sessionStorage.setItem(key, value);
            } catch (e) {}
            this._setFallback(key, value, onceOnly || false);
            return this;
        },
        
        'delete': function(key){
            return this.remove(key);
        },

        remove: function(key)
        {
            try {
            window.sessionStorage.removeItem(key);
            } catch (e) {};
            this._deleteFallback(key);
            return this;
        },

        _clearSession: function()
        {
          try {
                window.sessionStorage.clear();
            } catch (e) {
                for (var i in window.sessionStorage) {
                    window.sessionStorage.removeItem(i);
                }
            }
        },

        clear: function()
        {
            this._clearSession();
            this._clearFallback();
            return this;
        }

    };

    $.session._init();

})(jQuery);

/* START - SEARCH - USING ARROW KEYS */
    $(window).on('load',function(){
    /* START ARIA MARKUPS - MOBILE */
    /* mobile list items */
    function mobileMenuClicked(spanEle) {
        setTimeout(function(){
            var ulEle = spanEle.next('ul');
            var ulEleParent = ulEle.parent();
            
            var label = spanEle.clone().children().remove().end().text();
            
            ulEle.attr('role','menubar').attr('aria-label',label.trim());
            
            $('ul > li > a',ulEleParent).attr('role','menuitem');
            $('a.visit-link',ulEle).attr('aria-hidden','true');
            $('span.mobile-nav-list-item',ulEle).each(function(){
                $(this).attr('role','menuitem').attr('aria-haspopup','true');
                if ($(this).hasClass('expand')) {
                    $(this).attr('aria-expanded','true');
                }
                else {
                    $(this).attr('aria-expanded','false');
                }
                $(this).click(function(){
                    if ($(this).hasClass('expand')) {
                        $(this).attr('aria-expanded','false');
                    }
                    else {
                        $(this).attr('aria-expanded','true');
                        mobileMenuClicked($(this));
                    }
                });
            });
        },500);
    }
    $('.hmb-component-header:not(.visible-md) .top-nav > .global-links').each(function(){
        $(this).click(function(){
            if ($(this).hasClass('expand')) {
                $(this).attr('aria-expanded','true');
            }
            else {
                $(this).attr('aria-expanded','false');
            }
        });
    });
    $('.hmb-component-header:not(.visible-md) .site-menubar').each(function(index){
        $('span.mobile-nav-list-item',this).each(function(){
            $(this).click(function(){
                if ($(this).hasClass('expand')) {
                    $(this).attr('aria-expanded','false');
                }
                else {
                    $(this).attr('aria-expanded','true');
                    mobileMenuClicked($(this));
                }
            });
        });
    });

    $('.search > #spark-search-form > label > .icon-search').keydown(function(e) {
        if (e.keyCode==13) {
            $('> input#icon-search-checkbox',$(this).closest('#spark-search-form')).prop('checked',true);
            setTimeout(function() {
              $('#sparksearchbox').focus();
              $('#sparksearchbox').val('');
              $('.search > #spark-search-form > label > .icon-close').attr('tabindex', 0);
            },500);
        }
    });

    $('.search > #spark-search-form > label > .icon-close').keydown(function(e) {
        if (e.keyCode==13) {
            $('> input#icon-search-checkbox',$(this).closest('#spark-search-form')).prop('checked',false);
        }
    });
    
    /* START - TOP NAV GLOBAL LINKS - USING ARROW KEYS */
    /* tabindex, focus class */
    
    
    $('.hmb-component-header.visible-md .top-nav .global-links .global-links-dropdown').on('focus mouseover',function(e){
        if (!$(this).hasClass('focused')) {
            $(this).addClass('focused');
            $(this).attr('aria-expanded','true');
        }
    }).on('blur mouseleave',function(e){
        $(this).removeClass('focused');
        $(this).attr('aria-expanded','false');
    });
    
    $('.hmb-component-header.visible-md .top-nav .global-links .global-links-dropdown .global-link-list > li > a').on('focus mouseover',function(e){
        var parent = $(this).closest('.global-links-dropdown');
        if (!parent.hasClass('focused')) {
            parent.addClass('focused');
            parent.attr('aria-expanded','true');
        }
    }).on('blur mouseleave',function(e){
        var parent = $(this).closest('.global-links-dropdown');
        parent.removeClass('focused');
        parent.attr('aria-expanded','false');
    });
    
    /* Top Nav - 1st level links */
    $('.hmb-component-header.visible-md .top-nav .global-links:not(.account) > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).prev();
            if (prev.length>0) {
                prev.focus();
            }
            else {
                $('> div > ul > li:last-child > a',$('#hmb-footer > .inner-container > .foot-inner > .footer-bottom:last-child')).focus();
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).next();
            if (next.length>0) {
                next.focus();
            }
            else {
                $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:first-child > a').focus();
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            $('> div > ul > li:last-child > a',$('#hmb-footer > .inner-container > .foot-inner > .footer-bottom:last-child')).focus();
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:first-child > a').focus();
        }
    });
    
    /* Top Nav - global links dropdown */
    $('.hmb-component-header.visible-md .top-nav .global-links .global-links-dropdown').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).prev();
            if (prev.length>0) {
                prev.focus();
            }
            else {
                $('> div > ul > li:last-child > a',$('#hmb-footer > .inner-container > .foot-inner > .footer-bottom:last-child')).focus();
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            $('> div > ul > li:last-child > a',$('#hmb-footer > .inner-container > .foot-inner > .footer-bottom:last-child')).focus();
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).next();
            if (next.length>0) {
                next.focus();
            }
            else {
                $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:first-child > a').focus();
            }
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            var dropdown = $('> .global-link-list',this);
            if (dropdown.length > 0) {
                $('> li:first-child > a',dropdown).focus();
            }
            else {
                $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:first-child > a').focus();
            }
        }
    });
    
    /* Top Nav - global links dropdown links */
    $('.hmb-component-header.visible-md .top-nav .global-links .global-links-dropdown > .global-link-list > li > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            $(this).closest('.global-links-dropdown').focus();
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            $(this).closest('.global-links-dropdown').focus();
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).parent().prev('li');
            if (prev.length>0) {
                $('> a',prev).focus();
            }
            else {
                $('> li:last-child > a',$(this).closest('.global-link-list')).focus();
            }
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).parent().next('li');
            if (next.length>0) {
                $('> a',next).focus();
            }
            else {
                $('> li:first-child > a',$(this).closest('.global-link-list')).focus();
            }
        }
    });

    /* START - Sign in functionality */
    $('.sign-in-wrapper').on('blur mouseleave', 'a.signIN, a.signOUT', function(e) {
        var parent = $(this).closest('.sign-in-wrapper');
        parent.removeClass('focused');
        parent.attr('aria-expanded', 'false');
    }).on('focus mouseover', 'a.signIN, a.signOUT', function(e) {
        var parent = $(this).closest('.sign-in-wrapper');
        if (!parent.hasClass('focused')) {
            parent.addClass('focused');
            parent.attr('aria-expanded', 'true');
        }
    });

    $('.sign-in-wrapper').on('focus mouseover', '.user-options, .user-checkout', function(e) {
        var parent = $(this).closest('.sign-in-wrapper');
        if (!parent.hasClass('focused')) {
            parent.addClass('focused');
            parent.attr('aria-expanded', 'true');
        }
    }).on('blur mouseleave', '.user-options, .user-checkout', function(e) {
        var parent = $(this).closest('.sign-in-wrapper');
        parent.removeClass('focused');
        parent.attr('aria-expanded', 'false');
    });

    $('.sign-in-wrapper > a.signIN, .sign-in-wrapper > a.signOUT').keydown(function(e) {
        if(e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
            e.preventDefault();
            e.stopPropagation();
        }
        if (e.keyCode == 37) {
            // left
            var prev = $(this).prev();
            if (prev.length > 0) {
                prev.focus();
            } else {
                $('> a.signIN, > a.signOUT', $('.global-links.account')).focus();
            }
        }
        else if (e.keyCode == 39) {
            // right
            $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:first-child > a').focus();
        } else if (e.keyCode == 40) {
            // down            
            var dropdown = $('> .user-options, > .user-checkout', this);
            if (dropdown.length > 0) {
                $('> li:first-child > a', dropdown).focus();
            } else {
                $(this).parent().find('.user-options li:first-child a').focus();
            }
        }
    });

    $('.sign-in-wrapper .user-options li a, .sign-in-wrapper .user-checkout li a').keydown(function(e) {
        if(e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
            e.preventDefault();
            e.stopPropagation();
        }
        if (e.keyCode == 37) {
            // left
            $(this).closest('.sign-in-wrapper').focus();
        } else if (e.keyCode == 39) {
            // right
            $(this).closest('.sign-in-wrapper').focus();
        } else if (e.keyCode == 38) {
            // up
            var prev = $(this).parent().prev('li');
            if (prev.length > 0) {
                $('> a', prev).focus();
            } else {
                $('.sign-in-wrapper .user-options li:last-child a, .sign-in-wrapper .user-checkout li:last-child a').focus();
            }
        } else if (e.keyCode == 40) {
            // down
            var next = $(this).parent().next('li');
            if (next.length > 0) {
                $('> a', next).focus();
            } else {
                $('.sign-in-wrapper .user-options li:first-child a, .sign-in-wrapper .user-checkout li:first-child a').focus();
            }
        }
    });
    /* END - Sign in functionality */
    /* END - 1ST LEVEL NAVIGATION - USING ARROW KEYS */
    
    /* START - 2ND LEVEL NAVIGATION - USING ARROW KEYS */
    $('.hmb-component-header.visible-md.visible-lg .site-menubar > .nav-list li a').on('focus mouseover',function(e){
        var parent = $(this).closest('.nav-list > li');
        if (!parent.hasClass('focused')) {
            parent.addClass('focused');
        }
        if ($('> .subnav-list',parent).length>0) {
            $('> a',parent).attr('aria-expanded','true');
        }
    }).on('blur mouseleave',function(e){
        var parent = $(this).closest('.nav-list > li');
        parent.removeClass('focused');
        if ($('> .subnav-list',parent).length>0) {
          $('> a',parent).attr('aria-expanded','false');
        }
    });
    
    /* SiteMenu Navigation - 1st Level */
    $('.hmb-component-header.visible-md .site-menubar > .nav-list > li > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            $(this).parent().removeClass('focused');
            var prev = $(this).parent().prev();
            if (prev.length>0) {
              $('> a',prev).focus();
            }
            else {
                $('.hmb-component-header.visible-md .top-nav .global-links:first-child :last-child').focus();
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            $(this).parent().removeClass('focused');
            var next = $(this).parent().next();
            if (next.length>0) {
              $('> a',next).focus();
            }
            else {
                if ($('.hmb-component-header.visible-md .secondnavigationbar').length>0) {
                    $('.hmb-component-header.visible-md .secondnavigationbar .secondnavigationbar-body a:first').focus();
                }
                else if ($('.quick-links-scroll:visible > .card').length) {
                    $('.quick-links-scroll:visible > .card > a:first-child').focus();
                }
                else {
                    $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div:first-child > h3 > a').focus();
                }
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            $('.hmb-component-header.visible-md .top-nav .global-links:first-child :last-child').focus();
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            var dropdownMegaMenu = $(this).next('.subnav-list');
            if (dropdownMegaMenu.length > 0) {
              if (dropdownMegaMenu.find('.subnav-list-type1').length>0) {
                $('> .container > .row > div:first-child > .subnav-list-type1 > h3 > a',dropdownMegaMenu).focus();
              }
              else if (dropdownMegaMenu.find('.subnav-list-type2').length>0) {
                  $('> .container > .row > div:first-child > .subnav-list-type2 > a:first-child',dropdownMegaMenu).focus();
              }
            }
            else {
                if ($('.hmb-component-header.visible-md .secondnavigationbar').length>0) {
                    $('.hmb-component-header.visible-md .secondnavigationbar .secondnavigationbar-body a:first').focus();
                }
                else if ($('.quick-links-scroll:visible > .card').length) {
                    $('.quick-links-scroll:visible > .card > a:first-child').focus();
                }
                else {
                    $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div:first-child > h3 > a').focus();
                }
            }
        }
    });
    
    /* SiteMenu Navigation - Mega Menu - Type 2 - Image */
    $('.hmb-component-header.visible-md .site-menubar > .nav-list > li > .subnav-list .subnav-list-type2 > a').keydown(function(e) {
        if(e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
            e.preventDefault();
            e.stopPropagation();
        }
        if (e.keyCode == 37) {
            // left
            var prev = $(this).closest('.subnav-list-type2').parent().prev();
            if (prev.length > 0) {
                $('> .subnav-list-type2 > a:first-child', prev).focus();
            } else {
                $('> .container > .row > div:first-child > .subnav-list-type2 > a:first-child', $(this).closest('.subnav-list')).focus();
            }
        } else if (e.keyCode == 39) {
            // right
            var next = $(this).closest('.subnav-list-type2').parent().next();
            if (next.length > 0) {
                $('> .subnav-list-type2 > a:first-child', next).focus();
            } else {
                $('> .container > .row > div:first-child > .subnav-list-type2 > a:first-child', $(this).closest('.subnav-list')).focus();
            }
        } else if (e.keyCode == 38) {
            // up
            $(this).closest('.subnav-list').prev('a').focus();
        } else if (e.keyCode == 40) {
            // down
            var next = $('> a.more-link', $(this).closest('.subnav-list-type2'));
            if (next.length > 0) {
                $('> a.more-link', $(this).closest('.subnav-list-type2')).focus();
            }
        }
    });

    $('.hmb-component-header.visible-md .site-menubar > .nav-list > li > .subnav-list .subnav-list-type2 > a.more-link').keydown(function(e) {
        if(e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40) {
            e.preventDefault();
            e.stopPropagation();
        }
        if (e.keyCode == 37) {
            // left
            var prev = $(this).closest('.subnav-list-type2').parent().prev();
            if (prev.length > 0) {
                $('.subnav-list-type2 > a:last-child', prev).focus();
            } else {
                $('> .container > .row > div:last-child > .subnav-list-type2 > a:last-child', $(this).closest('.subnav-list')).focus();
            }
        } else if (e.keyCode == 39) {
            // right
            var next = $(this).closest('.subnav-list-type2').parent().next();
            if (next.length > 0) {
                $('.subnav-list-type2 > a:last-child', next).focus();
            } else {
                $('> .container > .row > div:first-child > .subnav-list-type2 > a:last-child', $(this).closest('.subnav-list')).focus();
            }
        } else if (e.keyCode == 38) {
            //up
            $('> a:first-child', $(this).closest('.subnav-list-type2')).focus();
        } else if (e.keyCode == 40) {
            //down
            var next = $(this).closest('.subnav-list-type2').parent().next();
            if (next.length > 0) {
                $('> .subnav-list-type2 > a:first-child', next).focus();
            } else {
                $('> .container > .row > div:first-child > .subnav-list-type2 > a:first-child', $(this).closest('.subnav-list')).focus();
            }
        }
    });
    
    /* SiteMenu Navigation - Mega Menu - Type 1 - Heading */
    $('.hmb-component-header.visible-md .site-menubar > .nav-list > li > .subnav-list .subnav-list-type1 > h3 > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).closest('.subnav-list-type1').parent().prev();
            if (prev.length>0) {
              $('> .subnav-list-type1 > h3 > a',prev).focus();
            }
            else {
              $('> .container > .row > div:last-child > .subnav-list-type1 > h3 > a',$(this).closest('.subnav-list')).focus();
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).closest('.subnav-list-type1').parent().next();
            if (next.length>0) {
              $('> .subnav-list-type1 > h3 > a',next).focus();
            }
            else {
              $('> .container > .row > div:first-child > .subnav-list-type1 > h3 > a',$(this).closest('.subnav-list')).focus();
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            $(this).closest('.subnav-list').prev('a').focus();
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            if ($(this).parent().next('ul').length>0) {
                $('> li:first-child > a',$(this).parent().next('ul')).focus();
            }
            else if ($('> a.more-link',$(this).closest('.subnav-list-type1')).length>0) {
                $('> a.more-link',$(this).closest('.subnav-list-type1')).focus();
            }
            else {
                var next = $(this).closest('.subnav-list-type1').parent().next();
                if (next.length>0) {
                  $('> .subnav-list-type1 > h3 > a',next).focus();
                }
                else {
                  $('> .container > .row > div:first-child > .subnav-list-type1 > h3 > a',$(this).closest('.subnav-list')).focus();
                }
            }
        }
    });
    
    /* SiteMenu Navigation - Mega Menu - Type 1 - Item link */
    $('.hmb-component-header.visible-md .site-menubar > .nav-list > li > .subnav-list .subnav-list-type1 > ul > li > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).closest('.subnav-list-type1').parent().prev();
            if (prev.length>0) {
              $('> .subnav-list-type1 > h3 > a',prev).focus();
            }
            else {
              $('> .container > .row > div:last-child > .subnav-list-type1 > h3 > a',$(this).closest('.subnav-list')).focus();
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).closest('.subnav-list-type1').parent().next();
            if (next.length>0) {
              $('> .subnav-list-type1 > h3 > a',next).focus();
            }
            else {
              $('> .container > .row > div:first-child > .subnav-list-type1 > h3 > a',$(this).closest('.subnav-list')).focus();
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).parent().prev('li');
            if (prev.length>0) {
                $('> a',prev).focus();
            }
            else {
                $('> h3 > a',$(this).closest('.subnav-list-type1')).focus();
            }
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).parent().next('li');
            if (next.length>0) {
                $('> a',next).focus();
            }
            else {
                $('a.more-link',$(this).closest('.subnav-list-type1')).focus();
            }
        }
    });
    
    /* SiteMenu Navigation - Mega Menu - Type 1 - More link */
    $('.hmb-component-header.visible-md .site-menubar > .nav-list > li > .subnav-list .subnav-list-type1 > a.more-link').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).closest('.subnav-list-type1').parent().prev();
            if (prev.length>0) {
              $('> .subnav-list-type1 > h3 > a',prev).focus();
            }
            else {
              $('> .container > .row > div:last-child > .subnav-list-type1 > h3 > a',$(this).closest('.subnav-list')).focus();
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).closest('.subnav-list-type1').parent().next();
            if (next.length>0) {
              $('> .subnav-list-type1 > h3 > a',next).focus();
            }
            else {
              $('> .container > .row > div:first-child > .subnav-list-type1 > h3 > a',$(this).closest('.subnav-list')).focus();
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            $('> li:last-child > a',$(this).prev('ul')).focus();
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).closest('.subnav-list-type1').parent().next();
            if (next.length>0) {
              $('> .subnav-list-type1 > h3 > a',next).focus();
            }
            else {
              $('> .container > .row > div:first-child > .subnav-list-type1 > h3 > a',$(this).closest('.subnav-list')).focus();
            }
        }
    });
    /* END - 2ND LEVEL NAVIGATION - USING ARROW KEYS */
    
    /* START - SECOND NAVIGATION BAR - USING ARROW KEYS */
    /* Second Navigation Bar - left most h3 item */
    $('.hmb-component-header.visible-md .secondnavigationbar > .secondnavigationbar-body > h3 > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:last-child > a').focus();
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).parent().next('ul');
            if (next.length>0) {
                $('> li:first-child > a',next).focus();
            }
            else {
                var next = $('.quick-links-scroll:visible > .card');
                if (next.length>0) {
                    $('> a:first-child',next).focus();
                }
                else {
                  $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div:first-child > h3 > a').focus();
                }
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:last-child > a').focus();
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            var next = $('.quick-links-scroll:visible > .card');
            if (next.length>0) {
                $('> a:first-child',next).focus();
            }
            else {  
              $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div:first-child > h3 > a').focus();
            }
        }
    });
    
    /* Second Navigation Bar - right ul items - focused class */
    $('.hmb-component-header.visible-md .secondnavigationbar > .secondnavigationbar-body > ul.secondnavigationbar-body-links > li > a').on('focus mouseover',function(e){
        if (!$(this).parent().hasClass('focused')) {
            $(this).parent().addClass('focused');
        }
        if ($(this).next('.second-subnav').length>0) {
            $(this).attr('aria-expanded','true');
        }
    }).on('blur mouseleave',function(e){
        $(this).parent().removeClass('focused');
        if ($(this).next('.second-subnav').length>0) {
            $(this).attr('aria-expanded','false');
        }
    });
    $('.hmb-component-header.visible-md .secondnavigationbar > .secondnavigationbar-body > ul.secondnavigationbar-body-links > li > .second-subnav > ul.second-subnav-links > li > a').on('focus mouseover',function(e){
        var parent = $(this).closest('.secondnavigationbar-body-link');
        if (!parent.hasClass('focused')) {
            parent.addClass('focused');
        }
        $('> a',parent).attr('aria-expanded','true');
    }).on('blur mouseleave',function(e){
        var parent = $(this).closest('.secondnavigationbar-body-link');
        parent.removeClass('focused');
        $('> a',parent).attr('aria-expanded','false');
    });
    
    /* Second Navigation Bar - right ul items - 1st level item */
    $('.hmb-component-header.visible-md .secondnavigationbar > .secondnavigationbar-body > ul.secondnavigationbar-body-links > li > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).parent().prev('li');
            if (prev.length>0) {
              $('> a',prev).focus();
            }
            else {
              var prev = $('> h3 > a',$(this).closest('.secondnavigationbar-body'));
              if (prev.length>0) {
                prev.focus();
              }
              else {
                $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:last-child > a').focus();
              }
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).parent().next('li');
            if (next.length>0) {
              $('> a',next).focus();
            }
            else {
              var next = $('.quick-links-scroll:visible > .card');
              if (next.length>0) {
                $('> a:first-child',next).focus();
              }
              else {
                $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div:first-child > h3 > a').focus();
              }
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:last-child > a').focus();
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            
            var dropdown = $(this).next('.second-subnav');
            if (dropdown.length > 0) {
                $('> ul > li:first-child > a',dropdown).focus();
            }
            else {
                var next = $('.quick-links-scroll:visible > .card');
                if (next.length>0) {
                    $('> a:first-child',next).focus();
                }
                else {
                    $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div:first-child > h3 > a').focus();
                }
            }
        }
    });
    
    /* Second Navigation Bar - right ul items - dropdown */
    $('.hmb-component-header.visible-md .secondnavigationbar > .secondnavigationbar-body > ul.secondnavigationbar-body-links > li > .second-subnav > ul > li > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            $(this).closest('.second-subnav').prev('a').focus();
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            $(this).closest('.second-subnav').prev('a').focus();
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).parent().prev('li');
            if (prev.length>0) {
                $('> a',prev).focus();
            }
            else {
                $('> li:last-child > a',$(this).closest('.second-subnav-links')).focus();
            }
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            
            var next = $(this).parent().next('li');
            if (next.length>0) {
                $('> a',next).focus();
            }
            else {
                $('> li:first-child > a',$(this).closest('.second-subnav-links')).focus();
            }
        }
    });
    /* END - SECOND NAVIGATION BAR - USING ARROW KEYS */
    
    /* START - QUICK LINKS BAR - USING ARROW KEYS */
    $('.quick-links-scroll > .card > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            var prev = $(this).prev('a');
            if (prev.length>0) {
                prev.focus();
            }
            else {
                var prev = $('.hmb-component-header.visible-md .secondnavigationbar');
                if (prev.length>0) {
                    var prev2 = $('> .secondnavigationbar-body > ul.secondnavigationbar-body-links > li:last-child > a',prev);
                    if (prev2.length>0) {
                        prev2.focus();
                    }
                    else {
                        $('> .secondnavigationbar-body > h3 > a',prev).focus();
                    }
                }
                else {
                    $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:last-child > a').focus();
                }
            }
        }
        else if (e.keyCode==39) {
            //right
            var next = $(this).next('a');
            if (next.length>0) {
                next.focus();
            }
            else {
                $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div:visible:first > h3 > a').focus();
            }
        }
        else if (e.keyCode==38) {
            //up
            var prev = $('.hmb-component-header.visible-md .secondnavigationbar');
            if (prev.length>0) {
                var prev2 = $('> .secondnavigationbar-body > ul.secondnavigationbar-body-links > li:last-child > a',prev);
                if (prev2.length>0) {
                    prev2.focus();
                }
                else {
                    $('> .secondnavigationbar-body > h3 > a',prev).focus();
                }
            }
            else {
                $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:last-child > a').focus();
            }
        }
        else if (e.keyCode==40) {
            //down
            $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div:visible:first > h3 > a').focus();
        }
    });
    /* END - QUICK LINKS BAR - USING ARROW KEYS */
    
    /* START - FOOTER NAVIGATION - USING ARROW KEYS */
    /* Footer Top - heading link */
    $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div > h3 > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).closest('div').prev('div');
            if (prev.length > 0) {
                $('> h3 > a',prev).focus();
            }
            else {
                $('> div:last-child > h3 > a',$(this).closest('.footer-top')).focus();
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).closest('div').next('div');
            if (next.length > 0) {
                $('> h3 > a',next).focus();
            }
            else {
                $('> div:first-child > h3 > a',$(this).closest('.footer-top')).focus();
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            
            var prev = $('.quick-links-scroll:visible > .card');
            if (prev.length>0) {
                $('> a:last-child',prev).focus();
            }
            else {
                var prev = $('.hmb-component-header.visible-md .secondnavigationbar');
                if (prev.length>0) {
                    var prevLastItem = $('> .secondnavigationbar-body > ul > li:last-child > a',prev);
                    if (prevLastItem.length>0) {
                        prevLastItem.focus();
                    }
                    else {
                        $('> .secondnavigationbar-body > h3 > a',prev).focus();
                    }
                }
                else {
                    $('.hmb-component-header.visible-md .site-menubar > .nav-list > li:last-child > a').focus();
                }
            }
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            var childLinks = $('> ul',$(this).closest('div'));
            if (childLinks.length>0) {
                $('> li > a:not([href=""])',childLinks).first().focus();
            }
            else {
                var next = $(this).closest('div').next('div');
                if (next.length > 0) {
                    $('> h3 > a',next).focus();
                }
                else {
                    $('> div:first-child > h3 > a',$(this).closest('.footer-top')).focus();
                }
            }
        }
    });
    
    /* Footer Top - normal link */
    $('#hmb-footer > .inner-container > .foot-inner > .footer-top > div > ul > li > a').keydown(function(e){
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).prev('a');
            if (prev.length>0) {
                prev.focus();
            }
            else {
                var prev = $(this).closest('div').prev('div');
                if (prev.length > 0) {
                    $('> h3 > a',prev).focus();
                }
                else {
                    $('> div:last-child > h3 > a',$(this).closest('.footer-top')).focus();
                }
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).next('a');
            if (next.length>0) {
                next.focus();
            }
            else {
                var next = $(this).closest('div').next('div');
                if (next.length > 0) {
                    $('> h3 > a',next).focus();
                }
                else {
                    $('> div:first-child > h3 > a',$(this).closest('.footer-top')).focus();
                }
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            var itemAbove = $('> a:not([href=""])',$(this).parent().prevAll('li')).last();
            if (itemAbove.length>0) {
              itemAbove.focus();
            }
            else {
              $('> h3 > a',$(this).closest('div')).focus();
            }
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            var itemBelow = $('> a:not([href=""])',$(this).parent().nextAll('li')).first();
            //var itemBelow = $(this).parent().next('li');
            if (itemBelow.length>0) {
              //$('> a:first-child',itemBelow).focus();
              itemBelow.focus();
            }
            else {
              var footerBottom = $('> .footer-bottom:first',$(this).closest('.foot-inner'));
              $('> div:first-child > ul > li:first-child > a',footerBottom).focus();
            }
        }
    });
    
    /* Footer Bottom - link */
    $('#hmb-footer > .inner-container > .foot-inner > .footer-bottom > div > ul > li > a').keydown(function(e){
        var mobileMenuVisible = false;
        if ($('nav#mobile-header').is(':visible')) {
            mobileMenuVisible = true;
        }
        if (e.keyCode==37) {
            //left
            e.preventDefault();
            e.stopPropagation();
            var prev = $(this).parent().prev('li');
            if (prev.length>0) {
                $('> a',prev).focus();
            }
            else {
                var prevMenu = $(this).closest('.footer-bottom').prev('div');
                $('> div:last-child > ul > li:last-child > a:last-child',prevMenu).focus();
            }
        }
        else if (e.keyCode==39) {
            //right
            e.preventDefault();
            e.stopPropagation();
            var next = $(this).parent().next('li');
            if (next.length>0) {
                $('> a',next).focus();
            }
            else {
                var nextMenu = $(this).closest('.footer-bottom').next('.footer-bottom');
                if (nextMenu.length > 0) {
                  $('> div:last-child > ul > li:first-child > a',nextMenu).focus(); 
                }
                else {
                  $('.hmb-component-header.visible-md .top-nav .global-links:first :first-child').focus();
                }
            }
        }
        else if (e.keyCode==38) {
            //up
            e.preventDefault();
            e.stopPropagation();
            if (mobileMenuVisible) {
                var prev = $(this).parent().prev('li');
                if (prev.length>0) {
                    $('> a',prev).focus();
                }
                else {
                    var prevMenu = $(this).closest('.footer-bottom').prev('div');
                    $('> div:last-child > ul > li:last-child > a:last-child',prevMenu).focus();
                }
            }
            else {
                var prevMenu = $(this).closest('.footer-bottom').prev('div');
                $('> div:last-child > ul > li:last-child > a:last-child',prevMenu).focus();
            }
        }
        else if (e.keyCode==40) {
            //down
            e.preventDefault();
            e.stopPropagation();
            if (mobileMenuVisible) {
                var next = $(this).parent().next('li');
                if (next.length>0) {
                    $('> a',next).focus();
                }
                else {
                    var nextMenu = $(this).closest('.footer-bottom').next('.footer-bottom');
                    if (nextMenu.length > 0) {
                      $('> div:last-child > ul > li:first-child > a',nextMenu).focus(); 
                    }
                    else {
                      $('.hmb-component-header.visible-md .top-nav .global-links:first :first-child').focus();
                    }
                }
            }
            else {
                var nextMenu = $(this).closest('.footer-bottom').next('.footer-bottom');
                if (nextMenu.length > 0) {
                  $('> div:last-child > ul > li:first-child > a',nextMenu).focus(); 
                }
                else {
                    $('.hmb-component-header.visible-md .top-nav .global-links:first :first-child').focus();
                }
            }
        }
    });
    /* END - FOOTER NAVIGATION - USING ARROW KEYS */
    
    // make sure touch devices can open up the mega menu, and second click goes to the link
    $(document).on('click', '#hmb-header.visible-md.visible-lg .site-menubar > .nav-list > li > a', function(e) {
        if ('ontouchstart' in window) {
            if ($(this).next('.subnav-list').length > 0) {
                if ($(this).next('.subnav-list').css('opacity')=='0') {
                        e.preventDefault();
                }
            }
        }
    });
    $(document).on('touchend', '#hmb-header.visible-md.visible-lg .secondnavigationbar > .secondnavigationbar-body > ul > li > a', function(e) {
          if ($(this).next('.second-subnav').length>0) {
              if (!$(this).closest('.secondnavigationbar-body-link').hasClass('focused')) {
                e.preventDefault();
                $(this).focus();
              }
          }
    });
});
function scrolltoAccordion(accordionId) {
  $( accordionId ).collapse('show');
  if($(accordionId).offset() !== undefined) {
      $('html,body').animate({
          scrollTop: $(accordionId).offset().top - 80
      });
  }
}

var checkUrlParameter = function() {
  var queryParam = window.location.hash;
  queryParam = queryParam.replace(/([ ;&,.+*~\':"!^$[\]()=>|\/@])/g, "");
  if(queryParam !== "") {
     scrolltoAccordion(queryParam);
  }
}

$(window).load(function() {
    checkUrlParameter();
});
//     jQuery Ajax Native Plugin

//     (c) 2015 Tarik Zakaria Benmerar, Acigna Inc.
//      jQuery Ajax Native Plugin may be freely distributed under the MIT license.
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals (root is window)
        factory(root.jQuery);
    }
}(this, function ( $ ) {
    var ajaxSettings = $.ajaxSettings;
    ajaxSettings.responseFields.native = 'responseNative';
    ajaxSettings.converters[ '* native' ] = true;
    var support = {},
        xhrId = 0,
        xhrSuccessStatus = {
            // file protocol always yields status code 0, assume 200
            0: 200,
            // Support: IE9
            // #1450: sometimes IE returns 1223 when it should be 204
            1223: 204
        },
        xhrCallbacks = {},
        xhrSupported = jQuery.ajaxSettings.xhr();
    // Support: IE9
    // Open requests must be manually aborted on unload (#5280)
    if ( window.ActiveXObject ) {
        $( window ).on( "unload", function() {
            for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]();
            }
        });
    }
    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    support.ajax = xhrSupported = !!xhrSupported;

    //Native Data Type Ajax Transport
    $.ajaxTransport('native', function ( options ) {
        var callback;
        // Cross domain only allowed if supported through XMLHttpRequest
        if ( support.cors || xhrSupported && !options.crossDomain ) {
            return {
                send: function( headers, complete ) {
                    var i,
                        xhr = options.xhr(),
                        id = ++xhrId,
                        responses = {};

                    xhr.open( options.type, options.url, options.async, options.username, options.password );

                    // Apply custom fields if provided
                    if ( options.xhrFields ) {
                        for ( i in options.xhrFields ) {
                            xhr[ i ] = options.xhrFields[ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( options.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( options.mimeType );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for ( i in headers ) {
                        xhr.setRequestHeader( i, headers[ i ] );
                    }

                    // Callback
                    callback = function( type ) {
                        return function() {
                            if ( callback ) {
                                delete xhrCallbacks[ id ];
                                callback = xhr.onload = xhr.onerror = null;

                                if ( type === "abort" ) {
                                    xhr.abort();
                                } else if ( type === "error" ) {
                                    complete(
                                        // file: protocol always yields status 0; see #8605, #14207
                                        xhr.status,
                                        xhr.statusText
                                    );
                                } else {
                                    // The native response associated with the responseType
                                    // Stored in the xhr.response attribute (XHR2 Spec)
                                    if ( xhr.response ) {
                                        responses.native = xhr.response;
                                    }

                                    complete(
                                        xhrSuccessStatus[ xhr.status ] || xhr.status,
                                        xhr.statusText,
                                        responses,
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    xhr.onerror = callback("error");

                    // Create the abort callback
                    callback = xhrCallbacks[ id ] = callback("abort");

                    try {
                        // Do send the request (this may raise an exception)
                        xhr.send( options.hasContent && options.data || null );
                    } catch ( e ) {
                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if ( callback ) {
                            throw e;
                        }
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback();
                    }
                }
            };
        }
    });


    //$.getNative wrapper
    $.getNative = function ( url, callback ) {
        return $.ajax({
            dataType: 'native',
            url: url,
            xhrFields: {
                responseType: 'arraybuffer'
            },
            success: callback
        });
    };

    //$.getBlob wrapper
    $.getBlob = function ( url, callback ) {
        return $.ajax({
            dataType: 'native',
            url: url,
            xhrFields: {
                responseType: 'blob'
            },
            success: callback
        });
    };

    //Return the jQuery Object
    return $;

}));

//This script is for opening chat boxes on click of <a> tags(for <a> tags within RTE components).
$(document).on('ready', function() {
    $(".one-spark-chat-box").on('click', function() {
        gwc_GetCommand(); 
        return false;
    });
    //This can be removed once the VA squad includes this in the above main function.
    $(document).on("click", ".one-spark-web-chat-box", function() {
        CXBus.command('WebChat.open'); 
        return false;    
    });
});

var snzCoverageMap = {
    /**
     * 
     * @param {*}
     *            layerNames is an array of layer names, e.g. ["LoRaWAN",
     *            "CAT-M1"]
     */
    init : function initMap() {
        var layerNames = [];
        if ($("#network-coverage-3g").val() != "") {
            layerNames.push($("#network-coverage-3g").val());
        }
        if ($("#network-coverage-4g").val() != "") {
            layerNames.push($("#network-coverage-4g").val());
        }
        if ($("#network-coverage-5g").val() != "") {
            layerNames.push($("#network-coverage-5g").val());
        }
        if ($("#network-coverage-wifi").val() != "") {
            layerNames.push($("#network-coverage-wifi").val());
        }
        if ($("#network-coverage-catm1").val() != "") {
            layerNames.push($("#network-coverage-catm1").val());
        }
        if ($("#network-coverage-lorawan").val() != "") {
            layerNames.push($("#network-coverage-lorawan").val());
        }
        // One of 3G, WiFi Sites, CAT-M1, LoRaWAN, 4G, 5G
        if (layerNames && layerNames.length) {
            var layers = layerNames.map(function(layerName) {
                var layerKey = Object.keys(wialus.layerDefinitions).find(function(key) {
                    return wialus.layerDefinitions[key].description === layerName;
                });
                return layerKey && wialus.layerDefinitions[layerKey];
            }).filter(Boolean);

            if (layers.length) {
                wialus.layerDefinitions = {};
                wialus.layerDefinitionsOrder = [];
                layers.forEach(function(layer) {
                    wialus.layerDefinitions[layer.id] = layer;
                    wialus.layerDefinitionsOrder.push(layer.id);
                });
            }
        }
    },

    show : function showMap() {
        if (!wialus.Bootstrap)
            return;

        var bootstrapper = new wialus.Bootstrap(function() {
            bootstrapper.getMap().setOptions({
                zoomControl : false,
                mapTypeControl : false,
                streetViewControl : false,
                rotateControl : false,
                scaleControl : false,
                fullscreenControl : false,
            });
            $("#coverage-map-options").css("display", "block");
            $("#wivolo-search-btn").val("Search");
        });
    },
};
  


$(document).ready(function () {

	$(document).click(function(){
		$(".theme-options-wrap").removeClass('theme-select-reference');
	});

	$('.theme-select-actions button').on('click', function(e){	
		e.stopPropagation();
		$(this).siblings(".theme-options-wrap").toggleClass('theme-select-reference');
	});

});
$(document).ready(function () {

	var mqVarThemeBox = window.matchMedia("(min-width: 640px)");
	if ($('.lab-themes-box').length) {
		if (mqVarThemeBox.matches) {
			var themeBoxMaxHeight = 0;
			$('.lab-themes-box').each(function() {
				var getHeightThemeBox = $(this).height();
				if (getHeightThemeBox > themeBoxMaxHeight) {
					themeBoxMaxHeight = getHeightThemeBox;
				}
			});
			$('.lab-themes-box').height(themeBoxMaxHeight);
		}
	}

});
$(document).ready(function () {
	
	if($('.event-share-panel').length){
		$('.event-share-panel a').on("click", function(){
			socialMediaShareLinks($(this));
		});
	}
	
});
(function(){

})();
(function($, $document) {
$(document).on("dialog-ready", function() {
	var count=0;
		$(".coral-TabPanel-content section").each(function(){
			count=++count;
			$(this).find("input[value='Internal']").attr("id","internal"+count);
			$(this).find("input[value='External']").attr("id","external"+count);
			$(this).each(function(){
				if($(this).find('.coral-FixedColumn-column .coral-Form-fieldwrapper .coral-RadioGroup .coral-Radio input:radio').is(':checked') === false) {
			        $(this).find('.coral-FixedColumn-column .coral-Form-fieldwrapper .coral-RadioGroup .coral-Radio input:radio').filter('[value=Internal]').prop('checked', true);
			    }
			});
			if($(this).find("input").length > 0){
				$(this).find("input").closest('section').find(".coral-FixedColumn-column section.externalSection").hide();
				if($(this).find("input[value='Internal']").is(":checked")){
					$(this).closest('section').find(".coral-FixedColumn-column section.internalSection").show();
					$(this).closest('section').find(".coral-FixedColumn-column section.externalSection").hide();
				}
				if($(this).find("input[value='External']").is(":checked")){
					$(this).closest('section').find(".coral-FixedColumn-column section.externalSection").show();
					$(this).closest('section').find(".coral-FixedColumn-column section.internalSection").hide();
				}
			}
			$('#internal'+count).on('click', function() {
				$(this).closest('section').find(".coral-FixedColumn-column section.internalSection").show();
				$(this).closest('section').find(".coral-FixedColumn-column section.externalSection").hide();
			});
			$('#external'+count).on('click', function() {
				$(this).closest('section').find(".coral-FixedColumn-column section.externalSection").show();
				$(this).closest('section').find(".coral-FixedColumn-column section.internalSection").hide();
			});
			
		});
		
	});
	
})($, $(document));

(function(){
	
		$(".related-content2-gallery").slick({
			resize: true,
			dots: false,
			infinite: true,
			variableWidth: true,
			slidesToShow: 1,
			slidesToScroll: 1,
			responsive: [
				{
				  breakpoint: 640,
				  settings: {
					slidesToShow: 1,
					slidesToScroll: 1
				  }
				}
			]
		});	
		
		$(window).load(function() {
			articleRelatedContentImage();
		});
})();

$(window).resize(function(){
	articleRelatedContentImage();
});

function articleRelatedContentImage(){
	if ($(".related-content2-list").length) {
		$(".related-content2-list").css("height","");
		var maxHeight = 0;
		$(".related-content2-list").each(function() {
			var getHeightArticalRef = $(this).height();
			if (getHeightArticalRef > maxHeight) {
				maxHeight = getHeightArticalRef;
			}
		});
		$(".related-content2-list").height(maxHeight);
		$(".related-content2-list").addClass('panel-theme');
	}
}
$(document).ready((function(){
	$.getScript("https://www.google.com/recaptcha/api.js"); 

	$(".event-register-success-block").hide(); 
	$(".event-register-error-block").hide();

	$("form[name='registertoattendform'] #submit").click(function(e) {
		var form = $("form[name='registertoattendform']");
		var fields = form.find('input');
		if (fields.valid()) {
			var registerForm = $('#registertoattend-form');
			var registerFormData = registerForm.serialize();
			submitRegistrationForm(registerFormData);
		}
		e.preventDefault();
	});

	 $('.register-custom-dropdown button').on('click', function(){ 
		//$(this).siblings('ul').toggle();
		$(this).siblings('ul').addClass('open');
	}); 
	 
	$(".register-dropdown-menu li").on('click', function(){
		$(this).parents(".custom-dropdown").find('button label').addClass('select-dropdown-val').html($(this).text());
		inputEl = $(this).parents(".custom-dropdown").find('button input').val($(this).text());
		$('#' + inputEl.attr('id') + 'Error').empty();
		//$(this).parent().hide();
	});

	jQuery.validator.addMethod("verifyEmail", function(value, element) {
		var pattern = /^([a-z\d!#$%&'*+\-\/=?^_`{|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+(\.[a-z\d!#$%&'*+\-\/=?^_`{|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)*|"((([ \t]*\r\n)?[ \t]+)?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*(([ \t]*\r\n)?[ \t]+)?")@(([a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|[a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF][a-z\d\-._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]*[a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])\.)+([a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|[a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF][a-z\d\-._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]*[a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])\.?$/i;
		return this.optional( element ) || pattern.test( value );
	});

	// Validating 7 to 9 digits in regex, excluding +64 and 0.
	jQuery.validator.addMethod("verifyPhone", function(value, element) {
		var pattern = /^[A-Za-z0-9_@./#&+-/\d\-_]+$/;
		return this.optional( element ) || pattern.test( value );
	});
	
	function submitRegistrationForm(data){
		var registrationFormAction = $( '#registertoattend-form' ).attr('action');
		$.ajax({
			url:registrationFormAction,
			type:'post',
			data:data,
			dataType:'text',
			async:false,
			success: function () {
				$(".event-register-form-block").hide();
				$('#modal-register #register-iframe', window.parent.document).addClass('event-msg-sucess-error');
				$(".event-register-success-block").show();
			},
			error: function (xhr, errorTest, thrownError) {
				if (xhr.status == 412){
					$("#captcha_error").html("Please solve the re-captcha challenge before submitting the form.");
				}
				else{

					if (xhr.status == 400 && xhr.responseText == "Sold out"){
						$("#registerform_errortext").html("This event cannot be registered for as it has already been sold out");
					}         		
					$(".event-register-form-block").hide();
					$('#modal-register #register-iframe', window.parent.document).addClass('event-msg-sucess-error');
					$(".event-register-error-block").show();
				}

			}
		});  

	}

	$("form[name='registertoattendform']").validate({
		ignore: [],
		rules: {
			first_name: 'required',
			last_name: 'required',
			email: {
				required : true,
				verifyEmail : true
			},
			company: 'required',
			title: 'required',
			industry: 'required',
			employees: 'required',
			phone: {
				required : true,
				verifyPhone : true
			}
		},
		messages: {
			first_name: 'Please enter your first name',
			last_name: 'Please enter your last name',
			email: {
				required : 'Please enter your valid email(name@address.com)',
				verifyEmail : 'Please enter a valid email address.'
			},
			title: 'Please enter your job title',
			company: 'Please enter your company',
			industry: 'Please enter your industry',
			employees: 'Please enter number of employees',
			phone: {
				required : 'Please enter your valid mobile number with no spaces and begin with a 0',
				verifyPhone : 'Please enter your valid mobile number with no spaces and begin with a 0'
			}
		},
		errorPlacement: function (error, element) {
			error.appendTo($('#' + element.attr('id') + 'Error'));
		},
		submitHandler: function (form) {
			return false;
		}
	});
	
	$('.register-group input').on("touchstart",function(){
		$(this).focus();
	});
})()
);
$(document).ready(function(){
	$(window).load(function() {
		var mqVarArticleRef = window.matchMedia("(min-width: 640px)");

		if ($(".article-ref-media").length) {
			if (mqVarArticleRef.matches) {
				$(".ref-article-container").each(function() {
					var maxHeight = 0;

					$(this).find(".reference-outer-wrap > div").each(function() {
						var getHeightArticalRef = $(this).height();
						if (getHeightArticalRef > maxHeight) {
							maxHeight = getHeightArticalRef;
						}
					});

					$(this).find(".reference-outer-wrap > div").height(maxHeight);
					$(this).find(".article-ref-media img").height(maxHeight);
				});
			}
		}
	});
});
$(document).ready(function(){

	$(".recent-video-holder .video-play").unbind('click').on('click', function(){
		var iframeSrc;
		$parentDiv = $(this).parent().parent();
		iframeSrc = $parentDiv.find(".video-placeholder iframe").attr("src");
		iframeSrc = iframeSrc + "?autoplay=1";

		$(this).hide();
		$parentDiv.find(".video-reference, .recent-video-time").hide();
		$parentDiv.find(".video-placeholder iframe").attr("src",iframeSrc);
		$parentDiv.find(".video-placeholder").show();
	});

	$(".recent-video-thumbnail").first().addClass("video-selected");

	$(".recent-video-reference .recent-video-thumbnail").on('click', function(){
		var $parentDiv = $(this);
		$siblingDiv = $parentDiv.parent().siblings(".recent-video-container");
		$siblingDiv.find(".recent-video-holder img").attr("src",$parentDiv.attr("data-videoImgUrl"));        
		$siblingDiv.find(".video-placeholder iframe").attr("src",$parentDiv.attr("data-videoUrl"));
		$siblingDiv.find(".recent-video-title-panel a").attr("href",$parentDiv.attr("data-pageUrl"));
		$siblingDiv.find(".recent-video-title-panel a").text($parentDiv.attr("data-pageTitle"));
		$siblingDiv.find(".recent-video-holder label").text($parentDiv.attr("data-videoDurationInMinutes"));
		$siblingDiv.find(".recent-video-stamp label span").html("Posted on " + $parentDiv.attr("data-pageUploadDate"));

		$siblingDiv.find(".video-placeholder").hide();
		$siblingDiv.find(".video-reference, .video-play").show();
		$(".recent-video-reference .recent-video-thumbnail.video-selected").removeClass("video-selected");
		$parentDiv.addClass("video-selected");

		var recentVideoScoll = window.matchMedia( "(max-width: 639px)" );	
        if (recentVideoScoll.matches){
            var vdoPosTop = $(".recent-video-group").offset().top;
            vdoPosTop = vdoPosTop - 10;
            $(window).scrollTop(vdoPosTop);
        }
	});

	$(".recent-video-reference .recent-video-link a").on('click', function(e){
		e.preventDefault();
	});
	var divBgColor;
	if($('.recent-video-title').length){
		var x = $('.recent-video-title').css('backgroundColor');
		if(x!="transparent"){
			hexc(x);
			divBgColor= color;
		}
	}    
	function hexc(colorval) {
		var parts = colorval.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
		delete(parts[0]);
		for (var i = 1; i <= 3; ++i) {
			parts[i] = parseInt(parts[i]).toString(16);
			if (parts[i].length == 1) parts[i] = '0' + parts[i];
		}
		color = '#' + parts.join('');
	}

	var mqVar2 = window.matchMedia( "(max-width: 647px)" );	
	var mqVar3 = window.matchMedia( "(min-width: 640px)" );
	if (mqVar2.matches){
		if (mqVar3.matches) {
			var heightArray = $(".recent-video-panel").map(function() {
				return  $(this).outerHeight();
			}).get();
			var maxHeight = Math.max.apply(Math, heightArray);
			calHt = maxHeight;
			$(".recent-video-panel:first-child").height(maxHeight);
			$(".recent-video-panel:first-child").css('background-color',divBgColor);
		}
	}	
	var mqVar2 = window.matchMedia( "(max-width: 767px)" );	
	var mqVar3 = window.matchMedia( "(min-width: 648px)" );
	if (mqVar2.matches){
		if (mqVar3.matches) {
			var heightArray = $(".recent-video-panel").map(function() {
				return  $(this).outerHeight();
			}).get();
			var maxHeight = Math.max.apply(Math, heightArray);
			calHt = (maxHeight*23)/100;
			$(".recent-video-panel:first-child").height(maxHeight + calHt);
			$(".recent-video-panel:first-child").css('background-color',divBgColor);
		}
	}
	var mqVar2 = window.matchMedia( "(max-width: 869px)" );	
	var mqVar3 = window.matchMedia( "(min-width: 768px)" );
	if (mqVar2.matches){
		if (mqVar3.matches) {
			var heightArray = $(".recent-video-panel").map(function() {
				return  $(this).outerHeight();
			}).get();
			var maxHeight = Math.max.apply(Math, heightArray);
			calHt = (maxHeight*23)/100;
			$(".recent-video-panel:first-child").height(maxHeight - calHt);
			$(".recent-video-thumbnail .recent-video-img, .recent-video-thumbnail .recent-video-link").css('margin-top','7%');
			$(".recent-video-thumbnail:first-child .recent-video-img, .recent-video-thumbnail:first-child .recent-video-link").css('margin-top','0');
			$(".recent-video-panel .recent-video-thumbnail").css('padding-bottom','8%');
		}
	}
	var mqVar2 = window.matchMedia( "(max-width: 1169px)" );	
	var mqVar3 = window.matchMedia( "(min-width: 870px)" );
	if (mqVar2.matches){
		if (mqVar3.matches) {
			var heightArray = $(".recent-video-panel").map(function() {
				return  $(this).outerHeight();
			}).get();
			var maxHeight = Math.max.apply(Math, heightArray);
			$(".recent-video-panel:first-child").height(maxHeight);
			$(".recent-video-thumbnail .recent-video-img, .recent-video-thumbnail .recent-video-link").css('margin-top','7%');
			$(".recent-video-thumbnail:first-child .recent-video-img, .recent-video-thumbnail:first-child .recent-video-link").css('margin-top','0');
			$(".recent-video-panel .recent-video-thumbnail").css('padding-bottom','6.7%');
		}
	}

	function dynamicContentHeight(getHeight, setHeight){
		var $featureImg = getHeight.height();
		setHeight.height($featureImg);
		featureImg= null;
	}

});
(function(){
	
	var data={};
	
	$(".rate-like, .rate-dislike").on('click', function(){
		var rateSelection = $(".selected").length;
		
		data['likeOrDislike'] = $(this).data("likeordislike");
		data['pageTitle'] = $(".rating-title").data("pagetitle");
		data['currentPagePath'] = $(".rating-title").data("currentpagepath");
		
		if(rateSelection ==0){
			$(this).toggleClass("selected");
		}
		if(rateSelection ==1){
			$(".rate-like, .rate-dislike").removeClass("selected");
			$(this).toggleClass("selected");
		}
		$(".rating-info .rate-like-info, .rating-info .rate-dislike-info").hide();
		if($(".rate-like").hasClass("selected")){
			$(".rating-info .rate-like-info").toggle();
			updateLikeDislikeNodesAjax(data);
		}
		if($(".rate-dislike").hasClass("selected")){
			$(".rating-info .rate-dislike-info").toggle();
			//data['dislikeComment'] = $(this).data("dislikecomment");
			updateLikeDislikeNodesAjax(data);
		}
	});
	
	function updateLikeDislikeNodesAjax(data){
		$.ajax({															
			type: 'POST',
			dataType: 'json',				
			data: data,							
			url: '/bin/sparklabs/rating.json',
			success: function(data){
			},
			failure: function(data){
			}
		});
	}
	
})();
(function(){
	var $status = $('.article-slider-paging');

	$('.article-slider').slick({
		resize: true,
		dots: false,
		infinite: true,
		speed: 500,
		fade: true,
		variableWidth: false,
		slidesToShow: 1,
		slidesToScroll: 1,
		responsive: [
		             {
		            	 breakpoint: 1170,
		            	 settings: {
		            		 slidesToShow: 1,
		            		 slidesToScroll: 1
		            	 }
		             },
		             {
		            	 breakpoint: 940,
		            	 settings: {
		            		 slidesToShow: 1,
		            		 slidesToScroll: 1
		            	 }
		             },
		             {
		            	 breakpoint: 640,
		            	 settings: {
		            		 slidesToShow: 1,
		            		 slidesToScroll: 1
		            	 }
		             },
		             {
		            	 breakpoint: 320,
		            	 settings: {
		            		 slidesToShow: 1,
		            		 slidesToScroll: 1
		            	 }
		             }
		             ]
	});	
	var currentSlideOnLoad = 1;
	slideCount(currentSlideOnLoad);
	
	$('.article-slider').on('init reInit afterChange', function (event, slick, currentSlide, nextSlide) {
		//currentSlide is undefined on init -- set it to 0 in this case (currentSlide is 0 based)
		var i = (currentSlide ? currentSlide : 0) + 1;
		slideCount(i);

	});

	function slideCount(currentSlide){
		if((undefined !== $(".article-slider").slick("getSlick").slideCount) && ($(".article-slider").slick("getSlick").slideCount !== 1)){
			$status.text(currentSlide + '/' + $(".article-slider").slick("getSlick").slideCount);
		}
		var array=$(".article-slider-caption");
		showDescription(array,currentSlide-1);
	}
	
	function showDescription(newArray,currentSlide){

		if(newArray != undefined && newArray.length >0){
			for(var i=0;i<newArray.length;i++){
				var id= $(newArray)[i].id;
				if(currentSlide==id){
					var caption= $(newArray)[i];
					$(caption).show();
				}else{
					var caption= $(newArray)[i];
					$(caption).hide();
				}
			}
		}
	}


})();
$(document).ready(function() {
	
	$(window).load(function() {
		var mqVarArticleRef = window.matchMedia("(max-width: 639px)");
		if ($(".hero-card-carousel").length) {
			if (mqVarArticleRef.matches) {
				var maxHeight = 0;
				$(".hero-card .hero-card-top").each(function() {
					var getHeightArticalRef = $(this).height();
					if (getHeightArticalRef > maxHeight) {
						maxHeight = getHeightArticalRef;
					}
				});
				$(".hero-card .hero-card-top").height(maxHeight);
			}
		}
	});

    if ($(window).width() > 639 && $('#myCarousel').length) {
        $('#myCarousel').carousel({
            interval: 3000
        });
    } else if ($(window).width() < 639) {

        $("#myCarousel .carousel-inner").css("display", "none");

    }
    var clickEvent = false;
    $('#myCarousel').on('click', '.nav a', function() {
        clickEvent = true;
       // $('.nav li').removeClass('active themecolor_1');
       //$(this).parent().addClass('active themecolor_1');

    }).on('slid.bs.carousel', function(e) {
        if (!clickEvent) {
            var count = $('.nav').children().length - 1;
            var current = $('.nav li.active');
            current.removeClass('active themecolor_1').next().addClass('active themecolor_1');
            var id = parseInt(current.data('slide-to'));
            if (count == id) {
                $('.nav li').first().addClass('active themecolor_1');
            }
        }
        clickEvent = false;
    });
    
    var mode = $('input[name=mode]').val();
    if ((undefined == mode || mode != 'edit') && $('.desktop-view div.hero-card').length>1 ) {
        createHeroCardCarousal(); 

    } else {
        editModeCarousal();
    }


    var mobslides = $(".herocard-mob-slider .hero-card").length;
    if (mobslides > 1) {
        $('.hero-card-mobile-carousel').slick({
            dots: false,
            infinite: ((undefined != mobslides && mobslides > 2) ? true : false),
            centerMode: true,
            slidesToShow: 1,
            slidesToScroll: 1,
        });
    }


});

window.setInterval(function(){
	if($("#myCarousel").length>0){
		if($('.nav.nav-pills.nav-justified.custom-hero-menu.hidden-xs li.active').index() != $('.carousel-inner.desktop-view div.active').index()){
			$('.nav.nav-pills.nav-justified.custom-hero-menu.hidden-xs li').removeClass('active themecolor_1');
			$('.nav.nav-pills.nav-justified.custom-hero-menu.hidden-xs li').eq($('.carousel-inner.desktop-view div.active').index()).addClass('active themecolor_1');
		}
	}
}, 0);

function createHeroCardCarousal() {
    var heroCrads = $('.desktop-view div.hero-card');
    var wraper = $('.carousel-inner.desktop-view');

    var tempHTML = "";
    var mobileHTML = "";
    var titleArray = new Array();
    for (var i = 0; i < heroCrads.length; i++) {
        $(heroCrads[i]).find('.btn-wrap').remove();
        var carousalTitle = getCarousalTitle($(heroCrads[i]));
        titleArray[i] = carousalTitle;
        tempHTML += '<div class="item ' + (i == 0 ? 'active' : '') + '">' + $(heroCrads[i]).html() + '</div>';

        mobileHTML += createMobileView($(heroCrads[i]));
    }

    $(wraper).html('');
    $(wraper).html(tempHTML);

    var navigation = $('ul.custom-hero-menu');
    $(navigation).html('');
    $(navigation).html(getNavigation(titleArray));

    $('.hero-card-mobile-carousel.herocard-mob-slider').html('');
    $('.hero-card-mobile-carousel.herocard-mob-slider').html(mobileHTML);

}

function editModeCarousal() {
    var heroCrads = $('.desktop-view div.hero-card');

    for (var i = 0; i < heroCrads.length; i++) {
        $(heroCrads[i]).find('.btn-wrap').remove();

    }
}

function getCarousalTitle(herocard) {
    var title = "";
    if (undefined != herocard) {
        var titleSpan = herocard.find('h1.block').find('span');
        if (undefined != titleSpan && titleSpan.length > 0) {
            for (var j = 0; j < titleSpan.length; j++) {
                title = title + titleSpan[j].innerHTML + " ";
            }
        }

    }
    return title.trim();
}

function getNavigation(titleArray) {
    var navigation = "";
    if (undefined != titleArray && titleArray.length > 0) {

        for (var i = 0; i < titleArray.length; i++) {
            navigation += '<li data-target="#myCarousel" data-slide-to="' + i + '" class="' + (i == 0 ? 'active' : '') + '" ><a href="#">' + titleArray[i] + '</a></li>'
        }
    }
    return navigation;
}

function createMobileView(herocard) {
    var mobileHtml = "";
    if (undefined != herocard) {

        var image = herocard.find('div.hero-img').attr("style");
        var titleBlock = herocard.find('h1.block').html();
        var textBlock = herocard.find('div.hero-content-block.blackbox').html();
        var buttonBlock = herocard.find('div.hero-btn-container').html();


        mobileHtml = '<div class="hero-card "><div class="hero-card-panel pos-rel">' +
            '<div class="hero-img" style="' + (undefined != image ? image : '') + '"></div>' +
            '<div class="hero-card-top vertical-center"><div class="inner-container"><div class="row">' +
            '<div class="col-xs-11 col-xs-offset-1"><div class="hero-card-inner">' +
            '<h1 class="block">' + (undefined != titleBlock ? titleBlock : '') + '</h1>' +
            '<div class="hero-content-block blackbox">' + (undefined != textBlock ? textBlock : '') + '</div>' +
            '<div class="hero-btn-container">' + (undefined != buttonBlock ? buttonBlock : '') + '</div>' +
            '</div></div></div></div></div></div> <div class="clearfix"></div></div>';

    }
    return mobileHtml;

}
$(document).ready(function(){
	$(window).load(function() {
        var mqMinVarArticleRef = window.matchMedia("(min-width: 640px)");
        var mqMaxVarArticleRef = window.matchMedia("(max-width: 1200px)");
        if ($(".hero-article-img").length) {
            if (mqMinVarArticleRef.matches) {
                if (mqMaxVarArticleRef.matches) {
                    var maxHeight = 0;
                    $(".hero-article-container > div > div > div").each(function() {
                        var getHeightArticalRef = $(this).height();
                        if (getHeightArticalRef > maxHeight) {
                            maxHeight = getHeightArticalRef;
                        }
                    });
                    $(".hero-article-img img").height(maxHeight);
                }
            }
        }
    });
});
$(document).ready(function(){

   $(".event-speakers-register").on('click', '#registerBtn', function(e) {
      $('#register-iframe').attr('src', $('#registrationLink').val());
      $('#modal-register #register-iframe').removeClass('event-msg-sucess-error');

    });  

}); 
$(document).ready(function(){
	$(".event-group-filter-container .event-dropdown.dropdown-menu li a").click(function() {
        $(this).parents(".custom-dropdown").find('.tablet-fix').html(' <span class="event-option-selected themecolor_2">' + $(this).text() + '</span><span class="icon-arrow-down themecolor_2 pull-right"> </span><span class="bottom-line themecolor_2_bg"></span>');
        $(this).parents(".custom-dropdown").find('.tablet-fix').val($(this).data('value')).addClass('drop-val');
    });
	
	var selectedOption="";
	$(".event-dropdown.dropdown-menu >li >a").on('click',function(){
		selectedOption = $(this).html();
		$(this).closest(".event-dropdown-wrap").find('.event-option-selected').html(selectedOption);
		$(this).closest(".event-dropdown-wrap").find('.selected-option-style').removeClass('selected-option-style');
		$(".event-dropdown-wrap").find('.options-dropdown').removeClass('event-dropdown-options');
		selectedOption ="";
		var selectedSort=$(this).closest(".event-filter-box").find("input[name=dropdownName]").val();
		var sortValue=$(this).attr("data-id");
		getAllSelectedSorts(selectedSort, sortValue, $(".event-dropdown.dropdown-menu li"));
		sortEvents();
	});
});

function getAllSelectedSorts(selectedSort, sortValue, clickedSort){
	if(undefined != selectedSort && undefined != clickedSort){
		if (selectedSort == 'sessions') {
			$(clickedSort).closest(".event-filter-box").find('input[id="sessionsDropDown"]').attr("data-sel-session-value", selectedSort);
			$(clickedSort).closest(".event-filter-box").find('input[id="sessionsDropDown"]').attr("data-sel-session-id", sortValue);
		} else if (selectedSort == 'locations') {
			$(clickedSort).closest(".event-filter-box").find('input[id="locationDropDown"]').attr("data-sel-location-value", selectedSort);
			$(clickedSort).closest(".event-filter-box").find('input[id="locationDropDown"]').attr("data-sel-location-id", sortValue);
		} else if (selectedSort == 'sort') {
			$(clickedSort).closest(".event-filter-box").find('input[id="sortDropDown"]').attr("data-sel-sort-value", selectedSort);
			$(clickedSort).closest(".event-filter-box").find('input[id="sortDropDown"]').attr("data-sel-sort-id", sortValue);
		}
	}
}
(function() {
	$('.event-view-more-wrap.eventList a').click(function(e) {
		e.preventDefault();
		var events = $(".event-list-group").find(".hideThis");
		if (undefined != events && events.length > 0) {
			for (var i = 0; i < 6; i++) {
				$(events[i]).removeClass("hideThis");
				$(events[i]).addClass("showThis");
				$(events[i]).show();
			}
		}
		showHideCheckMore();
	});
})();

function showHideCheckMore() {
	var hideViewMore = $(".event-list-group").find(".hideThis");
	if (undefined != hideViewMore && hideViewMore.length == 0) {
		$(".event-view-more-wrap.eventList").hide();
	} else {
		$(".event-view-more-wrap.eventList").show();
	}
}

if($("input[name=eventJson]").length){
	sortEvents();
}

function sortEvents() {
	var eventJson = $("input[name=eventJson]").val();
	var eventArray = JSON.parse(eventJson);
	var newArray = "";
	if (undefined != eventArray && eventArray.length > 0) {
		newArray = getEventsBySort($('input[id="sortDropDown"]').attr("data-sel-sort-id"), eventArray);
		if(undefined !== $('input[id="sessionsDropDown"]').attr("data-sel-session-id") && $('input[id="sessionsDropDown"]').attr("data-sel-session-id") !== ""){
			newArray = getEventsBySession($('input[id="sessionsDropDown"]').attr("data-sel-session-id"), newArray);
		}
		if(undefined !== $('input[id="locationDropDown"]').attr("data-sel-location-id") && $('input[id="locationDropDown"]').attr("data-sel-location-id") !== ""){
			newArray = getEventsByLocations($('input[id="locationDropDown"]').attr("data-sel-location-id"), newArray);
		}
		if($(".event-dropdown.dropdown-menu >li >a").length ==0){
			newArray = getEventsBySort(2, eventArray);
		}
		renderEventList(newArray);
		showHideCheckMore();
	}
}

function getEventsBySession(session, eventArray) {
	var newArray = new Array(eventArray.length);
	var count = 0;
	if (undefined != eventArray && eventArray.length > 0) {
		if (undefined != session && session == 'AM') {
			for (var i = 0; i < eventArray.length; i++) {
				if(undefined !== eventArray[i]){
					var event = eventArray[i].event;
					if (event.eventStartDate.hourOfDay < 12) {
						newArray[count] = eventArray[i];
						count++;
					}
				}
			}
		} else if (undefined != session && session == 'PM') {
			for (var i = 0; i < eventArray.length; i++) {
				if(undefined !== eventArray[i]){
					var event = eventArray[i].event;
					if (event.eventStartDate.hourOfDay >= 12) {
						newArray[count] = eventArray[i];
						count++;
					}
				}
			}
		} else {
			newArray = eventArray;
		}
	}
	return newArray;
}

function getEventsByLocations(location, eventArray) {
	var newArray = new Array(eventArray.length);
	var count = 0;
	if (undefined != eventArray && eventArray.length > 0) {
		if (undefined != location && location != 'All locations') {
			for (var i = 0; i < eventArray.length; i++) {
				if(undefined !== eventArray[i]){
					var event = eventArray[i].event;
					if (event.eventLocation == location) {
						newArray[count] = eventArray[i];
						count++;
					}
				}
			}
		} else {
			newArray = eventArray;
		}
	}
	return newArray;
}

function getEventsBySort(sortBy, eventArray) {
	if (undefined != sortBy && sortBy == '1') {
		eventArray.sort(sort1);

	} else if (undefined != sortBy && sortBy == '2') {
		eventArray.sort(sort2);
	} else if (undefined != sortBy && sortBy == '3') {
		eventArray.sort(sort3);
	} else {
		eventArray.sort(sort4);
	}
	return eventArray;
}

function sort1(a, b) {
	if (a.event.ageInMinutes < b.event.ageInMinutes)
		return -1;
	if (a.event.ageInMinutes > b.event.ageInMinutes)
		return 1;
	return 0;
}

function sort2(a, b) {
	if (a.event.ageInMinutes > b.event.ageInMinutes)
		return -1;
	if (a.event.ageInMinutes < b.event.ageInMinutes)
		return 1;
	return 0;
}

function sort3(a, b) {
	if (a.pageTitle < b.pageTitle)
		return -1;
	if (a.pageTitle > b.pageTitle)
		return 1;
	return 0;
}

function sort4(a, b) {
	if (a.pageTitle > b.pageTitle)
		return -1;
	if (a.pageTitle < b.pageTitle)
		return 1;
	return 0;
}

function renderEventList(eventArray) {
	var eventDiv = $('.event-ref-container').find('.col-xs-12');
	var showDateLocation = $("input[name=showDateLocation]").val();
	var newEventGrid = "";
	eventDiv.html('');
	if (undefined != eventArray && eventArray.length > 0) {
		for (var i = 0; i < eventArray.length; i++) {
			if (undefined != eventArray[i]) {
				var sparkPage = eventArray[i];
				newEventGrid += '<div class="event-reference-outer ' +
				(i < 6 ? 'showThis' : 'hideThis') +
				'" style=display:' +
				(i < 6 ? 'block' : 'none') +
				';>' +
				'<div class="event-ref-media wd-50 show-inline"><div class="pos-rel">' +
				'<a href="' +
				sparkPage.pageLink +
				'"><img src="' +
				(sparkPage.pageDefaultImage != undefined ? sparkPage.pageDefaultImage : '') +
				'" alt="' + (sparkPage.pageDefaultImageAltText) + '" class="img-responsive"></a>' +
				'</div></div><div class="event-ref-data-outer pos-rel show-inline"><i class="icon-arrow-right text-right"></i><div class="event-ref-data"><div class="event-reference-title ref-title-fix">' +
				'<h4 class="themecolor_1"> ' +
				(sparkPage.pageTitle != undefined ? sparkPage.pageTitle : '') +
				' </h4><a class="event-ref-data-link" href="' + 
                sparkPage.pageLink +
				'"></a>' +
				(undefined != sparkPage.pageDescription ? '<label> ' + sparkPage.pageDescription + '</label>': '') +
				'<hr class="underline themecolor_1_bg hidden-xs">' +
				'<div style="display:' + (showDateLocation == 'true' ? 'block' : 'none') + '"> ' +
				(sparkPage.event.formattedDate != undefined ? sparkPage.event.formattedDate : '') +
				((sparkPage.event.formattedDate != undefined && sparkPage.event.eventLocation != undefined) ? ', ' : '') +
				(sparkPage.event.eventLocation != undefined ? sparkPage.event.eventLocation : '') +
				'</div><div class="clearfix"></div>' +
				'</div></div></div><div class="clearfix"></div></div>';
			}
		}
	}
	eventDiv.html(newEventGrid);
}
$(document).ready(function () {


});

(function(){

})();
(function(){
	
	$(document).on("dialog-ready" ,function(e) {
		if($('.featuredCarousalWidth').length){
			$('.featuredCarousalWidth').css('width','50rem');
		}
	});
	
	var $slickElement = $('.lab-feature-carousel');

	$slickElement.slick({
		resize: true,
		dots: true,
		infinite: true,
		variableWidth: false,
		slidesToShow: 1,
		slidesToScroll: 1,
		responsive: [
			{
			  breakpoint: 1170,
			  settings: {
				slidesToShow: 1,
				slidesToScroll: 1
			  }
			},
			{
			  breakpoint: 940,
			  settings: {
				slidesToShow: 1,
				slidesToScroll: 1
			  }
			},
			{
			  breakpoint: 640,
			  settings: {
				slidesToShow: 1,
				slidesToScroll: 1
			  }
			},
			{
			  breakpoint: 320,
			  settings: {
				slidesToShow: 1,
				slidesToScroll: 1
			  }
			}
		]
	});	
	
	// reset the view to show image and video icons appropriately.
	$($slickElement).on('init reInit afterChange', function (event, slick, currentSlide, nextSlide) {
		$('.feature-carousel-img .article-feature-video-play').each(function(){
			var iframeSrc = $(this).siblings('.video-placeholder').find('iframe');
			$(this).show();
			$(this).siblings('img').show();
			$(this).siblings('.video-time').show();
			$(iframeSrc).attr("src",$(iframeSrc).attr('data-video-src') + "?&autoplay=false");
			$(this).siblings('.video-placeholder').hide();
		});

	});
	
	// play the video in carousal.
	$('.feature-carousel-img .article-feature-video-play').on('click', function(e){
		var iframeSrc = $(this).siblings('.video-placeholder').find('iframe');
		$(this).hide();
		$(this).siblings('img').hide();
		$(this).siblings('.video-time').hide();
		$(iframeSrc).attr("src",$(iframeSrc).attr('data-video-src') + "?&autoplay=1");
		$(this).siblings('.video-placeholder').show();
	});


	$(window).load(function() {

		featureDynamicContentHeight();
        function featureDynamicContentHeight(){
            var mqVarArticleRef = window.matchMedia("(min-width: 640px)");
            if ($(".lab-feature-carousel").length) {
                if (mqVarArticleRef.matches) {
                    var maxHeight = 0;
                    $(".lab-feature-carousel-slide > div").each(function() {
                        var getHeightArticalRef = $(this).height();
                        if (getHeightArticalRef > maxHeight) {
                            maxHeight = getHeightArticalRef;
                        }
                    });
                    $(".lab-feature-carousel-slide > div").height(maxHeight);
                    $(".lab-feature-carousel .feature-carousel-img img").height(maxHeight);
                    $(".lab-feature-carousel .video-placeholder iframe").height(maxHeight);
                }
            }
        }
        dynamicHeightUpdateForCards();
        $('.lab-feature-carousel .slick-dots').find('button').on('click', featureDynamicContentHeight());

    });
	
})();

$(window).resize(function() {
    $(window).trigger('load');
});
(function(){

	var listingFilterQuery = window.matchMedia( "(max-width: 1199px)" );
	if (listingFilterQuery.matches) {
	  $('.listing-filter-navigation').slick({
		  dots: false,
		  arrow: false,
		  infinite: false,
		  variableWidth: true,
		  speed: 300,
		  slidesToShow: 4,
		  slidesToScroll: 1,
		  responsive: [
			{
			  breakpoint: 1199,
			  settings: {
				slidesToShow: 4,
				slidesToScroll: 1,
				dots: false,
                arrow: false
			  }
			},
			{
			  breakpoint: 939,
			  settings: {
				slidesToShow: 3,
				slidesToScroll: 1,
				dots: false,
                arrow: false
			  }
			},
			{
			  breakpoint: 639,
			  settings: {
				slidesToShow: 2,
				slidesToScroll: 1,
				dots: false,
                arrow: false
			  }
			}
		  ]
		});
	}

	//$(window).resize(function(){location.reload();});	
	
	$('ul.listing-filter-navigation li').click(function(e) {
		var selected = $(this).find('#show').val();
		var url = window.location.href;
		url=url.replace("#", "");
		var reloadUrl = "";
		if (url.indexOf('?') > -1) {
			if (url.indexOf('display') > -1) {
				var rawParam = url.substring(url.indexOf('display') + 8);
				if (rawParam.indexOf('&') > -1) {
					var param = rawParam.substr(0, rawParam.indexOf('&'))
					reloadUrl = url.replace(param, selected);
				} else {
					reloadUrl = url.replace(rawParam, selected);
				}
			} else {
				reloadUrl = url;
				reloadUrl += '&display=' + selected;
			}
		} else {
            reloadUrl=url;
			reloadUrl += '?display=' + selected;
		}
		window.location.href = reloadUrl;
		sessionStorage.setItem('id', 'article-list');
	});
	
	 $('.article-view-more-wrap.desktop a').click(function(e) { 
	        e.preventDefault();
	         var desktopArticles = $(this).parents('.article-view-more-wrap').parent().siblings('.article-grid-listing-panel').find(".article-list-grid").find(".hideThis");
	         displayArticles(desktopArticles);
	         var value="desktop";
	         checkViewMoreLink(value, $(this));

		});


	 $('.article-view-more-wrap.mobile a').click(function(e) { 
	        e.preventDefault();
	         var mobileArticles = $(this).parents('.article-view-more-wrap').parent().siblings('.article-grid-listing-panel').find(".article-list-gallery").find(".hideThis");
	         displayArticles(mobileArticles);
	         var value="mobile";
	         checkViewMoreLink(value, $(this));

	 });

	   var value="desktop";
	   checkViewMore(value);
		  
	
})();

$(document).ready(function(){
	var data = sessionStorage.getItem('id');
	if(data != null){
		//setTimeout( function(){
			location.hash = "#" + data;
		//},300);
		sessionStorage.removeItem('id');
	}
});

//Height update of the cards
function dynamicHeightUpdateForCards(){
	if ($(".article-list-grid").length) {
		var maxHeight = 0;
		$(".article-list-grid .article-list-panel .article-theme").each(function() {
			var getHeightArticalRef = $(this).height();
			if (getHeightArticalRef > maxHeight) {
				maxHeight = getHeightArticalRef;
			}
		});

		$(".article-list-grid .article-list-panel .article-theme").height(maxHeight);
	}
}

function checkViewMoreLink(value, currentObject) {
    var hideviewmore = "";
    if (undefined != value && value == 'desktop') {
        hideviewmore = $(currentObject).parents('.article-view-more-wrap').parent().siblings('.article-grid-listing-panel').find(".article-list-grid").find(".hideThis");
    } else if (undefined != value && value == 'mobile') {
        hideviewmore = $(currentObject).parents('.article-view-more-wrap').parent().siblings('.article-grid-listing-panel').find(".article-list-gallery").find(".hideThis");

    }

    if (undefined != hideviewmore && hideviewmore.length == 0) {
        if (value == 'desktop') {
            $(currentObject).parents('.article-view-more-wrap').hide();
        } else {
            $(currentObject).parents('.article-view-more-wrap').hide();
        }
    } else {
        if (value == 'desktop') {
            $(currentObject).parents('.article-view-more-wrap').show();
        } else {
            $(currentObject).parents('.article-view-more-wrap').show();
        }
    }
    dynamicHeightUpdateForCards();
}

function hideViewMoreLink(value, currentObject) {
    var hideviewmore = "";
    if (undefined != value && value == 'desktop') {
        hideviewmore = $(currentObject).parents('.filter-bg-color.fullwidth').siblings('.article-grid-listing-panel').find(".article-list-grid").find(".hideThis")
    } else if (undefined != value && value == 'mobile') {
        hideviewmore = $(currentObject).parents('.filter-bg-color.fullwidth').siblings('.article-grid-listing-panel').find(".article-list-gallery").find(".hideThis");

    }

    if (undefined != hideviewmore && hideviewmore.length == 0) {
        if (value == 'desktop') {
            $(currentObject).parents('.article-list-with-filter').find('.article-view-more-wrap').hide();
        } else {
            $(currentObject).parents('.article-list-with-filter').find('.article-view-more-wrap').hide();
        }
    } else {
        if (value == 'desktop') {
            $(currentObject).parents('.article-list-with-filter').find('.article-view-more-wrap').show();
        } else {
            $(currentObject).parents('.article-list-with-filter').find('.article-view-more-wrap').show();
        }
    }
    dynamicHeightUpdateForCards();
}

function checkViewMore(value) {
	var hidde = "";
	if (undefined != value && value == 'desktop') {
		hidde = $(".article-list-grid").find(".hideThis");
	} else if (undefined != value && value == 'mobile') {
		hidde = $(".article-list-gallery").find(".hideThis");

	}

	if (undefined != hidde && hidde.length == 0) {
		if (value == 'desktop') {
			$(".article-view-more-wrap.desktop").hide();
			$(".article-view-more-wrap.desktop.showAllChecked").hide();
		} else {
			$(".article-view-more-wrap.mobile").hide();
			$(".article-view-more-wrap.mobile.showAllChecked").hide();
		}
	} else {
		if (value == 'desktop') {
			$(".article-view-more-wrap.desktop").show();
			$(".article-view-more-wrap.desktop.showAllChecked").hide();
		} else {
			$(".article-view-more-wrap.mobile").show();
			$(".article-view-more-wrap.mobile.showAllChecked").hide();
		}
	}
	dynamicHeightUpdateForCards();
}

function displayArticles(data)
{
    if(undefined!=data && data.length>0){
          for(var i=0;i<6;i++)
              {
                  $(data[i]).show();
                  $(data[i]).removeClass("hideThis");
                  $(data[i]).addClass("showThis");

              }
        }

}
$(document).ready(function(){
 if ($('.article-list-with-filter').length){
	$(".article-filter-group .article-dropdown.dropdown-menu li a").click(function() {
	    var listingShowFilter = $("input[name=listingShowFilter]").val();
        if(listingShowFilter == 'newsListing'){
            $(this).parents(".custom-dropdown").find('.tablet-fix').html(' <span class="event-option-selected ">' +
            $(this).text() + '</span><span class="icon-arrow-down  pull-right"> </span><span class="bottom-line filter-line-margin"></span>');
        }
        else {
            $(this).parents(".custom-dropdown").find('.tablet-fix').html(' <span class="event-option-selected ">' +
            $(this).text() + '</span><span class="icon-arrow-down  pull-right"> </span><span class="bottom-line"></span>');
        }
        $(this).parents(".custom-dropdown").find('.tablet-fix').val($(this).data('value')).addClass('drop-val');
    });

	var articleSelectedOption;
	$(".article-dropdown.dropdown-menu >li >a").on('click',function(evt){
		articleSelectedOption = $(this).html();
		$(this).parent().parent(".article-filter-selection").find('.article-option-selected').html(articleSelectedOption);
		$('.article-dropdown.dropdown-menu >li >a').removeClass('selected-option-style2');
		articleSelectedOption ="";
		var themeOption=$("input[name=themeDropDown]").val();
		var sortOption =$("input[name=sortDropDown]").val();
		var monthOption =$(this).parents(".article-filter-group").find("input[name=monthDropDown]").val();
		var yearOption =$(this).parents(".article-filter-group").find("input[name=yearDropDown]").val();
		var selectedSort=$(this).parent().parent().parent().find("input[name=dropdownName]").val();
		var sortValue=$(this).attr("data-id");
		if(undefined!=selectedSort && selectedSort=='theme'){
			$(this).parent().parent().parent().find("input[name=themeDropDown]").val(sortValue);
		}else if(undefined!=selectedSort && selectedSort=='sort'){
			$(this).parent().parent().parent().find("input[name=sortDropDown]").val(sortValue);
		}else if(undefined!=selectedSort && selectedSort=='month'){
			$(this).parent().parent().parent().find("input[name=monthDropDown]").val(sortValue);
		}else if(undefined!=selectedSort && selectedSort=='year'){
			$(this).parent().parent().parent().find("input[name=yearDropDown]").val(sortValue);
		}
		sortData(selectedSort,sortValue,themeOption,sortOption,yearOption,monthOption,$(this));
	});

    /* Search button ajax call */
    $('.article-search-box').on('click', function() {
        var searchKeyword = $(this).parents(".search-news-filters").find('.drop-val').val();
        var listingRootPath = $('#listing-root-path').val();
        var listingContentPath = $('#listing-content-type').val();
        var listingAuthorFilter = $('#listing-author-filter').val();
        var listingApplyTag = $('#listing-apply-tag').val();
        var $thisEvent = $(this);


        $.ajax({
            url: '/bin/sparklabs/articlelistingcarousal.json',
            data: "searchKeyword="+ searchKeyword  + "&listingContentPath="+listingContentPath + "&listingAuthorFilter="+ listingAuthorFilter + "&listingApplyTag="+ listingApplyTag + "&listingRootPath="+listingRootPath ,
            dataType: 'json',
            type: "GET",
            contentType: "application/json;charset=utf-8",

            success: function(returnData) {
                renderResponce(returnData, $thisEvent);

	        },
            error: function(xhr, ajaxOptions, thrownError) {

            },
            complete: function() {

            }
        });
    }); 
  }
});
if ($('.article-list-with-filter').length){
var sortData = function(selectedSort, sortValue,themeOption, sortOption, yearOption, monthOption, currentObject) {
    var newArray = "";
    var articleJson = $("input[name=articleJson]").val();
    var toDisplay = $("input[name=toDisplay]").val();
    var articleArray = JSON.parse(articleJson);
    var arraytoSort = "";
    if (undefined != articleArray) {
        arraytoSort = articleArray[toDisplay];
    }

    if (undefined != arraytoSort && arraytoSort.length > 0) {
        if (undefined != selectedSort && selectedSort == 'theme') {
			if(undefined != sortOption && "" !== sortOption)
            {
               newArray = getArticleBySort(sortOption, arraytoSort)
            }else{
                newArray=arraytoSort;
            }
            newArray = getArticleByTheme(sortValue, newArray);
            renderArticleListMobile(newArray, currentObject);
            renderArticleListDesktop(newArray, currentObject);

        } else if (undefined != selectedSort && selectedSort == 'sort') {
			if(undefined != themeOption && "" !== themeOption)
            {
               newArray = getArticleByTheme(themeOption, arraytoSort)
            }else{
                newArray=arraytoSort;
            }
            newArray = getArticleBySort(sortValue, newArray);            
            renderArticleListMobile(newArray, currentObject);
            renderArticleListDesktop(newArray, currentObject);
        } else if (undefined != selectedSort && selectedSort == 'year') {
			if(undefined != monthOption && "" !== monthOption)
            {
               newArray = getArticleByMonth(monthOption, arraytoSort)
            }else{
                newArray=arraytoSort;
            }
            newArray = getArticleByYear(sortValue, newArray);            
            renderArticleListMobile(newArray, currentObject);
            renderArticleListDesktop(newArray, currentObject);
        } else if (undefined != selectedSort && selectedSort == 'month') {
			if(undefined != yearOption && "" !== yearOption)
            {
               newArray = getArticleByYear(yearOption, arraytoSort)
            }else{
                newArray=arraytoSort;
            }
            newArray = getArticleByMonth(sortValue, newArray);            
            renderArticleListMobile(newArray, currentObject);
            renderArticleListDesktop(newArray, currentObject);
        }
		
    }

};

var getArticleByTheme = function(sortBy, array) {
    var newArray = new Array(array.length);
    if (undefined != sortBy && array.length > 0 && sortBy != 'All') {
        var count = 0;
        for (var i = 0; i < array.length; i++) {
            if (undefined != array[i]) {

                var isAvailable = false;

                var sparkPage = array[i];
                var themes = sparkPage.contentThemes;
                if (undefined != themes && themes.length > 0) {
                    for (var k = 0; k < themes.length; k++) {

                        if (undefined != themes[k]) {

                            var theme = themes[k];
                            if (undefined != theme.contentTheme && theme.contentTheme == sortBy) {
                                isAvailable = true;
                                break;
                            } else {
                                continue;
                            }

                        }

                    }
                }

                if (isAvailable == true) {
                    newArray[count] = array[i];
                    count++;
                }

            }

        }

    } else if (sortBy == 'All') {
        return array;
    }
    return newArray;
};



var getArticleBySort = function(sortBy, array) {
    
    if (undefined != sortBy && sortBy == '1') {

        array = getArrayWithDate(array, sortBy);

    } else if (undefined != sortBy && sortBy == '2') {
        array = getArrayWithDate(array, sortBy);
    } else if (undefined != sortBy && sortBy == '3') {
        array.sort(sort3);
    } else {
        array.sort(sort4);
    }

    return array;
};

var renderResponce = function(data, currentObject) {
var toDisplay = $("input[name=toDisplay]").val();
	var articleArray = JSON.parse(data);
	var arraytoSort = "";
    if (undefined != articleArray) {
        arraytoSort = articleArray[toDisplay];
    }
	renderArticleListDesktop(arraytoSort, $(currentObject));
	renderArticleListMobile(arraytoSort, $(currentObject));
};

var getArticleByYear = function(yearBy, array) {
    var finalArray = new Array();

    if (undefined != array && array.length > 0) {
        var arrayWithYear = new Array();
        var count = 0;
        if (yearBy == 'Year'){
            finalArray = array;
        } else {
	        for (var i = 0; i < array.length; i++) {
	            if (undefined != array[i]) {
	                var sparkPage = array[i];
	                var contentDate = sparkPage.contentDate;
	                if(undefined != contentDate ||  null != contentDate){
	                    var contentDateArray = contentDate.split(" ") ;
	                    var year = contentDateArray.length == 3 ? contentDateArray[2] : "";	
	                    if (undefined != year && year == yearBy) {
	                        arrayWithYear[count] = sparkPage;
	                        count++;
	                    }
	                }
	            }
	        }
	        finalArray = arrayWithYear;
        }
    }

    return finalArray;
};

var getArticleByMonth = function(monthBy, array) {     
    if (undefined != monthBy && monthBy == '0') {
		monthBy = 'January';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '1') {
		monthBy = 'February';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '2') {
		monthBy = 'March';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '3') {
		monthBy = 'April';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '4') {
		monthBy = 'May';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '5') {
		monthBy = 'June';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '6') {
		monthBy = 'July';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '7') {
		monthBy = 'August';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '8') {
		monthBy = 'September';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '9') {
		monthBy = 'October';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '10') {
		monthBy = 'November';
        array = getArrayWithMonth(array, monthBy);
    } else if (undefined != monthBy && monthBy == '11'){
		monthBy = 'December';
	    array = getArrayWithMonth(array, monthBy);
	}

    return array;
};

var sortArticle2 = function(a, b) {

    if (a.ageInMinutes < b.ageInMinutes)
        return -1;
    if (a.ageInMinutes > b.ageInMinutes)
        return 1;
    return 0;



};

var sortArticle1 = function(a, b) {
    if (a.ageInMinutes > b.ageInMinutes)
        return -1;
    if (a.ageInMinutes < b.ageInMinutes)
        return 1;
    return 0;
};



var renderArticleListDesktop = function(articleArray, currentObject) {

    var articleGrid = $('.article-list-grid');
    var listingShowAuthor = $("input[name=listingShowAuthor]").val();
    var listingShowDate = $("input[name=listingShowDate]").val();
    var listingShowCategory = $("input[name=listingShowCategory]").val();
    var listingShowDescription = $("input[name=listingShowDescription]").val();
    var listingShowAll = $("input[name=listingShowAll]").val();
    var listingShowFilter = $("input[name=listingShowFilter]").val();
    
    if(undefined != listingShowFilter && listingShowFilter == 'newsListing') {
        articleGrid = $(currentObject).parents('.filter-bg-color.fullwidth').siblings('.article-grid-listing-panel').find('.article-list-grid');
    }

    if (undefined != articleArray && articleArray.length > 0) {

        var newArticleGrid = "";
        for (var i = 0; i < articleArray.length; i++) {
            if (undefined != articleArray[i]) {
                var sparkPage = articleArray[i];

                var dateHtml = "";
                if (undefined != listingShowDate && listingShowDate == 'true') {
                    dateHtml = getDateHtml(sparkPage);
                }
                
                var categoryHtml = "";
                if (undefined != listingShowCategory && listingShowCategory == 'true') {
                	categoryHtml = getContentThemeCategory(sparkPage);
                }

                var authorHtml = "";
                if (undefined != listingShowAuthor && listingShowAuthor == 'true') {
                    authorHtml = getAuthorHtml(sparkPage);
                }

				var DescriptionHtml = "";
                if (undefined != listingShowDescription && listingShowDescription == 'true') {
                	DescriptionHtml = getDescriptionHtml(sparkPage);
                }
				
                var videoPlayHtml = "";
                var showVideoPlayImage = sparkPage.showVideoPlayImage;

                if (undefined != showVideoPlayImage && showVideoPlayImage == 'true') {
                    videoPlayHtml = getVideoPlayHtml(sparkPage, i);
                }
                
                var slideShareHtml = "";
                var showSlideShareImage = sparkPage.showSlideShareImage;
                if (undefined != showSlideShareImage && showSlideShareImage == 'true') {
                	slideShareHtml = getSlideShareHtml(sparkPage, i);
                }

                if(undefined != listingShowAll && listingShowAll == 'true'){
                    newArticleGrid += '<div class="col-xs-3 col-sm-4 col-lg-4 ' + 'showThis' + '" style="display:' + 'block' + ';">'
                            + '<div class="article-list-panel"><div class="ref-article-media pos-rel">' + categoryHtml + '<a href="' + sparkPage.pageLink + '"> <img src="'
                            + (sparkPage.pageDefaultImage) + '" alt="' + (sparkPage.pageDefaultImageAltText) + '" class="img-responsive"></a> ' + videoPlayHtml
                            + slideShareHtml + '</div>' + '<div class="article-theme"><div class="ref-article-title">' + '<h4><a href="' + sparkPage.pageLink
                            + '"> ' + (sparkPage.pageTitle != undefined ? sparkPage.pageTitle : '') + '</a></h4>'
                            + DescriptionHtml + dateHtml + authorHtml
                            + '<div class="clearfix"></div></div></div></div></div>';
                } else{
	                newArticleGrid += '<div class="col-xs-3 col-sm-4 col-lg-4 ' + (i + 1 > 6 ? 'hideThis' : 'showThis') + '" style="display:' + (i + 1 > 6 ? 'none' : 'block') + ';">' +
	                    '<div class="article-list-panel"><div class="ref-article-media pos-rel">' + categoryHtml +
	                    '<a href="' + sparkPage.pageLink + '"> <img src="' + (sparkPage.pageDefaultImage) + '" alt="' + (sparkPage.pageDefaultImageAltText) + '" class="img-responsive"></a> ' + videoPlayHtml + slideShareHtml + '</div>' +
	                    '<div class="article-theme"><div class="ref-article-title">' +
	                    '<h4><a href="' + sparkPage.pageLink + '"> ' + (sparkPage.pageTitle != undefined ? sparkPage.pageTitle : '') + '</a></h4>' + DescriptionHtml +
	                    dateHtml + authorHtml + '<div class="clearfix"></div></div></div></div></div>';
	                }
            }
        }
        articleGrid.html('');        
        $(currentObject).parents('.filter-bg-color.fullwidth').siblings('.article-grid-listing-panel').find('.article-list-empty').hide();      
        articleGrid.html(newArticleGrid);
        dynamicHeightUpdateForCards();
        if(undefined != listingShowFilter && listingShowFilter == 'newsListing') {
            hideViewMoreLink("desktop", currentObject);
        } else {
            checkViewMore("desktop");
        }

    } else{
        articleGrid.html('');
        $(currentObject).parents('.filter-bg-color.fullwidth').siblings('.article-grid-listing-panel').find('.article-list-empty').show();
        if(undefined != listingShowFilter && listingShowFilter == 'newsListing') {
            hideViewMoreLink("desktop", currentObject);
        } else {
            checkViewMore("desktop");
        }
    }
};

var renderArticleListMobile = function(articleArray, currentObject) {

    var articleGrid = $('.article-list-gallery');
    var listingShowAuthor = $("input[name=listingShowAuthor]").val();
    var listingShowDate = $("input[name=listingShowDate]").val();
    var listingShowCategory = $("input[name=listingShowCategory]").val();
    var listingShowDescription = $("input[name=listingShowDescription]").val();
    var listingShowAll = $("input[name=listingShowAll]").val();
    var listingShowFilter = $("input[name=listingShowFilter]").val();
    
    if(undefined != listingShowFilter && listingShowFilter == 'newsListing') {
        articleGrid = $(currentObject).parents('.filter-bg-color.fullwidth').siblings('.article-grid-listing-panel').find('.article-list-gallery');
    }

    if (undefined != articleArray && articleArray.length > 0) {

        var newArticleGrid = "";
        for (var i = 0; i < articleArray.length; i++) {
            if (undefined != articleArray[i]) {
                var sparkPage = articleArray[i];

                var dateHtml = "";
                if (undefined != listingShowDate && listingShowDate == 'true') {
                    dateHtml = getDateHtml(sparkPage);
                }
                
                var categoryHtml = "";
                if (undefined != listingShowCategory && listingShowCategory == 'true') {
                	categoryHtml = getContentThemeCategory(sparkPage);
                }

                var authorHtml = "";
                if (undefined != listingShowAuthor && listingShowAuthor == 'true') {
                    authorHtml = getAuthorHtml(sparkPage);
                }
				
                var DescriptionHtml = "";
                if (undefined != listingShowDescription && listingShowDescription == 'true') {
                	DescriptionHtml = getDescriptionHtml(sparkPage);
                }
				
                var videoPlayHtml = "";
                var showVideoPlayImage = sparkPage.showVideoPlayImage;
                if (undefined != showVideoPlayImage && showVideoPlayImage == 'true') {
                    videoPlayHtml = getVideoPlayHtml(sparkPage, i);
                }
                
                var slideShareHtml = "";
                var showSlideShareImage = sparkPage.showSlideShareImage;
                if (undefined != showSlideShareImage && showSlideShareImage == 'true') {
                	slideShareHtml = getSlideShareHtml(sparkPage, i);
                }

                if(undefined != listingShowAll && listingShowAll == 'true'){
                    newArticleGrid += '<div class="related-content-column ' + 'showThis' + '" style="display:' + 'block' + ';">'
                            + '<div class="article-list-panel-device"><div class="ref-article-media pos-rel">' + categoryHtml + '<a href="' + sparkPage.pageLink
                            + '"> <img src="' + (sparkPage.pageDefaultImage) + '" alt="' + (sparkPage.pageDefaultImageAltText)
                            + '" class="img-responsive"></a>' + videoPlayHtml + slideShareHtml + '</div>'
                            + '<div class="article-theme"><div class="ref-article-title">' + '<h4><a href="' + sparkPage.pageLink + '"> '
                            + (sparkPage.pageTitle != undefined ? sparkPage.pageTitle : '') + '</a></h4>' + DescriptionHtml + dateHtml + authorHtml
                            + '</div></div><div class="clearfix"></div></div></div>';
                } else {
	                newArticleGrid += '<div class="related-content-column ' + (i + 1 > 6 ? 'hideThis' : 'showThis') + '" style="display:' + (i + 1 > 6 ? 'none' : 'block') + ';">' +
	                    '<div class="article-list-panel-device"><div class="ref-article-media pos-rel">' + categoryHtml +
	                    '<a href="' + sparkPage.pageLink + '"> <img src="' + (sparkPage.pageDefaultImage) + '" alt="' + (sparkPage.pageDefaultImageAltText) + '" class="img-responsive"></a>' + videoPlayHtml + slideShareHtml + '</div>' +
	                    '<div class="article-theme"><div class="ref-article-title">' +
	                    '<h4><a href="' + sparkPage.pageLink + '"> ' + (sparkPage.pageTitle != undefined ? sparkPage.pageTitle : '') + '</a></h4>' +DescriptionHtml+
	                    dateHtml + authorHtml + '</div></div><div class="clearfix"></div></div></div>';
	                }
            }
        }
        articleGrid.html('');        
        $(currentObject).parents('.filter-bg-color.fullwidth').siblings('.article-grid-listing-panel').find('.article-list-gallery-empty').hide();
        articleGrid.html(newArticleGrid);
        dynamicHeightUpdateForCards();
        if(undefined != listingShowFilter && listingShowFilter == 'newsListing') {
            hideViewMoreLink("mobile", currentObject);
        } else {
            checkViewMore("mobile");
        }

    } else {
        articleGrid.html('');
        $(currentObject).parents('.filter-bg-color.fullwidth').siblings('.article-grid-listing-panel').find('.article-list-gallery-empty').show();
        if(undefined != listingShowFilter && listingShowFilter == 'newsListing') {
            hideViewMoreLink("mobile", currentObject);
        } else {
            checkViewMore("mobile");
        }
    }
};

var getThemes = function(themes) {
    var themehtml = "";
    if (undefined != themes && themes.length > 0) {

        for (var i = 0; i < themes.length; i++) {
            if (undefined != themes[i]) {

                var theme = themes[i];
                var thisHtml = "";
                thisHtml = '<a href="' + theme.contentThemeLink + '">' +
                    theme.contentTheme + '</a>'
                themehtml += thisHtml + (i + 1 < themes.length ? ' , ' : '');

            }

        }

    }
    return themehtml;
};

var getDateHtml = function(sparkPage) {
    var dateHtml = '<label>' + (undefined != sparkPage.contentDate ? 'Posted on ' + sparkPage.contentDate : '') + '</label>';
    return dateHtml;
};

var getContentThemeCategory = function(sparkPage) {
        var contentTheme = "";
        if (undefined !== sparkPage.contentThemes[0]) {
            contentTheme = '<span class="article-cat-tag">' + (sparkPage.contentThemes[0].contentTheme) + '</span>';
        }
        return contentTheme;
    };
}

var getAuthorHtml = function(sparkPage) {
    var html = "";
    if (undefined != sparkPage.authorName) {
        html = '<div><span> By </span><a href="' + sparkPage.authorPageLink + '">' + (undefined != sparkPage.authorName ? sparkPage.authorName : '') + '</a></div>';
    }

    return html;
};

var getVideoPlayHtml = function(sparkPage, i) {
    var html = "";

    html = '<a href="'+sparkPage.pageLink+'" class="article-video-play-small"> <span class="icon-video-play"> </span> </a> ';

    if (undefined != sparkPage.pageVideoDuration) {
        html += '<label class="article-video-time list-video-time">' + sparkPage.pageVideoDuration + '</label>';
    }

    return html;
};

var getSlideShareHtml = function(sparkPage, i) {
    var html = "";
    html = '<a href="'+sparkPage.pageLink+'" class="article-video-play-small"> <span class="icon-slide-share-f"> </span> </a> ';
    return html;
};
var getDescriptionHtml = function(sparkPage) {
    var html = "";
    if (undefined != sparkPage.pageDescription) {
     html = '<p>'+sparkPage.pageDescription+'</p>';
    }
    return html;
};
var getArrayWithDate = function(array, sortBy) {
    var finalArray = new Array();

    if (undefined != array && array.length > 0) {
        var arrayWithDate = new Array();
        var count1 = 0;
        var arrayWithoutDate = new Array();
        var count2 = 0;

        for (var i = 0; i < array.length; i++) {
            if (undefined != array[i]) {
                var sparkPage = array[i];
                var contentDate = sparkPage.contentDate;
                if (undefined != contentDate) {
                    arrayWithDate[count1] = sparkPage;
                    count1++;
                } else {
                    arrayWithoutDate[count2] = sparkPage;
                    count2++;
                }
            }
        }

        if (undefined != sortBy && sortBy == '1') {
            arrayWithDate.sort(sortArticle1);
        } else {
            arrayWithDate.sort(sortArticle2);
        }

        arrayWithDate.push.apply(arrayWithDate, arrayWithoutDate);
        finalArray = arrayWithDate;

    }

    return finalArray;
};

var getArrayWithMonth = function(array, monthBy) {
    var finalArray = new Array();

    if (undefined != array && array.length > 0) {
        var arrayWithMonth = new Array();
        var count = 0;
       
        for (var i = 0; i < array.length; i++) {
            if (undefined != array[i]) {
                var sparkPage = array[i];
                var contentDate = sparkPage.contentDate;
				if(undefined != contentDate ||  null != contentDate){
					/* sample content date format: 14 December 2018 */
					var contentDateArray = contentDate.split(" ") ;
                    var month = contentDateArray.length == 3 ? contentDateArray[1] : "";
                    if (undefined != month && month === monthBy) {
                        arrayWithMonth[count] = sparkPage;
                        count++;
                    }
                }
            }
        }
        finalArray = arrayWithMonth;
    }
    return finalArray;
};

$(document).ready(function () {
	"use strict";
	$(document).on("dialog-ready" ,function(e) {
		// Show the tab which is selected in the drop down, whenever the dialog is opened.
		showHideTabs($(".articleAndEventHeroPanelContentType button"));
		
		//On click of any value from the drop down, show the corresponding tab in the dialog.
		$(".articleAndEventHeroPanelContentType ul li").on("click", function(){
			showHideTabs($(this));
		});
	});

	// This function shows the respective tab and hides others
	function showHideTabs(tab){
		var tabText = tab.text().trim().toLowerCase();
		$('.article-event-hero-panel-dialog nav a:gt(0)').each(function(){
			if(($(this).text().trim().toLowerCase()).indexOf(tabText) >= 0){
				$(this).show();
			}else{
				$(this).hide();
			}
		});
	}

});
$(document).ready(function () {

	var mq2 = window.matchMedia( "(min-width: 940px)" );
	if($("#articleSocialWrap").length){
		var scrollPos = $("#articleSocialWrap").offset().top;
		$(window).scroll(function() {
			if (mq2.matches) {
				if( ($(window).scrollTop() > scrollPos) ){
					$("#articleSocialWrap").addClass('scroll-sticky');
                    var el = $(".article-banner-wrap img");
                 	var articleOffset = el.offset();
					var elPosLeft = el.width() + articleOffset.left;
                    $('.article-social-base.scroll-sticky').css({'margin-left':elPosLeft, 'left':'109px'});
				} else {
					$("#articleSocialWrap").removeClass('scroll-sticky');
                    $('.article-social-base').css({'margin-left':'97px','left':'100%'}); 
				}
			}
		});
	}

	$(".article-banner-wrap .video-play").on('click', function(){
		var iframeSrc = $(this).siblings('.video-placeholder').find('iframe');
		$(this).hide();
		$(this).siblings('img').hide();
		$(this).siblings('.video-time').hide();
		$(iframeSrc).attr("src",$(iframeSrc).attr('data-video-src') + "?&autoplay=1");
		$(this).siblings('.video-placeholder').show();
	});

	// Facebook, LinkedIn and Twitter share.	
	if($('#articleSocialWrap').length){
		$('.article-social-box a').on("click", function(){
			socialMediaShareLinks($(this));
		});
	}

	if(! $('.article-banner-wrap img').length){
		$('.article-top-section').addClass('article-banner-space-fix');
	}

	var articleTabletMin = window.matchMedia( "(min-width: 640px)" );
    var articleTabletMax = window.matchMedia( "(max-width: 939px)" );
	if (articleTabletMin.matches) {
       	if (articleTabletMax.matches) {

            if(	($('.event-list-with-filter').length) || ($(".event-speakers-register").length)){
				$('.article-top-section').parent().parent().parent().addClass('lab-event-tablet-fix');
            }
			if(	(!$('.event-list-with-filter').length) && (!$(".event-speakers-register").length)){
                $('.article-top-section').parent().parent().parent().addClass('lab-article-tablet-fix');
            }
        }
    }
	
	var articleMQ = window.matchMedia( "(max-width: 639px)" );
	if (articleMQ.matches) {
            if(	($('.event-list-with-filter').length) || ($(".event-speakers-register").length)){
				$('.article-top-section').parent().parent().parent().addClass('lab-event-mobile-fix');
            }
			if(	(!$('.event-list-with-filter').length) && (!$(".event-speakers-register").length)){
                $('.article-top-section').parent().parent().parent().addClass('lab-article-mobile-fix');
            }
	}
	
	$(window).load(function() {
		// All views top section dynamic height.
		var articleTitleRowHeight = 0;
		$('.article-top-box > .row').each(function(){
			if($(this).find('.article-title').length || $(this).find('.article-info').length){
				articleTitleRowHeight = articleTitleRowHeight + $(this).height();
			}else if($(this).find('.article-banner-wrap')){
				var calHeight = $(this).find('.article-banner-wrap').height();
				articleTitleRowHeight = articleTitleRowHeight + calHeight/2;
			}
		});
		// Add top margin pixel.
		var articleHeroHeight = articleTitleRowHeight + 60;
		$('.article-top-panel').height(articleHeroHeight);

	});

});

function socialMediaShareLinks(clickedSocialMedia){

	var shareArticleModalWidth =  600;
	var shareArticleModalHeight = 400;
	var shareArticleModalLeft = (screen.width - shareArticleModalWidth)/2;
	var shareArticleModalTop = (screen.height - shareArticleModalHeight)/2;
	var articlePosition = 'width='+shareArticleModalWidth+', height='+shareArticleModalHeight+', top='+shareArticleModalTop+', left='+shareArticleModalLeft;

	var currentPageUrl = window.location.href;
	var pageUrl = "";

	var platform = clickedSocialMedia.data('platform')
	if (platform == 'twitter') {
		window.open('https://twitter.com/intent/tweet?url=' + currentPageUrl + pageUrl, 'sharer', articlePosition);
	} else if (platform == 'facebook') {
		window.open('https://www.facebook.com/sharer/sharer.php?u='+ currentPageUrl + pageUrl, 'sharer', articlePosition);
	} else if (platform == 'linkedin') {
		window.open('http://www.linkedin.com/shareArticle?mini=true&url=' + currentPageUrl + pageUrl, 'sharer', articlePosition);
	}
}
var accordionContainerId = "";
var accordionContainer = $(".one-spark-accordion-container");
var accordionEntry = $(".one-spark-accordion-entry");

// Sets unique id to the accordion container
accordionContainer.each(function(index) {
  $(this).attr("id", "spark-lab-accordion" + index);
});

// Gets the accordion container(parent) id and pushes it to its child accordion
// entry.
accordionEntry.each(function(index) {
  accordionContainerId = $(this)
    .parents(".one-spark-accordion-container")
    .attr("id");
  $(this)
    .find(".accordian-link")
    .attr("data-parent", "#" + accordionContainerId);

  if (
    $(this)
      .find(".panel-collapse")
      .attr("id") === undefined
  ) {
    $(this)
      .find(".accordian-link")
      .attr("href", "#" + accordionContainerId + index);
    $(this)
      .find(".panel-collapse")
      .attr("id", accordionContainerId + index);
  }
});

$(document).ready(function() {
    //search expand
    $(".search-hideshow").click(function(){
        $( ".main-head" ).toggleClass( "active-search" );
       $( ".active-search .search-input" ).val("");
        $( ".active-search .search-input" ).focus();
        $(".search").removeClass('active');
   });
    //hamburger
    $('.icon-hamburger').click(function(){
        $(this).toggleClass('open');
        $(".main-head").toggleClass("hamb-open");
        $('div.circle').toggleClass('expand');
        $('.site-menubar > ul > li').toggleClass('animate');
        $("body").toggleClass("overflowx");
        $( ".nav-list li.animate a" ).each(function(){
        	if($(this).parent().find(".subnav-list").length==0){
        		$(this).unbind("click");
        	}
        });
        //removed z-index for icon tab container in patter library component, as this js is used there for header
        $('nav#myNavbar2').css('z-index', '');
    });
    onClickLogin();
    onClickHeaderNavigation();
});

$(window).resize(function() {
	fnLoadTopHeaders();
	onClickLogin();
	onClickHeaderNavigation();
});

function fnLoadTopHeaders(){
	if ($(window).width() >= 939) {
		setTimeout(
			function(){
				for(i=0;i<$('.subnav-list').length;i++){
					$('#sublist-'+(i+1)+' .subnav-list-type1').height(0);
				}
				var i=0;
				for(i=0;i<$('.subnav-list').length;i++){
					var maxheight = [];
					maxheight = [];
					$('#sublist-'+(i+1)+' .subnav-list-type2').each(function(){
						maxheight.push($(this).height());
					});
					$('#sublist-'+(i+1)+' .subnav-list-type2').each(function(){
						$('#sublist-'+(i+1)+' .subnav-list-type2').height(Math.max.apply(Math,maxheight));
					});
					if($('#sublist-'+(i+1)+' .subnav-list-type2 p').length == 0){
						$('#sublist-'+(i+1)+' .subnav-list-type2').css({
						  'min-height':'400px'
						});
					}
				}
				for(var i=0;i<$('.subnav-list').length;i++){
					var k=1 , tempArrayHeight =[], arrayIndex = [], arrayEmptyData=[];
					for(var j=0;j<$('#sublist-'+(i+1)+' .subnav-list-type1').length;j++){
						if($('#sublist-'+(i+1)+' .subnav-list-type1')[j].getElementsByTagName('ul').length == 0){
							arrayEmptyData.push(j)
						}
						arrayIndex.push(j);
						if(k%4 !=0){
							tempArrayHeight.push($('#sublist-'+(i+1)+' .subnav-list-type1').eq(j).parent().height());
							for(var a=0;a<arrayIndex.length;a++){
								$('#sublist-'+(i+1)+' .subnav-list-type1')[arrayIndex[a]].style.height = (Math.max.apply(Math,tempArrayHeight))+'px';
							}
						}
						if(k%4 == 0){
							tempArrayHeight.push($('#sublist-'+(i+1)+' .subnav-list-type1').eq(j).parent().height());
							for(var a=0;a<arrayIndex.length;a++){
								$('#sublist-'+(i+1)+' .subnav-list-type1')[arrayIndex[a]].style.height = (Math.max.apply(Math,tempArrayHeight))+'px';
							}
							tempArrayHeight =[];
							arrayIndex= [];
						}
						for(var a=0;a<arrayEmptyData.length;a++){
							$('#sublist-'+(i+1)+' .subnav-list-type1')[arrayEmptyData[a]].style["border-bottom"]='0';
						}
						k++;
					}
				}
				
				for(var i=0;i<$('.subnav-list').length;i++){
					var k=1;
					for(var j=0;j<$('#sublist-'+(i+1)+' .subnav-list-type2').length;j++){
						if($('#sublist-'+(i+1)+' .subnav-list-type2')[j].getElementsByTagName('p').length == 0){ 
							if(k%3 != 0){
								$('#sublist-'+(i+1)+' .subnav-list-type2')[j].style["height"]='375px';
							}
						}
						k++;
					}
				}
			},500);
	}else{
		for(i=0;i<$('.subnav-list').length;i++){
			$('#sublist-'+(i+1)+' .subnav-list-type1').css('height', '');
			$('#sublist-'+(i+1)+' .subnav-list-type2').css('height', '');
		}
	}
}

$(function(){
	$("#headersearchautoq").keyup(function(event){
	    if(event.keyCode == 13 && $(this).val() != null){
	    	$("#searchString").val($(this).val());
	    	//$('#headersite-search').submit();
	    	$('#hidden-auto-suggest-form').submit();
	    }
	});
	
    function highlightAutoComplete() {
        $.ui.autocomplete.prototype._renderItem = function(ul, item) {
            var re = new RegExp("^" + this.term, "i") ;
            var t = item.label.replace(re,"<b style='color: #000000;'>" + this.term + "</b>");
            return $("<li></li>")
            .data("item.autocomplete", item)
            .append("<a>" + t + "</a>")
            .appendTo(ul);
        };
    }
    
    $(function() {
        highlightAutoComplete();
        var autoSuggestUrl = $( '#autoSuggestURl' ).val();
        $("#headersearchautoq").autocomplete({
            source: function(request, response) {
                $.ajax({
                    url: autoSuggestUrl,
                    async: true,
                    dataType: 'jsonp',
                    data: {
                        q: request.term
                    },
                    success: function(data) {
                        response($.map(data.results, function(item) {
                            return {
                                label: item.name,
                                value: item.name
                            };
                        }));
                    }
                });
            },
			select: function(event, ui) {
				$("#headersearchautoq").val(ui.item.value);
				$("#searchString").val(ui.item.value);
				//$('#headersite-search').submit();
				$('#hidden-auto-suggest-form').submit();
			},			
            minLength: 1
        });
    });
    fnLoadTopHeaders();
});

$(window).on("load resize",function(e){
	//window load start
	if($(window).width() >= 940){
		if($(".nav-list").hasClass("ui-accordion")){
			$(".nav-list").accordion("destroy");
		}
	}
	if ($(window).width() <= 939) {
		$('.subnav-list-type2').css("min-height","100px");
		//login collapse expand
	   $(".login .dropdown-toggle").click(function(){ 
	        //$(this).toggleClass("dd-open");
	    });
        $( ".nav-list" ).accordion({
        	active: false,
            collapsible: true
        });
	}//window width check if loop
});//window load end

function onClickLogin(){
	if ($(window).width() > 939){
		$("div.login.dropdown").click(function(){
			$("a.dropdown-toggle").css({"border-bottom":"none","color":"#666666"}).blur();
			return false;
		});
		$("div.subnav-list.dropdown-menu").mouseover(function(){
			$("a.dropdown-toggle").css({"border-bottom":"1px solid #333","color":"#333"}).focus();
		});
		$("div.subnav-list.dropdown-menu").mouseout(function(){
			$("a.dropdown-toggle").css({"border-bottom":"none","color":"#666666"}).blur();
		});
	}
	$("a.dropdown-toggle").mouseover(function(){
		$("a.dropdown-toggle").css({"border-bottom":"1px solid #333","color":"#333"});
	});
	$("a.dropdown-toggle").mouseout(function(){
		$("a.dropdown-toggle").css({"border-bottom":"none","color":"#666666"});
	});
	$('div.subnav-list.dropdown-menu ul li').click(function(){
		window.location = $(this).find("a").attr("href"); 
		return false;
	});
	if($(window).width() <= 939){
		$("div.login.dropdown").unbind('click').click(); 
	}
}

function onClickHeaderNavigation(){
	if($(window).width() > 939){
		var arrayURL= $('#underlineurl').val(),arrayTitle= $('#underlineurlTitle').val(),spark_digital_url = $('#spark_digital_url').val(),spark_lab_url= $('#spark_lab_url').val(),pattern_library_url=$('#pattern_library_url').val();
		if( arrayURL !=undefined && arrayTitle !=undefined){
			arrayURL = arrayURL.split(",");
			arrayTitle = arrayTitle.split(",");
			for(var i=0;i<arrayURL.length;i++){
				arrayURL[i] = arrayURL[i].replace(spark_digital_url,"");
				arrayURL[i] = arrayURL[i].replace(spark_lab_url,"");
				arrayURL[i] = arrayURL[i].replace(pattern_library_url,"");
			}
			var findURL = [],findTitle = [],pathname = window.location.pathname;
			if((pathname == spark_digital_url ||pathname == spark_digital_url+".html" ) 
					|| (pathname == spark_lab_url ||pathname == spark_lab_url+".html" ) 
					|| (pathname == pattern_library_url ||pathname == pattern_library_url+".html")){
				//do nothing
			}else{
				var rem_digital_url = spark_digital_url.replace("/content",""),rem_lab_url = spark_lab_url.replace("/content",""), rem_pl_url = pattern_library_url.replace("/content","");
				//no underline for home page , exceptions when no /content
				pathname = pathname.replace(rem_digital_url,"");
				pathname = pathname.replace(rem_lab_url,"");
				pathname = pathname.replace(rem_pl_url,"");
				if((pathname.indexOf(rem_digital_url)!=-1 ||pathname.indexOf(rem_digital_url+".html")!=-1 ) 
						|| (pathname.indexOf(rem_lab_url)!=-1 ||pathname.indexOf(rem_lab_url+".html")!=-1 ) 
						|| (pathname.indexOf(rem_pl_url)!=-1 ||pathname.indexOf(rem_pl_url+".html")!=-1)){
					//do nothing
				}
				for(var i=0;i<arrayURL.length;i++){
					if(pathname.indexOf(arrayURL[i]) !=-1){
						findURL.push(arrayURL[i]);
						findTitle.push(arrayTitle[i]);
					}
				}
			}
			var checkflag =false;
			if(findURL.length >= 1){
				for(var i=0;i<findURL.length;i++){
					$('.site-menubar ul.nav-list >li >a').each(function(index){
						if(findURL[i] !=undefined){
							if( ($(this).attr('href').indexOf(findURL[i]) != -1) || ($(this).attr('href').indexOf(findURL[i]+".html") !=-1) || ($(this)[0].innerText.trim().toLowerCase() == findTitle[i].trim().toLowerCase())){
								$(this).addClass('header-underline');
								checkflag =true;
							}
						}
						if(checkflag == true){
							return true;
						}
					});
				}
			}
		}
	    $('.site-menubar ul.nav-list >li >a').each(function(){
	    	if((window.location.host.indexOf('sparklab.co.nz') != -1) || (window.location.host.indexOf('4502') != -1)|| (window.location.host.indexOf('4503') != -1)){
	    		if(window.location.pathname.indexOf('/videoarticles/') != -1){
	    			var flag=false;
	    			if( ($(this).attr('href').indexOf('/watch/') != -1) || ($(this).attr('href').indexOf("watch.html") !=-1)  || ($(this)[0].innerText.trim().toLowerCase() == "watch")){
	    				$(this).addClass('header-underline');
	    				flag=true;
	    			}
	    			if(flag==false){
	    				if($(this)[0].innerText.trim().toLowerCase() == "spark lab"){
		    				$(this).addClass('header-underline');
		    			}
	    			}
	    		}
	    		if(window.location.pathname.indexOf('/articles/') != -1){
	    			var flag=false;
	    			if( ($(this).attr('href').indexOf('/discover/') != -1) || ($(this).attr('href').indexOf("discover.html") !=-1) || ($(this)[0].innerText.trim().toLowerCase() == "discover")){
	    				$(this).addClass('header-underline');
	    				flag=true;
	    			}
	    			if(flag==false){
	    				if($(this)[0].innerText.trim().toLowerCase() == "spark lab"){
		    				$(this).addClass('header-underline');
		    			}
	    			}
	    		}
	    		if(window.location.pathname.indexOf('/events/') != -1){
	    			var flag=false;
	    			if( ($(this).attr('href').indexOf('/attend/') != -1) || ($(this).attr('href').indexOf("attend.html") !=-1) || ($(this)[0].innerText.trim().toLowerCase() == "attend")){
	    				$(this).addClass('header-underline');
	    				flag=true;
	    			}
	    			if(flag==false){
	    				if($(this)[0].innerText.trim().toLowerCase() == "spark lab"){
		    				$(this).addClass('header-underline');
		    			}
	    			}
	    		}
	    		if(window.location.pathname.indexOf('/discover') != -1){
	    			var flag=false;
	    			if( ($(this).attr('href').indexOf('/discover/') != -1) || ($(this).attr('href').indexOf("discover.html") !=-1) || ($(this)[0].innerText.trim().toLowerCase() == "discover")){
	    				$(this).addClass('header-underline');
	    				flag=true;
	    			}
	    			if(flag==false){
	    				if($(this)[0].innerText.trim().toLowerCase() == "spark lab"){
		    				$(this).addClass('header-underline');
		    			}
	    			}
	    		}
	    	}
	    	var pathName = window.location.pathname;
	        if(pathName == $(this).attr('href')){
	          $(this).addClass('header-underline');
	        }
	        if(pathName.indexOf("/solutions") !=-1){
	        	if( ($(this).attr('href').indexOf('/solutions/') != -1) || ($(this).attr('href').indexOf("solutions.html") !=-1) || ($(this)[0].innerText.trim().toLowerCase() == "solutions")){
    				$(this).addClass('header-underline');
    			}
	        }
    	});
    }
	
    if($(window).width() <= 939){
    	$('.site-menubar ul.nav-list >li >a').each(function(){
    		$(this).removeClass('header-underline');
    	});
    }
}
$(document).ready(function() {
    if ($(".cmp_bb_plan_cards").length) {
        const titleBlock = '.unplan-bb-card-title';
        const descBlock = '.unplan-bb-plan-desc';
        const plansBlock = '.unplan-bb-plan-include';
        const plansLegal = '.unplan-bb-plan-legal';
        $(window).on('load resize orientationchange', function() {
            if ($(this).width() > 639) {
                heightAlignment(titleBlock);
                heightAlignment(descBlock);
                heightAlignment(plansBlock);
                heightAlignment(plansLegal);
            } else {
                removeHeight(titleBlock);
                removeHeight(descBlock);
                removeHeight(plansBlock);
                removeHeight(plansLegal);
            }
        });
    }
});

function heightAlignment(blockClass) {
    var cardHeight = -1;
    $(blockClass).each(function() {
        cardHeight = Math.max($(this).height(), cardHeight);
    });

    $(blockClass).each(function() {
        $(this).height(cardHeight);
    });
}

function removeHeight(blockClass) {
    $(blockClass).removeAttr("style");
}
function createDataTable($this, index) {
    var dataTableJson = $this.find(".jsonFilePath").val();
    var headingJSON = $.parseJSON($this.find(".tableHeadingJson").val());
    var ctaLabel = $this.find(".ctaLabel").val();
    var cta = $this.find(".cta").val();
    var ctakey = 0;
    var headingRow = "";
    var columns = "";
    var colDefinition = [];
    var colDef = {};
    if (cta) {
        ctakey = $(headingJSON).length;
    }

    /* Creating Columns & ColumnDefinition */
    $(headingJSON).each(function(key, val) {
        var heading = val.heading;
        if (val.headingCaption !== "") {
            heading += "<code>" + val.headingCaption + "</code>";
        }
        var columnsValue = "";
        columnsValue += '"title" : "' + heading + '"';
        if (val.headingType === "dt-right") {
            columnsValue += ', "class" :"dt-right" ';
        }
        columns += "{" + columnsValue + "},";

        colDef = {
            targets : [ key ],
            createdCell : function(td, cellData, rowData, row, col) {
                $(td).prepend('<div class="mobileHead">' + val.heading + "<code>" + val.headingCaption + "</code>" + "</div>");
            }
        };

        colDefinition.push(colDef);
    });

    var columnctaheading = "";
    if (cta) {
        colDef = {
            targets : [ ctakey ],
            visible : false
        };
        colDefinition.push(colDef);
        columnctaheading = ',{"title":"CTA", "class" :""}, {"title":"&nbsp;", "class" :"dt-right cta-arrow"}';
    }

    headingRow = $.parseJSON("[" + columns.substr(0, columns.length - 1) + columnctaheading + "]");

    // New Json Data variable
    var items = [];

    // GetJson
    if (dataTableJson !== "") {
        if (!$this.find(".alert").hasClass("hidden")) {
            $this.find(".alert").addClass("hidden");
        }

        $.ajax({
            url : dataTableJson,
            type: 'GET',
            dataType : 'json',
            async : false,
            success : function(jd) {
                // Loop the Row Data
                $(jd.data).each(function(index, tableData) {
                    var itemsInside = [];

                    // Loop each cell
                    $(tableData).each(function(key, value) {
                        if (ctakey > 0 && key === ctakey) {
                            itemsInside.push(value);
                        } else {
                            // Convert each cell using showdown / markdown
                            // convertor
                            var converter = new showdown.Converter({
                                headerLevelStart : 1
                            }), html = converter.makeHtml(value);

                            // Replace <p> tag which are added by showdown
                            var htmlReplace = html.replace(/^<p>|<\/p>$/g, "");

                            // Replace quotes tag which are added by json
                            // convertor
                            // if there are commas or other symbol.
                            if (htmlReplace.charAt(0) === '"' && htmlReplace.charAt(htmlReplace.length - 1) === '"') {
                                htmlReplace = htmlReplace.slice(1, -1);
                            }

                            // Wrap content for responsiveness
                            var wrap = '<div class="cellContent">' + htmlReplace + "</div>";
                            itemsInside.push(wrap);
                        }
                    });

                    // Add New column arrow-right if there is a link in each
                    // row.
                    if (cta) {
                        itemsInside.push('<div class="mobileHead">&nbsp;</div><div class="cellContent"><span>' + ctaLabel + '</span> <i class="icon-arrow-right"></i></div>');
                    }
                    items.push(itemsInside);
                });
                // Initialize Data Table
                var tableElement = $(".table-component").eq(index).DataTable({
                    data : items,
                    paging : false,
                    searching : false,
                    ordering : false,
                    info : false,
                    stateSave : true,
                    columns : headingRow,
                    columnDefs : colDefinition,
                    fixedHeader : {
                        header : true,
                        bottom : false
                    },
                    createdRow : function(row, data, index) {
                        // Add Data Attribute to table row
                        if (ctakey > 0) {
                            $(row).attr("data-href", data[ctakey]);
                        }
                    }
                });
                setTimeout(function() {
                    new $.fn.dataTable.FixedHeader(tableElement);
                }, 1500);
            },
            error: function() {
                $this.find(".alert").text("Something went wrong in CSV");
                $this.find(".alert").removeClass("hidden");
            }
        });
    }
}

$(document).ready(function() {
    // Multiple Tables in one page
    $(".table-wrapper").each(function(index) {
        createDataTable($(this), index);
    });

    //Click Event on each row
    $(".table-component").on("click", "tbody tr", function(e) {
        if ($(this).attr("data-href") !== undefined) {
            location.href = $(this).attr("data-href");
        }
    });
});

(function($) {
    "use strict";
    // This takes you to the json file related to the csv
    $(document).on("click", ".open-json-in-new-tab", function(e) {
        e.preventDefault();
        var csvPath = $(this).parents(".table-csv-section").find(".js-coral-pathbrowser-input").val();
        var path = "/assetdetails.html/content/dam/onespark/tables/json/" + csvPath.substring(csvPath.lastIndexOf('/') + 1).replace(".csv", ".json");
        window.open(path, "_blank");
    });

    // For disabling the activate json button if csv path is blank
    $(document).on("input", ".table-csv-section input[type=text]", function(e) {
        var targetSelector = $(this).parents(".table-csv-section").find(".open-json-in-new-tab");
        targetSelector.prop('disabled', $(this).val() === '');
    });
})(Granite.$);

$(document).ready(function(){
	if($('.device-details-right').find(".nav-tabs").length>0){
		if($('.device-details-right .nav-tabs').find(".tab-item").length>0)
		{
			$(".tab-item").first().addClass("active");
			var tabContent=$(".tab-item").first().find("a").attr("href");
			if(tabContent != undefined)
			{
				tabContent=tabContent.replace ('#', '');
				$("[id='"+tabContent+"']").addClass("active");
				$("[id='"+tabContent+"']").addClass("in");
			}
		}else{
			$('.device-details-right').find(".tab-outer-container").remove();
		}	
	}
	fnTechSpechsGridStructure();
});


function fnTechSpechsGridStructure(){
	setTimeout( function(){
		var arr=[0,1];
		for(var q=0;q<arr.length;q++){
			$('.device-features .row').eq(arr[q]).find('div ul').css('height','')
		}
		var row=3;
		if($(window).width() > 639 && $(window).width() <= 1199){
			row=2;
		}
		if($(window).width() >= 1200){
			row=3;
		}
		if ($(window).width() > 639){
			var arr=[0,1];
			for(var q=0;q<arr.length;q++){
				var maxheight = [],count=1,tempaArray=[];
				for(i=0;i<$('.device-features .row').eq(arr[q]).find('div').length;i++){
					  var j=i*2;
					  if($('.device-features .row').eq(arr[q]).find('div').eq(j).length !=0) {
						  tempaArray.push(j);
						  if(count%row ==0){
							  for(var k=0;k<tempaArray.length;k++){
								  maxheight.push($('.device-features .row').eq(arr[q]).find('div').eq(tempaArray[k]).find('ul').height());
							  }
							  for(var k=0;k<tempaArray.length;k++){
								  $('.device-features .row').eq(arr[q]).find('div').eq(tempaArray[k]).find('ul').height(Math.max.apply(Math,maxheight)+'px');
							  }
							  tempaArray=[];
							  maxheight = [];
						  }
					  }
					  count++;
				}
			}
		}
	},1000);
}

$(window).resize(function() {
	fnTechSpechsGridStructure();
});
$(document).ready(function() {
	fnSolutionCardCarousel();
	$(".our-solution-list li").css("height","");
    var maxHeight = (getMaxHeight($(".our-solution-list li")));
    setTimeout( function(){
	    $(".our-solution-list li").each(function(){
			$(this).css("height",maxHeight);
	    });
    },500);
});

function fnSolutionCardCarousel(){
	if ($(window).width() < 639){
		if(!$(".oursolutions").hasClass('slick-initialized')){
			$(".oursolutions").slick({
				dots : false,
				infinite : true,
				variableWidth : true,
				arrows : false,
				swipe : true,
				resize: true
			});
		}
	}
	if ($(window).width() >= 640){
		if($(".oursolutions").hasClass('slick-initialized')){
			$('.oursolutions').slick('unslick');
		}
	}
}

$(window).resize(function() {
	fnSolutionCardCarousel();
	$(".our-solution-list li").css("height","");
	var maxHeight = (getMaxHeight($(".our-solution-list li")));
	setTimeout( function(){
	    $(".our-solution-list li").each(function(){
			$(this).css("height",maxHeight);
	    });
	},500);
});

function getMaxHeight(newArray){
  var cardMaxHeight = 0;
    if(newArray != undefined && newArray.length >0){
        for(var i=0;i<newArray.length;i++){
            if($(newArray[i]).height()>cardMaxHeight){
			    cardMaxHeight = $(newArray[i]).height();
            }
        }
    }
    return cardMaxHeight;
} 
if($("#manual").val() !=""){
	var backgroundImage = $("#manual").val();
	if(!(backgroundImage == undefined)){
		$('.manual').css({
			background:"url('"+backgroundImage+"') no-repeat scroll 0 0 / cover"
		});
	}
}

function fnSlnCardColors(classname, id,cond){
	var value = $("."+id).val();
	$(classname+" > p").addClass(value);
	$(classname+" > p a").addClass(value);
	$(classname+" > ul").addClass(value);
	$(classname+" > ul a").addClass(value);
	$(classname+" > ol").addClass(value);
	$(classname+" > ol a").addClass(value);
}

function fnSolutionCardColors(classname, id,cond){
	var value = $("."+id).val();
	var contactLinkColor ="black80";
	if(value == "white"){
		contactLinkColor ="white";
	}
	if(value == "black60"){
		contactLinkColor ="black80";
	}
	$(classname+" > p").addClass(value);
	$(classname+" > p a").addClass(contactLinkColor);
	$(classname+" > ul").addClass(value);
	$(classname+" > ul a").addClass(contactLinkColor);
	$(classname+" > ol").addClass(value);
	$(classname+" > ol a").addClass(contactLinkColor);
}

$(document).ready(function() {
	fnSlnCardColors(".manual .sol-description", "descColor",true);
	fnSolutionCardColors(".manual .contact-us-link", "linkColor",true);
	alterSolutionCardDiv();
});

$(window).resize(function(){
	alterSolutionCardDiv();
});

function alterSolutionCardDiv(){
	setTimeout( function(){
		var maxheight = [];
		$('.panel-bg.our-solution-block').css("height","");
		$('.panel-bg.our-solution-block').each(function(){
			maxheight.push($(this).height());
		});
		$('.panel-bg.our-solution-block').height(Math.max.apply(Math,maxheight));
	},500);
}
$(document).ready(
        function() {
            var recaptchaResponse;
            $.getScript("https://www.google.com/recaptcha/api.js?onload=publicKey&render=explicit", setTimeout(function() {
                if ($('.sendtestmail-Wrapper').length) {
                    if (typeof grecaptcha === "undefined") {
                        location.reload();
                    }
                    $.ajax({
                        url : '/rest/v1/captcha/publickey',
                        dataType : 'json',
                        type : "GET",
                        contentType : "application/json;charset=utf-8",
                        success : function(returnData) {
                            widgetId = grecaptcha.render('g-recaptcha-id', {
                                'sitekey' : returnData,
                                'callback' : reCaptchaVerify
                            });
                        },
                        error : function(xhr, ajaxOptions, thrownError) {
                        },
                        complete : function() {
                        }
                    });
                }
            }, 1000));

            function reCaptchaVerify(response) {
                recaptchaResponse = response;
            }

            // on click outside the input field
            $(document).bind(
                    'click',
                    function(event) {
                        // Check if we have not clicked on the input
                        if (document.getElementById('helpsendEmailAddressInput') !== null && $('#helpsendEmailAddressInput').val() !== ""
                                && !($(event.target).parents().andSelf().is('#helpsendEmailAddressInput'))) {
                            var email = validateEmail($('#helpsendEmailAddressInput').val());
                            $('#helpsendEmailAddressInput').val(email);
                        }
                        if ($('#helpsendEmailAddressInput').val() === "") {
                            $('.sendtestmail-Wrapper .post-text').show();
                        }
                    });
            // Disable the send button if no email entered

            $('#helpsendEmailAddressInput').keyup(function() {
                $('#send-test-email-send-button .btn-primary').prop('disabled', this.value === "");
                if ($('#helpsendEmailAddressInput').val() === "") {
                    $('.sendtestmail-Wrapper .post-text').show();
                }

            });
            if ($('.sendtestmail-Wrapper').length) {
                $('#send-test-email-send-button .btn-primary').prop('disabled', true);
            }
            $(".sendtestmail-Wrapper").on('DOMSubtreeModified', "#email-error", function() {
                $('#send-test-email-send-button .btn-primary').prop('disabled', $('#email-error').text() !== "");
            });

            // Call to Servlet when clicked on send button
            $(document).on("click", "#send-test-email-send-button .btn-primary", function() {
                var emailAddress = validateEmail($('#helpsendEmailAddressInput').val());
                $('#back-error').html("");
                if ($('#email-error').text() === "") {
                    $.ajax({
                        dataType : 'json',
                        type : "POST",
                        url : "/rest/v1/xtramail/help/testemail",
                        contentType : "application/x-www-form-urlencoded; charset=UTF-8",
                        data : {
                            emailAddress : emailAddress,
                            recaptchaResponse : recaptchaResponse
                        },
                        success : function(data, textStatus, jqXHR) {
                            var questionId = getQuestionId();
                            var troubleShootingPage = $("#troubleShootingPagePath").val();
                            var redirect;
                            if (troubleShootingPage.indexOf(".html") >= 0) {
                                redirect = troubleShootingPage + questionId;
                            } else {
                                redirect = troubleShootingPage + ".html" + questionId;
                            }
                            window.location.href = redirect;
                        },
                        error : function(err) {
                            var errorMessage = "";
                            if (typeof err.responseJSON.messages !== "undefined" && typeof err.responseJSON.messages.messages !== "undefined") {
                                for (var message = 0; message < err.responseJSON.messages.messages.length; message++) {
                                    if (message !== (err.responseJSON.messages.messages.length) - 1) {
                                        errorMessage += err.responseJSON.messages.messages[message].description + '<br/>';
                                    } else {
                                        errorMessage += err.responseJSON.messages.messages[message].description;
                                    }
                                }
                                $('#back-error').html(errorMessage);
                                grecaptcha.reset(widgetId);
                            }
                        },
                        complete : function() {
                        }
                    });
                }
            });

            // validate entered email is xtra.co.nz domain
            function validateEmail(email) {
                var emailAddress;
                if (email.indexOf("@") !== -1) {
                    $('#email-error').html('');
                    var substr = email.substring(email.indexOf("@"), email.length);
                    if (substr === "@xtra.co.nz") {
                        emailAddress = email;
                    } else if (email.length - 1 > email.indexOf("@")) {
                        emailAddress = email;
                        $('#email-error').html("Sorry! We didn't recognise those details. Check them and try again");
                    } else {
                        $('#email-error').html('');
                        emailAddress = email + "xtra.co.nz";
                    }

                } else {
                    $('#email-error').html('');
                    emailAddress = email + "@xtra.co.nz";
                }
                $('.sendtestmail-Wrapper .post-text').hide();
                return emailAddress;
            }

            function getQuestionId() {
                var link = window.location.href;
                var questinId = link.substring((link.indexOf('?questionId')), link.length);
                return questinId;
            }
          //Validating email when TabKey Pressed 
            $('#helpsendEmailAddressInput').keydown(function(e) {
                var pressedKey = (e.keyCode ? e.keyCode : e.which);
                //If pressed key is TabKey
                if(pressedKey == 9){
                    $('#helpsendEmailAddressInput').val(validateEmail($('#helpsendEmailAddressInput').val()));
                }
            });
        });

(function() {
	var mq = window.matchMedia("(max-width: 639px)");
	if (mq.matches) {
		initSlickSlider();
	}
	function initSlickSlider() {
		$(".gallery.rc-block").slick({
			resize : true,
			dots : false,
			infinite : true,
			variableWidth : true
		});
	}
	$(window).resize(function() {
		initSlickSlider();
	});
})();
(function() {
  (function($) {
    var Fewlines;
    Fewlines = (function() {

      function Fewlines(el, options) {
        var appendText, div, hidLines, i, lineHeight, needCut, text, visLines, words, _i, _ref,
          _this = this;
        this.defaults = {
          'closeMark': 'close',
          'openMark': '...',
          'newLine': false,
          'lines': 2
        };
        this.opts = $.extend({}, this.defaults, options);
        this.$el = $(el);
        if (navigator.userAgent.search("Chrome") >= 0 || $(window).width() > 639 && $(window).width() < 940){
        div = $("<div>x</div>").css({
          'position': 'absolute',
          'left': 0,
          'top': "-3000px",
          "visibility": "hidden",
        }).width($(this.$el).width()).css($(this.$el).css(['font-size', 'font-weight', 'font-family'])).appendTo('body');
        }
        else
        	{
        	div = $("<div><p>x</p></div>").css({
                'position': 'absolute',
                'left': 0,
                'top': "-3000px",
                "visibility": "hidden",
              }).width($(this.$el).width()).css($(this.$el).css(['font-size', 'font-weight', 'font-family'])).appendTo('body');
        	}
        text = $(el).text();
        lineHeight = div.height();
        words = text.split(/\b/);
        needCut = false;
        this.openMark = $("<a class='openMark' href='#/'>" + this.opts.openMark + "</a>");
        if (this.opts.newLine) {
          this.openMark.css({
            'display': 'block'
          });
        }
        this.openMark.bind('click', function(event) {
          event.preventDefault();
          return _this.show();
        });
        this.closeMark = $("<a class='closeMark' href='#/'>" + this.opts.closeMark + "</a>").hide();
        this.closeMark.bind('click', function(event) {
          event.preventDefault();
          return _this.close();
        });
        for (i = _i = 0, _ref = words.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          appendText = this.getLines(words, i);
          if (!this.opts.newLine) {
            appendText += this.opts.openMark;
          }
          div.text(appendText);
          if (div.height() > this.opts.lines * lineHeight) {
            needCut = true;
            break;
          }
        }
        visLines = this.getLines(words, i - 1);
        hidLines = text.slice(visLines.length);
        this.hidePart = $('<span>').hide().text(hidLines);
        if (needCut) {
          this.$el.text(visLines).append(this.openMark).append(this.hidePart).append(this.closeMark);
        }
        div.remove();
        this.$el;
      }

      Fewlines.prototype.getLines = function(words, i) {
        return words.slice(0, +i + 1 || 9e9).join('').replace(/\W+$/, '');
      };

      Fewlines.prototype.show = function() {
        this.openMark.hide();
        this.hidePart.show();
        return this.closeMark.css("display", "block");
      };

      Fewlines.prototype.close = function() {
        this.openMark.show();
        this.hidePart.hide();
        return this.closeMark.hide();
      };

      Fewlines.prototype.init = function() {
        return this;
      };

      return Fewlines;

    })();
    return $.fn.fewlines = function(options) {
      if (this.length) {
        return this.each(function() {
          var rev;
          rev = new Fewlines(this, options);
          rev.init();
          return $(this).data("fewlines", rev);
        });
      }
    };
  })(jQuery);

}).call(this);
$('div .tile-click').click(function(){
	window.location = $(this).find("p").next('a').attr("href"); 
	  return false;
});

function functionOnResize(){
	if($("div.mp-tile p").length >0){
		setTimeout( function(){
			$("div.mp-tile p").fewlines({
				'closeMark' : ' ',
				'openMark' : '...',
				'lines' : 2
			});
			$(".productGrid .mp-tile.tile-box p a").each(function(){
				$(this).html($(this).html().replace(/\.\.\./g,"$47"));
			});
			$(".productGrid .mp-tile.tile-box p").each(function(){
				$(this).html($(this).html().replace(/\.\.\./g,""));
			});
			$(".productGrid .mp-tile.tile-box p a").each(function(){
				$(this).html($(this).html().replace(/\$47/g,"..."));
			});
			$('div.mp-tile a.openMark').click(function(e){
				$(this).hide();
				$(this).parent().find('span').show();
				$(this).parent().find('div.mp-tile a.closeMark').show();
				$('.productGrid .mp-tile.tile-box').css("height","");
				var maxheight = [];
				$('.productGrid .mp-tile.tile-box').each(function(){
					maxheight.push($(this).height());
				});
				return false;
			});
			$('div.mp-tile a.closeMark').click(function(e){
				$(this).hide();
				$(this).parent().find('span').hide();
				$(this).parent().find('div.mp-tile a.openMark').show();
				return false;
			});
		},500);
		fnProdutcGridDivAlignment();
	}
}

function reizingInTabletView(){
	if($(window).width() > 639 && $(window).width() <= 939){
		functionOnResize();
	}
	if($(window).width() > 939){
		$(".productGrid .mp-tile.tile-box p").each(function(){
			$(this).text($(this).text().replace(/\.\.\./g,""));
	 	});
		fnProdutcGridDivAlignment();
	}
	if($(window).width() <= 639){
		$(".productGrid .mp-tile.tile-box p").each(function(){
			$(this).text($(this).text().replace(/\.\.\./g,""));
	 	});
		fnProdutcGridDivAlignment();
	}
}

$(window).on('load',function(){
	reizingInTabletView();
});

$(window).on('resize',function(){
	reizingInTabletView();
});
$('div .tile-click').click(function(){
	window.location = $(this).find("a").attr("href"); 
	  return false;
});
var mobileFlag =false;
var tabletFlag =false;
var mediascreenFlag =false;
var largescreenFlag =false;
$(document).ready(function(){
	resizing();
	fnProductGridArrowRightMobile();
	fnProdutGridStickyDiv();
});

function resizing(){
	fnProdutcGridDivAlignment();
}

$(window).resize(function() {
	var el = $('#mobilePlans');
	el.css({position :"",top : ""});
	resizing();
	fnProductGridArrowRightMobile();
	fnProdutGridStickyDiv();
	if ($(window).width() <= 639){
		fnProdutcGridDivAlignment();
	}
});

function fnProductGridArrowRightMobile(){
	if ($(window).width() > 639){
		$(".mp-tile").each(function(){
			if($(this).find('span').hasClass('right-arrow-productGrid')){
				$(this).find('span').css("display","none");
			}
		});
	}
	if ($(window).width() < 640){
		$(".mp-tile").each(function(){
			if($(this).find('span').hasClass('right-arrow-productGrid')){
				$(this).find('span').css("display","inline-block");
			}
		});
	}
}

function fnProdutcGridDivAlignment(){
	setTimeout(function(){
	$('.productGrid .mp-tile.tile-box').css("height","");
	var maxheight = [];
	$('.productGrid .mp-tile.tile-box').each(function(){
		maxheight.push($(this).height());
	});
	$('.productGrid .mp-tile.tile-box').height(Math.max.apply(Math,maxheight))},500);
}

function fnProdutGridStickyDiv(){
	var mq2 = window.matchMedia("(min-width: 940px)");
	if (mq2.matches) {
		if (!!$('#mobilePlans').length) { // make sure "#sticky" element exists
			var el = $('#mobilePlans');
			var stickyTop = $('#mobilePlans').offset().top; // returns number
			$(window).scroll(function() { // scroll event
				var windowTop = $(window).scrollTop(); // returns number//$(this).scrollTop();
				if (stickyTop < windowTop) {
					el.css({position : 'fixed',top :0});
				} else {
					el.css('position', 'static');
				}
				var productList = $('.mobile-plans-info .row .col-md-12').offset().top + $('.mobile-plans-info .row .col-md-12').height();
				var featureImg = $('img.img-responsive').offset().top + $('img.img-responsive').height();
				if( productList <= featureImg){
					var diff = productList - featureImg;
					el.css({top : diff});
				}
			});
		} // make sure "#sticky" element exists
	}else{
		var el = $('#mobilePlans');
		el.css({position :"",top : ""});
		$(window).scroll(function(){
			if ($('#mobilePlans').length !=0){
				el.css('position', 'static');
			}
		});
	}
}
$(document).ready(function() {
	fnProductCardSlick();
    var columnCountClass=$('#columnCount').val();
    var columnCount=0;   
    if(columnCountClass!= undefined){
    	if(columnCountClass=='center-block'){
    		$('.card-div').each(function(){
    			$(this).addClass('wd-50');
    			if ($(window).width() > 939){
    				var parent=$(this).closest("div.plans-grid-parent"); 
    				$(parent).find('.plan-family div:first').css("margin-left", "33%");
    				$(parent).find('.plan-family h2').css("margin-bottom", "12px");
    				$(parent).find('.plan-family div:nth-child(2)').css({"width":"32%", "margin-left": "34%", "word-wrap": "break-word"});
    			}
    		}); 
    		columnCount=1;
    	}
    	if(columnCountClass=='col-md-5 col-lg-5'){
    		columnCount=2;
    		$('.plans-grid-parent .card-div').each(function(index){
    			if(index==0 || index%2==0){
    				$(this).addClass('col-lg-offset-1');
    				if ($(window).width() > 939) {	
    					var parent=$(this).closest("div.plans-grid-parent"); 
    					$(parent).find('.plan-family div:first').css("margin-left", "8.333333%");
    					$(parent).find('.plan-family div:nth-child(2)').css({"width":"32%", "margin-left": "100px", "word-wrap": "break-word"});
    				}
    			}
    		})
    	}
    	if(columnCountClass=='col-md-4 col-lg-4'){
    		columnCount=3;
    	}
    }
    if(columnCount!=0) {  
    	var array=$('.plans-grid .plan-wrap');
	    findMaxHeight(array);
    }
    fnProductCardDivAlignment();
});

function fnProductCardSlick(){
	var mq = window.matchMedia( "(max-width: 939px)" ); 
    if (mq.matches){
        if (!$('.plans-gallery').hasClass("slick-initialized")) {
			$(".plans-gallery").slick({
				dots : false,
				infinite : true,
				variableWidth : true,
				arrows : false,
				swipe : true,
				resize: true,
				responsive: [ 
	                { 
	                	breakpoint: 939, 
	                	settings: {
	                        slidesToShow: 2, 
	                        slidesToScroll: 1 
	                  	}
	                },
	                { 
	                	breakpoint: 639, 
	                    settings: { 
	                          slidesToShow: 1, 
	                          slidesToScroll: 1 
	                	}
	                }
	            ]
			});
        }
    }
}

$(window).resize(function(){
	for(var i=0;i<$('.plans-grid .plan-wrap').length;i++){
		$($('.plans-grid .plan-wrap')[i]).find('.title-section').css("height","");
		$($('.plans-grid .plan-wrap')[i]).find('.card-fieldset').css("height","");  	
	}
    fnProductCardDivAlignment();
});

function findMaxHeight(newArray){
	setTimeout( function(){
	var maxHeight=0;
	var maxFieldSet=0;
	var maxTitleSection=0;
	if(newArray.length>=1){
		 maxHeight=$(newArray[0]).height();
    	 maxFieldSet=$(newArray[0]).find('.card-fieldset').height();
    	 maxTitleSection=$(newArray[0]).find('.title-section').height();
    	 for(var i=0;i<newArray.length;i++){
    		 if(maxHeight<=$(newArray[i]).height()){
    			 maxHeight=$(newArray[i]).height();
    	     }
    		 if(maxFieldSet<=$(newArray[i]).find('.card-fieldset').height()){
    			 maxFieldSet=$(newArray[i]).find('.card-fieldset').height();
    		 }
    		 if(maxTitleSection<=$(newArray[i]).find('.title-section').height()){
    			 maxTitleSection=$(newArray[i]).find('.title-section').height()
    		 }
    	 }
	}
	for(var counter=0;counter<newArray.length;counter++){
		$(newArray[counter]).find('.title-section').css("height",maxTitleSection);
		$(newArray[counter]).find('.card-fieldset').css("height",maxFieldSet);  		
	}},500);
}

function fnProductCardDivAlignment(){
	setTimeout( function(){
        if ($(window).width()<940){
        	fnProductCardSlick();
        }
        if ($(window).width() > 939){
        	if ($('.plans-gallery').hasClass("slick-initialized")) {
          		$('.plans-gallery').slick('unslick');
        	}
    	}
        var maxHeight = [];
        $(".plan-wrap .plan-body .plan-fluid.title-section").each(function(){
        	maxHeight.push($(this).height());
        });
        $(".plan-wrap .plan-body .plan-fluid.title-section").height(Math.max.apply(Math,maxHeight));
        maxHeight = [];
        $(".plan-wrap .plan-body .plan-fluid .card-fieldset").each(function(){
        	maxHeight.push($(this).height());
        });
        $(".plan-wrap .plan-body .plan-fluid .card-fieldset").height(Math.max.apply(Math,maxHeight));
		},500);
}
//To play the video on click of play icon
$(".product-features .feature-block .feature-video-play").on('click', function(){
    var iframeParent = $(this).parent();
    var iframe = iframeParent.find('.feature-video-placeholder iframe');
    iframe.attr('src', iframe.attr('data-video-src')+"?autoplay=1");
    setTimeout(function() {
        iframeParent.find('img').hide();
    }, 1000);
    iframeParent.find('.feature-video-placeholder').removeClass('hidden');
});
$( document ).ready(function() {
    var lastId;
    if ($('#globalpabel').length) {
        var targetPos = $('.pattern-fixed-navigation').offset().top;
    }
    var mq2 = window.matchMedia("(max-width: 940px)");
    var mq3 = window.matchMedia("(min-width: 940px)");
    if (mq2.matches) {
        if (!!$('#globalpabel').length) {
            $('#globalpabel').parents(".container-fluid").addClass("lhs-globalleft");

            var el = $('#globalpabel');
            var stickyTop = $('#globalpabelAnchor').offset().top;
            var footerTop = $('#paterncontainerbottom').offset().top - 30;
            var stickyHeight = $('#globalpabel').height();
            var limit = footerTop - stickyHeight;
            var windowTop = $(window).scrollTop();
            $(window).scroll(function() { // scroll event
                el = $('#globalpabel');
                var elementHeight=$('.pattern-cards-list')[0].clientHeight;
                footerTop = $('#paterncontainerbottom').offset().top - 30;
                stickyHeight = $('#globalpabel').height();
                limit = footerTop - stickyHeight;
                windowTop = $(window).scrollTop();
                var fromTop = $(this).scrollTop() + topMenuHeight;
                var scrollPos = $(this).scrollTop();
                curThreadScroll(scrollPos);
                var cur = scrollItems.map(function() {
                    if ($(this).offset().top < fromTop) {
                        return this;
                    }
                });

                cur = cur[cur.length - 1];
                var id = cur && cur.length ? cur[0].id : "";
                if (lastId !== id) {
                    lastId = id;
                    menuItems.parent().removeClass("fixed-nav-active").end().filter("[href='#" + id + "']").parent().addClass("fixed-nav-active");
                }
                if ($('body').width() < 960) {
                    if ($('.pattern-cards-list li:first-child').hasClass('fixed-nav-active')) {
                        if ($('.pl-sticky-nav-item').length) {
                            $('.pattern-fixed-navigation').addClass('pattern-scroll');
                        }
                    }
                }
                $('.pattern-fixed-navigation').addClass('pattern-scroll');
                if (stickyTop-elementHeight < windowTop) {
                    el.css({
                        position : 'fixed',
                        top : 0
                    });
                    $('.pattern-cards-list li').show();
                } else {
                    el.css({
                        position : 'static',
                        top : -300
                    });
                    $('.pattern-cards-list li').show();
                }
                if (limit < windowTop) {
                    var diff = limit - windowTop;
                    el.css({
                        top : diff
                    });
                    $('.pattern-cards-list li').hide();
                }
            });
        }
    } else if (mq3.matches) {
        if (!!$('#globalpabel').length) {
            $('#globalpabel').parents(".container-fluid").addClass("lhs-globalleft");

            var el = $('#globalpabel');
            var stickyTop = $('#globalpabel').offset().top - 10;
            var footerTop = $('#paterncontainerbottom').offset().top - 30;
            var stickyHeight = $('#globalpabel').height();
            var limit = footerTop - stickyHeight;
            var windowTop = $(window).scrollTop();
            $(window).scroll(function() { // scroll event
                el = $('#globalpabel');
                footerTop = $('#paterncontainerbottom').offset().top - 30;
                stickyHeight = $('#globalpabel').height();
                limit = footerTop - stickyHeight;
                windowTop = $(window).scrollTop();
                var fromTop = $(this).scrollTop() + topMenuHeight;
                var scrollPos = $(this).scrollTop();
                curThreadScroll(scrollPos);
                var cur = scrollItems.map(function() {
                    if ($(this).offset().top < fromTop)
                        return this;
                });

                cur = cur[cur.length - 1];
                var id = cur && cur.length ? cur[0].id : "";

                if (lastId !== id) {
                    lastId = id;

                    menuItems.parent().removeClass("fixed-nav-active").end().filter("[href='#" + id + "']").parent().addClass("fixed-nav-active");
                }
                if ($('body').width() < 960) {
                    if ($('.pattern-cards-list li:first-child').hasClass('fixed-nav-active')) {
                        if ($('.pl-sticky-nav-item').length) {
                            $('.pattern-fixed-navigation').addClass('pattern-scroll');
                        }
                    }
                }
                
                $('.pattern-fixed-navigation').addClass('pattern-scroll');
                if (stickyTop < windowTop) {
                    el.css({
                        position : 'fixed',
                        top : 0
                    });
                } else {
                    el.css('position', 'static');
                }
                if (limit < windowTop) {
                    var diff = limit - windowTop;
                    el.css({
                        top : diff
                    });
                }
            });
        }

    } else {
        var el = $('#globalpabel');
        el.css({
            position : "",
            top : ""
        });
        $(window).scroll(function() {
            $('.pattern-fixed-navigation').addClass('pattern-scroll');
            if ($('#globalpabel').length != 0) {
                el.css('position', 'static');
            }
        });
    }
    
    // click event functionality for sticky interaction
    var topMenu = $(".pattern-fixed-navigation");
    var topMenuHeight = topMenu.outerHeight() - 10;
    var menuItems = topMenu.find("a");
    var scrollItems = menuItems.map(function() {
        var item = $($(this).attr("href"));
        if (item.length) {
            return item;
        }
    });
                menuItems.click(function(e){
                    $('.pattern-fixed-navigation').addClass('pattern-scroll');
                    $(this).addClass('pl-sticky-nav-item');
                    var elementHeight=$('.pattern-cards-list')[0].clientHeight;
                    var href = $(this).attr("href");
                        offsetTop =  $(href).offset().top-topMenuHeight-45;
                    if ($('.pattern-cards-list li').hasClass('fixed-nav-active')) {
                        offsetTop =   $(href).offset().top-elementHeight;

                    } else if( href == '#1'){
                                menuItems.filter("#1").parent().addClass("fixed-nav-active");
                        offsetTop =   $(href).offset().top - topMenuHeight -40;
                    }
                    if($('body').width() > 960 ){
                        offsetTop =  $(href).offset().top;
                    }
                    if ($('body').width() < 640) {
                            offsetTop =   $(href).offset().top - $(window).scrollTop() - topMenu.outerHeight()-54;
                        if ($('.pattern-cards-list li').hasClass('fixed-nav-active')) {
                            offsetTop = $(href).offset().top - topMenu.outerHeight();
                            if( href == '#1'){
                                offsetTop =   $(href).offset().top - 94;
                            }
                        } else if( href == '#1'){
                                offsetTop =   $(href).offset().top - topMenuHeight + 155;
                        }
                    }                 
                    $('html, body').stop().animate({ 
                        scrollTop: offsetTop
                    }, 300);
                    e.preventDefault();
                });

    var a = window.matchMedia("(max-width: 959px)");
    if (a.matches) {
        $(".pattern-fixed-navigation .pattern-cards-list").slick({
            dots : false,
            arrow : false,
            infinite : false,
            variableWidth : true,
            prevArrow : false,
            nextArrow : false,
            speed : 300,
            slidesToShow : 4,
            slidesToScroll : 1,

            responsive : [ {
                breakpoint : 1169,
                settings : {
                    slidesToShow : 4,
                    slidesToScroll : 1,
                    dots : false,
                    arrow : false
                }
            }, {
                breakpoint : 939,
                settings : {
                    slidesToShow : 3,
                    slidesToScroll : 1,
                    dots : false,
                    arrow : false
                }
            }, {
                breakpoint : 639,
                settings : {
                    slidesToShow : 3,
                    slidesToScroll : 2,
                    dots : false,
                    arrow : false
                }
            } ]
        })

    }
    function curThreadScroll(scrollPos) {
        var thisScrollPos = scrollPos;
        if (thisScrollPos > targetPos) {
            $('.pattern-fixed-navigation').addClass('pattern-scroll');

        } else {
            $('.pattern-fixed-navigation').removeClass('pattern-scroll');
        }
    }

});
(function(){

	$(".needs-rel-content-gallery").slick({
		resize: true,
		dots: true,
		infinite: true,
		slidesToShow: 1,
		slidesToScroll: 1,
		responsive: [
		             {
		            	 breakpoint: 640,
		            	 settings: {
		            		 infinite: true,
		            		 speed: 300,
		            		 slidesToShow: 1,
		            		 centerMode: true,
		            		 variableWidth: true
		            	 }
		             }
		             ]
	});

	function officeCardsHeight() {
		var maxheight = [];
		$('.needs-rel-content-gallery .needs-rel-content-column').each(function() {
			maxheight.push($(this).height());
		});

		var max = Math.max.apply(Math, maxheight)
		$('.needs-rel-content-gallery .needs-rel-content-column').height(max);

	}
	officeCardsHeight(); 

	$(window).on('resize orientationchange', function () {
		officeCardsHeight();
	}); 

})();
function needsHeightUpdate(arr){
	for (var i = 0; i < arr.length; i=i+2) {
		var maxHeight = 0;
		var element = $(arr)[i];
		var nextElement = $(arr)[i+1];
		var even = $(element).height(); 
		var odd = $(nextElement).height();
		if(even > maxHeight || odd > maxHeight){
			(even >= odd) ? maxHeight = even : maxHeight = odd;
			$(element).height(maxHeight);
			$(nextElement).height(maxHeight);
		}

	}
}

(function(){
	// Dynamically update of height of title and description in desktop view.
	$(window).load(function(){

		$('.need-heading').each(function(){
			if ($(window).width() > 939) {
				var descArr = $(this).find('.need-content-padtop .need-flaot-left');
				var titleArr = $(this).find('.need-product-content a div.need-prod-title');
				needsHeightUpdate(titleArr);
				needsHeightUpdate(descArr);
			}
		});
	});
})();
$(document).ready(function() {
	var columnCountClass=$('.needs-guide-column').val();
    var columnCount=0;   
    if(columnCountClass!= undefined)
    {
    	if(columnCountClass=='center-block')
    	{
    		$('.needs-guide-div').each(function(){
    			$(this).addClass('wd-50');
    			if ($(window).width() > 939) {
    				var parent=$(this).closest("div.plans-grid-parent"); 
    				$(parent).find('.plan-family div:first').css({"margin-left": "24%", "width": "50%"});
    				$(parent).find('.plan-family h2').css("margin-bottom", "12px");
    				$(parent).find('.plan-family div:nth-child(2)').css({"width":"50%", "margin-left": "25%", "word-wrap": "break-word","padding-top":"1%"});
    			}
    		});     		
    		columnCount=1;
    	}
    	if(columnCountClass=='col-md-5 col-lg-5')
    	{
    		columnCount=2;
    		$('.plans-grid-parent .needs-guide-grid').each(function(index){
    			if(index==0 || index%2==0)
    			{
    				$(this).addClass('col-lg-offset-1');
    				if ($(window).width() > 939) {	
    					var parent=$(this).closest("div.plans-grid-parent"); 
    					$(parent).find('.plan-family div:first').css({"margin-left": "8.333333%", "width": "40%"});  
    					$(parent).find('.plan-family div:nth-child(2)').css({"width":"41%", "margin-left": "20px", "word-wrap": "break-word"});
    				}
    			}
    		})
    	}
    	if(columnCountClass=='col-lg-4')
    	{
    		columnCount=3;
    	}
    }
    if(columnCount!=0) {  
    	var array=$('.plans-grid .needs-guide-div');   
	    findMaxHeight(array); 	    
    }
    
    if(columnCountClass=='col-md-6 col-lg-6'){
    	columnCount=2;
	}
    function findMaxHeight(newArray)
    {
    	var maxHeight=0;
    	var maxHeadSection=0;
    	var maxListSection=0;
    	if(newArray.length>=1)
    	{
    		 maxHeight=$(newArray[0]).height();
        	 maxHeadSection=$(newArray[0]).find('.needs-guide-head').height();
        	 maxListSection=$(newArray[0]).find('.needs-guide-list').height();
        	 for(var i=0;i<newArray.length;i++)
        	 {
        		 if(maxHeight<=$(newArray[i]).height())
        	     {
        			 maxHeight=$(newArray[i]).height();
        	     }
        		 if(maxHeadSection<=$(newArray[i]).find('.needs-guide-head').height())
        		{
        			 maxHeadSection=$(newArray[i]).find('.needs-guide-head').height();
        		}
        		 if(maxListSection<=$(newArray[i]).find('.needs-guide-list').height())
        		{
        			 maxListSection=$(newArray[i]).find('.needs-guide-list').height()
        		}
        	}
    	}
    	
    	for(var counter=0;counter<newArray.length;counter++)
    	{  		
    		$(newArray[counter]).find('.needs-guide-list').css("height",maxListSection);
    		$(newArray[counter]).find('.needs-guide-head').css("height",maxHeadSection);  		
    		
    	}    	
    }
    var maxNeedGuideHeight= [];
    $('.needs-guide-block.panel-bg').each(function(e){
    	var val = $(this).height();
    	if(val >=0 ){
    		maxNeedGuideHeight.push(val)
    	}
	});
    $('.needs-guide-block.panel-bg').height(Math.max.apply(Math,maxNeedGuideHeight));
    
    if(columnCount == 2){
    	if($(document).width() >= 940){
        	$('.prod-ttl').css("width","50%");
        	$('.desc-prod-txt').css("width","50%");
    	}
    	if($(document).width() > 639 && $(document).width() <=939){
    		var firstContainerWidth = $('.needs-guide-div.needs-guide-gallery-t').eq(0).width();
    		var parentDivWidth = $('.plans-grid-parent div.plans-grid').width();
        	$('.desc-prod-txt').width(parentDivWidth-firstContainerWidth);
        	$('.prod-ttl').width(firstContainerWidth-20);
    	}
    }
});
(function(){
	$("body").scrollspy({
		target: "#myNavbar"
	})

	if($("#cust-nav-scroll").length){
		var targetPos = ($("#cust-nav-scroll").offset().top);
		$(window).scroll(function(){
			var scrollPos = $(this).scrollTop();
			if(scrollPos > targetPos){
				$("#myNavbar").addClass("fix-custom-menu");
			}else{
				$("#myNavbar").removeClass("fix-custom-menu");
			}
			$("li.active").prevAll().addClass(" themecolor_1_border");
			$("li.active").addClass(" themecolor_1_border");
			$("li.active").nextAll().removeClass(" themecolor_1_border");

			$("li.active a").addClass(" themecolor_1");
			$("#listblocks li:not(.themecolor_1_border) a").removeClass("themecolor_1");
			$("li.themecolor_1_border").prevAll().each(function(){
				$(this).find("a.themecolor_1").removeClass("themecolor_1");
			})
			needsContainer();
		});
	}	
	needsContainer();
	function needsContainer(){
		if($(window).width()> 639){
			var num_li_size = $(".custom-nav-scroll nav li").size();
			var each_li_width = (parseFloat($('#listblocks').width()))/num_li_size;
			$(".custom-nav-scroll nav li").each(function() {
				$(this).width(parseInt(each_li_width- 1.5));  
			});
		}else{
			$(".slide-scroll-nav").slick({
				resize: true,
				dots: false,
				infinite: false,
				variableWidth: true,
				placeholders:false,
				lazyLoad: 'ondemand',
				slidesToShow: 1,
				slidesToScroll: 1,
				easing: 'linear'
			});	
		}
	}

})();
$(document).ready(function() {
	$('[id^="tabs-"]').each(function(e){
		$(this)[0].id;
		$(this)[0].id.substring($(this)[0].id.indexOf("-"));
		$(".tabclass").eq(e).addClass(" tb"+$(this)[0].id.substring($(this)[0].id.indexOf("-")));
	});

	var mq2 = window.matchMedia( "(min-width: 640px)" );  
	if (mq2.matches) {

		// tb-1    
		if (!!$('.tb-1').length) { // make sure "#sticky" element exists
			var el = $('.tb-1');
			var stickyTop = $('.tb-1').offset().top; // returns number
			var footerTop = $('.tabs-1-end').offset().top; // returns number
			var stickyHeight = $('.tb-1').height();
			var stickyWidth = $('.tb-1').width();
			var limit = footerTop - stickyHeight;
			$(window).scroll(function(){ // scroll event
				var windowTop = $(window).scrollTop()+108; // returns number

				if (stickyTop < windowTop){
					el.css({ position: 'fixed', top: 97 });
					el.css('width',stickyWidth);
					//el.addClass("sticky-interaction-fixed");
				}
				else {
					el.css('position','static');
					//el.removeClass("sticky-interaction-fixed");
				}

				if (limit < windowTop) {
					var diff = limit - windowTop + 97;
					el.css({top: diff});
				}     
			});
		}

		// tb-2    
		if (!!$('.tb-2').length) { // make sure "#sticky" element exists
			var el2 = $('.tb-2');
			var stickyTop2 = $('.tb-2').offset().top; // returns number
			var footerTop2 = $('.tabs-2-end').offset().top; // returns number
			var stickyHeight2 = $('.tb-2').height();
			var limit2 = footerTop2 - stickyHeight2;
			$(window).scroll(function(){ // scroll event
				var windowTop2 = $(window).scrollTop()+108; // returns number

				if (stickyTop2 < windowTop2){
					el2.css({ position: 'fixed', top: 97 });
					el2.css('width',stickyWidth);
				}
				else {
					el2.css('position','static');
				}

				if (limit2 < windowTop2) {

					var diff2 = limit2 - windowTop2 + 97;
					el2.css({top: diff2});
				}     
			});
		}

		// tb-3    
		if (!!$('.tb-3').length) { // make sure "#sticky" element exists
			var el3 = $('.tb-3');
			var stickyTop3 = $('.tb-3').offset().top; // returns number
			var footerTop3 = $('.tabs-3-end').offset().top; // returns number
			var stickyHeight3 = $('.tb-3').height();
			var limit3 = footerTop3 - stickyHeight3;
			$(window).scroll(function(){ // scroll event
				var windowTop3 = $(window).scrollTop()+108; // returns number

				if (stickyTop3 < windowTop3){
					el3.css({ position: 'fixed', top: 97 });
					el3.css('width',stickyWidth);
				}
				else {
					el3.css('position','static');
				}

				if (limit3 < windowTop3) {
					var diff3 = limit3 - windowTop3 + 97;
					el3.css({top: diff3});
				}     
			});
		}

		// tb-4    
		if (!!$('.tb-4').length) { // make sure "#sticky" element exists
			var el4 = $('.tb-4');
			var stickyTop4 = $('.tb-4').offset().top; // returns number
			var footerTop4 = $('.tabs-4-end').offset().top; // returns number
			var stickyHeight4 = $('.tb-4').height();
			var limit4 = footerTop4 - stickyHeight4;
			$(window).scroll(function(){ // scroll event
				var windowTop4 = $(window).scrollTop()+108; // returns number

				if (stickyTop4 < windowTop4){
					el4.css({ position: 'fixed', top: 97 });
					el4.css('width',stickyWidth);
				}
				else {
					el4.css('position','static');

				}

				if (limit4 < windowTop4) {
					var diff4 = limit4 - windowTop4 + 97;    
					el4.css({top: diff4});
				}     
			});
		}

		// tb-5    
		if (!!$('.tb-5').length) { // make sure "#sticky" element exists
			var el5 = $('.tb-5');
			var stickyTop5 = $('.tb-5').offset().top; // returns number
			var footerTop5 = $('.tabs-5-end').offset().top; // returns number
			var stickyHeight5 = $('.tb-5').height();
			var limit5 = footerTop5 - stickyHeight5;
			$(window).scroll(function(){ // scroll event
				var windowTop5 = $(window).scrollTop()+108; // returns number

				if (stickyTop5 < windowTop5){
					el5.css({ position: 'fixed', top: 97 });
					el5.css('width',stickyWidth);
				}
				else {
					el5.css('position','static'); 
				}

				if (limit5 < windowTop5) {
					var diff5 = limit5 - windowTop5 + 97;    
					el5.css({top: diff5});
				}     
			});
		}

	}
	//setTimeout( function(){$("html,body").animate({ scrollTop: 0 }, "slow")}, 500);
});

function navigate(){
	$(".needimg-panel-section .pos-rel").click(function() {
		window.location = $(this).find(".need-img-content a").attr("href"); 
		return false;
	});
}
$(document).ready(function(){
	$('body').scrollspy({
		target: '#myNavbar2'
	});
    tabHeight();
	if($('.iconpatterngallery-panel #cust-nav-scroll').length){

        if (0 != window.location.hash.length) {
            let tabId = window.location.hash.substring(1);
            fnShowActiveTab(tabId);
            $('#' + tabId).parent().addClass('themecolor_1_border');
            $('#' + tabId).addClass('themecolor_1');
        }
		fnIconTabSetWidth();

		var targetPos = ($('#cust-nav-scroll').offset().top);
            $(window).scroll(function(){
                var iconTabListWidth = $('#cust-nav-scroll').width();
                var scrollPos = $(this).scrollTop();
                if(scrollPos > targetPos){
                    $('.ig-slide-scroll-nav li').width($('#cust-nav-scroll').width()/$('.ig-slide-scroll-nav li').length);
                    $('#myNavbar2').addClass('fix-custom-menu');
                    $('#myNavbar2').css('width',iconTabListWidth);
                }else{
                    $('#myNavbar2').removeClass('fix-custom-menu');
                    $('#myNavbar2').css('width','');
                }
                $('.iconpatterngallery-panel #cust-nav-scroll li.active').addClass(' themecolor_1_border');
                $('.iconpatterngallery-panel #cust-nav-scroll li.active').nextAll().removeClass(' themecolor_1_border');
                $('.iconpatterngallery-panel #cust-nav-scroll li.active a').addClass(' themecolor_1');
                $('.iconpatterngallery-panel #listblocks2 li:not(.themecolor_1_border) a').removeClass('themecolor_1');
                $('.iconpatterngallery-panel #cust-nav-scroll li.themecolor_1_border').prevAll().each(function(){
                    $(this).find('a.themecolor_1').removeClass('themecolor_1');
                })
                needsIconContainer();
            });
            $('.iconpatterngallery-panel').on('click', '#cust-nav-scroll li a', function(e){
            	e.stopPropagation();
            	var activeTabSelection = $(this).attr('href').substr(1);
                var id = $(e.target).attr('href').substr(1);
                fnShowActiveTab(activeTabSelection);
                $(this).parent().addClass('themecolor_1_border');
                $(this).addClass('themecolor_1');
            });
         }
	needsIconContainer();
});

function fnShowActiveTab(activeTab) {
    $('#cust-nav-scroll li').removeClass('themecolor_1_border');
    $('#cust-nav-scroll li a').removeClass('themecolor_1');
    $('.ig-tab-content .full-col-width > div').hide();
    $('.ig-tab-content .full-col-width > div' + '.' + activeTab).show();
}

function fnIconTabSetWidth(){
	$('#cust-nav-scroll li').removeClass('active');
	setTimeout( function(){
		$('.ig-slide-scroll-nav li').width($('#cust-nav-scroll').width()/$('.ig-slide-scroll-nav li').length);
	},500);
}

$(window).resize(function(){
	fnIconTabSetWidth();
});

function needsIconContainer(){
	if ($('.ig-slide-scroll-nav').hasClass('slick-initialized')) {
		$('.ig-slide-scroll-nav').slick('unslick');
	}
	if ($('.ig-slide-scroll-nav').hasClass('slick-initialized')) {
		$('.ig-slide-scroll-nav').slick('unslick');
	}
	var each_li_width = '50%'
	$('.ig-custom-nav-tab-scroll  nav li').each(function() {
		$(this).width(each_li_width);  
	});
}

function tabHeight() {
    if ($('.iconpatterngallery-panel #cust-nav-scroll').length) {
        var maxHeight = 0;
        var items = $("#cust-nav-scroll li").length;
        for (var tabIndex = 0; tabIndex < items - 1; tabIndex++) {
            if ($("#cust-nav-scroll li")[tabIndex].clientHeight != undefined && $("#cust-nav-scroll li")[tabIndex + 1].clientHeight != undefined) {
                var height = Math.max($("#cust-nav-scroll li")[tabIndex].clientHeight, $("#cust-nav-scroll li")[tabIndex + 1].clientHeight);
                maxHeight = height;
            }
        }
        for (var tab = 0; tab < items; tab++) {
            if ($("#cust-nav-scroll li")[tab].children["0"] != undefined) {
                $("#cust-nav-scroll li")[tab].children["0"].style.height = maxHeight + "px";
            }
        }
    }
}
$(document).ready(function() {
	$('.pl-baner-fullwidth-btn-zip').click(function() {
		if ($(this).attr('href').indexOf('dam') != -1) {
			$(this).attr('download', '');
		}
	});
});
$(document).ready(function() {
	var columnCountClass=$('#cardColumnCount').val();
    var columnCount=0;
    if(columnCountClass!= undefined){
    	if(columnCountClass=='col-md-12 col-sm-12'){
    		$('.home-card').each(function(){
    			$(this).addClass('center-block wd-50');
    		}); 
    		columnCount=1;
    	}
        if(columnCountClass=='col-md-6 col-sm-6'){
    		columnCount=2;
    	}
    }

    if (columnCount != 0) {
        if ($(window).width() <= 639) {
            $('.home-card .panel-home').css("height", "");
        }
    }
    $(".home-tile").css('cursor','pointer');
    var homeCardContainer = $(".home-card-container-section");
    if(homeCardContainer.length && homeCardContainer.hasClass("hide")) {
        homeCardContainer.removeClass("hide");
    }
	alterHomeCardDiv();
	return false;
});

$(window).resize(function(){
	alterHomeCardDiv();
});

function alterHomeCardDiv(){
	if ($(window).width() <= 639){
		$(".home-card .panel-home p").each(function(){
			$(this).text($(this).text().replace(/\.\.\./g,""));
		});
		$('.home-card .panel-home').css("height","");
	}
	if($(window).width() > 639 && $(window).width() <= 939){
		fnTrimDescHomecard();
	}
	if ($(window).width() > 939){
		$(".home-card .panel-home p").each(function(){
			$(this).text($(this).text().replace(/\.\.\./g,""));
		});
		fnAddHeightForDesc();
		fnTitleBelowImage();
		fnTitleWithoutImage();
	}
}

function fnTrimDescHomecard(){
	if($(".home-card .panel-home p").length >0){
		setTimeout( function(){
			$(".home-card .panel-home p").fewlines({
				'closeMark' : ' ',
				'openMark' : '...',
				'lines' : 4
			});
			$(".home-card .panel-home p a").each(function(){
				$(this).html($(this).html().replace(/\.\.\./g,"$47"));
		 	});
			$(".home-card .panel-home p").each(function(){
				$(this).html($(this).html().replace(/\.\.\./g,""));
		 	});
			$(".home-card .panel-home p a").each(function(){
				$(this).html($(this).html().replace(/\$47/g,"..."));
			});
			$('.home-tile-content a.openMark').click(function(e){
				$(this).hide();
				$(this).parent().find('span').show();
				$(this).parent().find('.home-tile-content a.closeMark').show();
				fnAddHeightForDesc();
				fnTitleWithoutImage();
				fnTitleBelowImageForTwo();
				return false;
			});
			$('.home-tile-content a.closeMark').click(function(e){
				$(this).hide();
				$(this).parent().find('span').hide();
				$(this).parent().find('.home-tile-content a.openMark').show();
				fnAddHeightForDesc();
				fnTitleWithoutImage();
				fnTitleBelowImageForTwo();
				return false;
			});
		},0);
		fnAddHeightForDesc();
		fnTitleWithoutImage();
		fnTitleBelowImageForTwo();
	}
}

function fnAddHeightForDesc(){
	if($("div.panel-home").hasClass('titleOnTopImage')){
		setTimeout( function(){
			$('.home-card .titleOnTopImage').css("height","");
			var maxheighthomecard = [];
			$('.home-card .titleOnTopImage').each(function(){
				maxheighthomecard.push($(this).find('div.home-tile').height()+$(this).find('div.home-tile-content').height());
			});
			$('.home-card .titleOnTopImage').height(Math.max.apply(Math,maxheighthomecard)+70);
		}, 0);
	}
}

function fnTitleBelowImage(){
	if($("div.panel-home").hasClass('titleBelowImage')){
		setTimeout( function(){
			$('.home-card .titleBelowImage').css("height","");
			var maxheighthomecard = [];
			$('.home-card .titleBelowImage').each(function(){
				maxheighthomecard.push($(this).find('div.home-tile').height()+$(this).find('div.home-tile-content').height());
			});
			$('.home-card .titleBelowImage').height(Math.max.apply(Math,maxheighthomecard)+160);
		},0);
	}
}

function fnTitleWithoutImage(){
	if($("div.panel-home").hasClass('titleWithoutImage')){
		setTimeout( function(){
			$('.home-card .titleWithoutImage').css("height","");
			var maxheighthomecard = [];
			$('.home-card .titleWithoutImage').each(function(){
				maxheighthomecard.push($(this).height());
			});
			$('.home-card .titleWithoutImage').height(Math.max.apply(Math,maxheighthomecard));
		},0);
	}
}

function fnTitleBelowImageForTwo(){
	if($("div.panel-home").hasClass('titleBelowImage')){
		setTimeout( function(){
			$('.home-card .titleBelowImage').css("height","");
			var maxheighthomecard = [];
			$('.home-card .titleBelowImage').each(function(){
				maxheighthomecard.push($(this).find('div.home-tile').height()+$(this).find('div.home-tile-content').height());
			});
			$('.home-card .titleBelowImage').height(Math.max.apply(Math,maxheighthomecard)+120);
		},0);
	}
}
/**
 * 
 */
if($("#tellusrequirement").val() !=""){
	var backgroundImage = $("#tellusrequirement").val();
	if(!(backgroundImage == undefined)){
		$('.tellusrequirementDiv').css({
			background:"url('"+backgroundImage+"') no-repeat scroll 0 0 / cover"
		});
	}
	fnGetStartDescrptionColor(".getstarted-wrap.tellusrequirementDiv .getstarted-fluid","tellusrequirementDescColor");
}

if($("#getintouch").val() !=""){
	var backgroundImage = $("#getintouch").val();
	if(!(backgroundImage == undefined)){
		$('.getintouchDiv').css({
			background:"url('"+backgroundImage+"') no-repeat scroll 0 0 / cover"
		});
	}
	fnGetStartDescrptionColor(".getstarted-wrap.getintouchDiv .getstarted-fluid","getintouchDescColor");
}

if($("#receivecallback").val() !=""){
	var backgroundImage = $("#receivecallback").val();
	if(!(backgroundImage == undefined)){
		$('.receivecallbackDiv').css({
			background:"url('"+backgroundImage+"') no-repeat scroll 0 0 / cover"
		});
	}
	fnGetStartDescrptionColor(".getstarted-wrap.receivecallbackDiv .getstarted-fluid","receivecallbackDescColor");
}

if($("#signgetstart").val() !=""){
	var backgroundImage = $("#signgetstart").val();
	if(!(backgroundImage == undefined)){
		$('.signgetstartDiv').css({
			background:"url('"+backgroundImage+"') no-repeat scroll 0 0 / cover"
		});
	}
	fnGetStartDescrptionColor(".getstarted-wrap.signgetstartDiv .getstarted-fluid","signgetstartDescColor");
}

if($("#signgetstart").val() ==""){
	fnGetStartDescrptionColor(".getstarted-wrap.signgetstartDiv .getstarted-fluid","signgetstartDescColor");
}

if($("#receivecallback").val() ==""){
	fnGetStartDescrptionColor(".getstarted-wrap.receivecallbackDiv .getstarted-fluid","receivecallbackDescColor");
}

if($("#getintouch").val() ==""){
	fnGetStartDescrptionColor(".getstarted-wrap.getintouchDiv .getstarted-fluid","getintouchDescColor");
}

if($("#tellusrequirement").val() ==""){
	fnGetStartDescrptionColor(".getstarted-wrap.tellusrequirementDiv .getstarted-fluid","tellusrequirementDescColor");
}
	
function fnGetStartDescrptionColor(classname,id,cond){
	$(classname+" > p").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val()
	});
	$(classname+" > p a").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val(),
		'text-decoration':'underline'
	});
	$(classname+" > ul").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val()
	});
	$(classname+" > ul a").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val(),
		'text-decoration':'underline'
	});
	$(classname+" > ol").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val()
	});
	$(classname+" > ol a").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val(),
		'text-decoration':'underline'
	});
}
	
$('.getstarted').slick({
  dots: false,
  infinite: false,
  speed: 300,
  slidesToShow: 4,
  slidesToScroll: 4,
  resize: true,
  variableWidth: true,
	responsive: [
	             {
	            	 breakpoint: 1024,
	            	 settings: "unslick"
	             },
	             {
	            	 breakpoint: 640,
	            	 settings: {
	            		 slidesToShow: 1,
	            		 slidesToScroll: 1,
	            		 arrows: false
	            	 }
	             }
             ]
});
$(window).resize(function() {
	$('.getstarted').slick('resize');
	checkWidth();
	fnGetstartedDivAlignment();
});

$(document).ready(function() {
	checkWidth();
	fnGetstartedDivAlignment();
});

function fnGetstartedDivAlignment() {
    setTimeout(function() {
        $("input:hidden[class='get-started-current-node']").each(function() {
            var currentNode = "#" + $(this).val();
            var maxheightgetstart = [];
            $(currentNode + '.getstarted-grid .getstarted-wrap').height(0);
            $(currentNode + '.getstarted-grid .getstarted-wrap').each(function() {
                maxheightgetstart.push($(this).find('.getstarted-fluid').height());
            });
            $(currentNode + '.getstarted-grid .getstarted-wrap').height(Math.max.apply(Math, maxheightgetstart) + 30);
        });
    }, 300);
}

function checkWidth(){
	/* tablet breakpoint */
	if ($(window).width() <= 939 && $(window).width() >= 640){
		if ($('.getstarted').hasClass("slick-initialized")) {
			$('.getstarted').slick('unslick');
    	}
	}else if ($(window).width() >= 940){
		/* desktop breakpoint */
		if ($('.getstarted').hasClass("slick-initialized")) {
			$('.getstarted').slick('unslick');
		}
		var checkWidthFlag =  ($(window).width() > 1199) ? true: false; 
		var cardCount =0;
		if($('.tellusrequirementDiv.getstarted-wrap .getstarted-title h3').html() != "" && $('.tellusrequirementDiv.getstarted-wrap .getstarted-title h3').html() != undefined){
			cardCount = 1 + cardCount;
		}
		if($('.getintouchDiv.getstarted-wrap .getstarted-title h3').html() != "" && $('.getintouchDiv.getstarted-wrap .getstarted-title h3').html() != undefined){
			cardCount = 1 + cardCount;
		}
		if($('.receivecallbackDiv.getstarted-wrap .getstarted-title h3').html() != "" && $('.receivecallbackDiv.getstarted-wrap .getstarted-title h3').html() != undefined){
			cardCount = 1 + cardCount;
		}
		if($('.signgetstartDiv.getstarted-wrap .getstarted-title h3').html() != "" && $('.signgetstartDiv.getstarted-wrap .getstarted-title h3').html() != undefined){
			cardCount = 1 + cardCount;
		}
		var classNameArray = $('.variable.getstarted-desktop > div');
		var arrayHideClass=[];
		for(var i=0;i < classNameArray.length;i++){
			var hideClass = $('.variable.getstarted-desktop > div')[i].className;
			if(hideClass.indexOf('hideclass') != -1)
				arrayHideClass.push(i+1);
		}
		for(var i=0;i<classNameArray.length;i++){
			if(cardCount == 1 || cardCount == 2){
				var className = classNameArray[i].className+"";
				var bootstrapClass = checkWidthFlag == true ? 'col-lg-6' :'col-md-6';
				if(!(className.trim().indexOf(bootstrapClass) !=-1)){
					$('.variable.getstarted-desktop > div').addClass(bootstrapClass).removeClass(className);
					break;
				}
			}
			if(cardCount == 3){
				var className = classNameArray[i].className+"";
				var bootstrapClass = checkWidthFlag == true ? 'col-lg-4' :'col-md-4';
				if(!(className.trim().indexOf(bootstrapClass) !=-1)){
					$('.variable.getstarted-desktop > div').addClass(bootstrapClass).removeClass(className);
					break;
				}
			}
			if(cardCount == 4){
				var className = classNameArray[i].className+"";
				var bootstrapClass = checkWidthFlag == true ? 'col-lg-3' :'col-md-3';
				if(!(className.trim().indexOf(bootstrapClass) !=-1)){
					$('.variable.getstarted-desktop > div').addClass(bootstrapClass).removeClass(className);
					break;
				}
			}
		}
		for(var i=0;i < arrayHideClass.length;i++){
			$('.variable.getstarted-desktop > div:nth-child('+(arrayHideClass[i])+')').addClass('hideclass')
	  	}
	}
}
$(document).ready((function(){ 
$(".otherbtn").on('change',function(){
		$("#plan-name-blk").show();
	});
	$(".carpo").on('change',function(){
		$("#plan-name-blk").hide();
		$("#planName").val("");
	});
	$(".phoneYes").on('change',function(){
		$("#device-option-list").show();
	});
	$(".phoneNo").on('change',function(){
		$("#device-option-list").hide();
		$("#deviceName").val("");
	});
	
/*	$(".likeNewNumber").on('click',function(){
		$(".activationBlock").show();
		$(".existaccBlock").hide();
	});
 
	 $(".oldSim").on('click',function(){
		$(".activationBlock").hide();
	    $(".existaccBlock").show();
	});*/
	 
	 $('input[name=needNewSim]').click(function() {
		if($(this).is(':checked')){
			$(this).val("Yes, i need a new SIM card"); 
		}else{
			$(this).val("Keep my SIM card");
		} 	 
	 });
 $(".phoneYes").click();    
 $(".franchise-success-blk").hide();
 $(".franchise-error-blk").hide();
 
 
 $("form[name='franchiseform'] #submit").click(function(e) {
     var dataObj = {};
     
     var form = $("form[name='franchiseform']");
    // var validator = form.data('validator');
     var fields = form.find('input');
     $( "#addressLine2" ).removeAttr( "required" );
     $( "#companyReference" ).removeAttr( "required" );
     $( "#billingReference" ).removeAttr( "required" );
     $( "#billaddresscompany" ).removeAttr( "required" );

     if (fields.valid()) {
	     fields.each(function () {
	    	 dataObj[this.name] = $(this).val();
	     });
	     dataObj["numberOption"] = $("input[name='numberOption']:checked").val();
	     dataObj["planSelection"] = $("input[name='planSelection']:checked").val();
	     dataObj["phoneOption"] = $("input[name='phoneOption']:checked").val();
	     submitFranchiseForm(dataObj);
     }else{
    	$( "#addressLine2" ).attr( "required" ,"");
        $( "#companyReference" ).attr( "required","" );
        $( "#billingReference" ).attr( "required" ,"");
        $( "#billaddresscompany" ).attr( "required","" );
     }
     e.preventDefault();
 });
 
 function submitFranchiseForm(dataObj) {
     $.ajax({
         dataType: 'html',
         type: "POST",
         url: "/bin/sparkdigital/form/franchise",
         contentType: "application/x-www-form-urlencoded",
         timeout: 3600,
         data: dataObj,
         success: function(data, textStatus, jqXHR){
        	 $(".franchise-form-blk").hide();
             $(".franchise-success-blk").show();
         },
         error: function(err){
        	 $(".franchise-form-blk").hide();
             $(".franchise-error-blk").show();
         },
         complete: function(){
         }
     });
 }
 
 $("form[name='franchiseform']").validate({
     debug: true,
     rules: {
    	 firstName: 'required',
    	 lastName: 'required',
    	 emailAddress: {
             required : true,
             email: true
         },
         contactNumber: 'required',
         company: 'required',
         addressLine1: 'required',
         suburb: 'required',
         town: 'required',
         postcode: 'required',
         planSelection:'required',
         planName: 'required',
         phoneOption: 'required',
         date: 'required'
     },
     messages: {
    	 firstName: 'Please enter your firstname',
    	 lastName: 'Please enter your lastname',
    	 emailAddress: {
             required : 'Please enter your email',
             email: 'Please enter valid email'
         },
         contactNumber: 'Please enter your contact number',
         company: 'Please enter your Company',
         addressLine1: 'Please enter your address',
         suburb: 'Please enter your Suburb',
         town: 'Please enter your City',
         postcode: 'Please enter your Post code',
         phoneOption:'Please select a phone option',
         planName: 'Please enter your Plan',
         numberOption: 'Please select an option',
         date: 'Please enter the activation date',
         deviceName: 'Please enter your preferred device'
     },
     errorPlacement: function (error, element) {
         error.appendTo($('#' + element.attr('id') + 'ErrorMessages'));
     },
     submitHandler: function (form) {
         return false;
     }
 });
})()
);
$(document).ready(function() {

	var clickedFilterArray = [];
	var data={};
	var hashmap = {};
	var queryParameterString = '';
	$('.search-holder input').val("");
	data["baseStoreValue"] = $('#baseStoreValue').val();
	var prevSearchText = '';
	setHashMapForFilter();
	
	//Unchecked all the filter input on page load-Mozilla Specific Fix
	$('.filter-list label input').removeAttr('checked');
	
	//Setting facet id for each tab and dynamically naming hashmap based on this id.
	function setHashMapForFilter(){
		$('.galleryFilter .filter-list h3').each(function(){
			var id = $(this).attr("id");
			hashmap[id] = id;
		});
	}
	
	// when clicked on reset all in selected filters, removing all the selected filters.
	$(document).on("click", "button.reset_all_filters, button.reset_all_filters_panel", function () {
		resetAll("resetAll");
		$( ".acc-pagination" ).show(); 
	});
	
	// onclick of close icon for each selected filter and removing them and updating the query parameters accordingly
	$('.device-preference-selected .preference-key-wrap').on("click",'.btn-filter-preference', function () {		
		var removeItem = $(this).find('span:first').text();
		var removeItemId = $(this).find('span:first').attr('id');
		$('.device-preference-selected .preference-key-wrap button').each(function(){
			if($(this).text().trim() === removeItem){
				$(this).remove();
			}
		});   
 
		$('.filter-wrap input[type="checkbox"].selected-filter').each(function(){
			if($(this).next().text().trim() === removeItem){
				$('.galleryFilter .filter-list h3').each(function(){
					hashmap[$(this).attr('id')] = hashmap[$(this).attr('id')].replace(':'+removeItemId,'');
				});
				$(this).removeClass('selected-filter');
				$(this).removeAttr('checked');
				$(this).css("content",'url("/etc/designs/sparkdigital/clientlib-site/img/unchecked.jpg")');
				updateQueryParameters();

			}
		});
		clickedFilterArray = $.grep(clickedFilterArray, function(value) {
			return value != removeItem;
		});
	});
	
	// function called to update query parameters.
	function updateQueryParameters(){
		queryParameterString='';
		$('.galleryFilter .filter-list h3').each(function(){
			if(hashmap[$(this).attr('id')] !== $(this).attr('id')){
				queryParameterString = queryParameterString +'::'+hashmap[$(this).attr('id')];
			}
		});

		if(queryParameterString.indexOf('::')==0){
			queryParameterString = queryParameterString.replace('::','');

		}

		if(queryParameterString ==''){
			$('.device-preference-selected').hide();
		}
		triggerAjaxDeviceGalleryFilter();
	}
	
    $('.search-holder input').keypress(function(event){
        if(event.which == 13){
        	//To prevent the page getting reloaded on press of "enter" key
        	//Also Page should be reloaded if the user deletes the searched text and click's on enter key
        	if(!($('.search-holder input').length && $('.search-holder input').val() == '')){
        		event.preventDefault();
        	}
        	$('.btn-filter-search').click();
        }
    });
	
	// Showing appropriate selected filters in selected filters section, and updates query parameters.
	$(document).on('click','.galleryFilter .filter-wrap span', function(){
		
		$('.device-preference-selected').show();
		var clickedFilter = $(this).text().trim();
		var clickedFilterId = $(this).attr("id");
		
		if(!($(this).prev('input[type="checkbox"]')).hasClass('selected-filter')){
			$(this).prev('input[type="checkbox"]').addClass('selected-filter');
			$(this).prev('input[type="checkbox"]').css("content",'url("/etc/designs/sparkdigital/clientlib-site/img/checked.jpg")');
			hashmap[$(this).closest('div.filter-list').find('h3').attr("id")]=hashmap[$(this).closest('div.filter-list').find('h3').attr("id")] +':'+clickedFilterId;
		}
		
		clickedFilterArray.push(clickedFilter);
		updateQueryParameters();
		

		var numArr = 0;
		for (var i = 0; i < clickedFilterArray.length; i++) {
			if (clickedFilterArray[i] === clickedFilter) {
				numArr++; 
			}
		}

		var selectedFiltersText = $('.device-preference-selected .preference-key-wrap').text().trim();
		var resetAll = '';
		if(selectedFiltersText.indexOf('Reset all') >= 0 && numArr <= 1){
			$('.reset_all_filters').remove();
		}

		if(numArr==1){
			$('.device-preference-selected .preference-key-wrap').append('<button type="button" class="btn-filter-preference sp-out-left-5">'+	
					'<span id="'+clickedFilterId+'" class="pull-left sp-in-left-12">'+clickedFilter+'</span>'+
					'<span class="toggle-close pull-right icon-close closeThisPreference"></span></button>');
			
			$('.device-preference-selected .preference-key-wrap').append('<button type="button" class="btn-plain btn-filter-reset purple sp-out-left-15 reset_all_filters">'+	
					'<span class="pull-left">	Reset all </span>'+
					'<span class="toggle-close pull-right sp-in-left-12 sp-in-right-12"></span></button>');

		}else{
			$('.device-preference-selected .preference-key-wrap').find('span[id="'+clickedFilterId+'"]').next('.closeThisPreference').click();
		}
		
	});
	
	// This trigger Ajax function is called, whenever user changes any of the filters.
	function triggerAjaxDeviceGalleryFilter(){
		var modeGallery = $("#modeGallery").val();
		if($('.journeyType').val()!=undefined)
		{
			data["journeyType"]=$('.journeyType').val();
		}
		data["filter"]=queryParameterString;
		data["modeGallery"] = modeGallery;
		var url="/bin/sparkdigital/devicegallery.json";
		deviceGalleryFilterAjax(data,url,"post");
	}

	//This is used to make an Ajax call, whenever user tries to modify selection in the dropdown for sorts
	$('.preference-list.sort-wrap fieldset').on('click', 'input[type="radio"] + label', function() {
		if($('.journeyType').val()!=undefined)
		{
			data["journeyType"]=$('.journeyType').val();
		}
		data["sort"]=$(this).prev('input[type="radio"]').attr('id');
		
		//Append the selected sort text to "Sort By" 
		var selectedSortPrefId = $(this).prev('input[type="radio"]').attr('id');
		var $selectedSortPrefLabel = $("label[for='"+selectedSortPrefId+"']");
		var selectedSortPrefText = $selectedSortPrefLabel.text();
		$(".gallerySortByText").html(selectedSortPrefText);
		
		var url="/bin/sparkdigital/devicegallery.json";
		deviceGalleryFilterAjax(data,url,"post");
	});

	// This is used to make an Ajax call, whenever user types text in search box and clicks the search button
	// While making a call to hyrbis the filters are reset and the call is made only if the text is not empty.
	$('.btn-filter-search').on('click', function() {
		if($('.search-holder input').length && 	$('.search-holder input').val() !== '' && prevSearchText !== $('.search-holder input').val()){
			if($('.journeyType').val()!=undefined)
			{
				data["journeyType"]=$('.journeyType').val();
			}
			prevSearchText = $('.search-holder input').val();
			resetAll("search");
			data["searchText"]=$('.search-holder input').val();
			var url="/bin/sparkdigital/devicegallery.json";
			deviceGalleryFilterAjax(data,url,"post");
		}else if($('.search-holder input').length && $('.search-holder input').val() == '' && prevSearchText !== ''){
			//Page should be reloaded if the user deletes the searched text and click's on search icon
			location.reload(!1);
		}
	});
	
	function resetAll(resetText){
		$('.device-preference-selected').hide();
		hashmap = {};
		setHashMapForFilter();
		queryParameterString = '';
		$('.filter-wrap input[type="checkbox"].selected-filter').each(function(){
			$(this).removeClass('selected-filter');
			$(this).css("content",'url("/etc/designs/sparkdigital/clientlib-site/img/unchecked.jpg")');
			$(this).prop('checked', false);
		});
		data["filter"] = queryParameterString;
		clickedFilterArray = [];
		if(resetText != "" && resetText == "resetAll"){
			triggerAjaxDeviceGalleryFilter();
		}
		$('.device-preference-selected .preference-key-wrap').children().remove();
	}
	
	//Ajax for filter panel
	function deviceGalleryFilterAjax(data, url, method){
		$.ajax({															
			type: method,
			dataType: 'json',				
			data: data,							
			url: url,
			success: function(data){
				getDeviceGalleryProducts(data.products,"sort");
				  if((data['moreItems'])=='false')
	              {
					$( ".acc-pagination" ).attr( "disabled", true ); 
		            $( ".acc-pagination" ).hide();
	               
	              }else {
	            	  $( ".acc-pagination" ).attr( "disabled", false ); 
	                  $( ".acc-pagination" ).show();  
	              }
			}
		});
	}
    $(".acc-pagination").on("click", function () {
        triggerLoadMoreAjax();   
    });         
   
    // This trigger Ajax function is called, whenever load more button is clicked
    function triggerLoadMoreAjax(){
      var currentPage = $(".currentPageClass").val();
      var modeGallery = $("#modeGallery").val();
      accessoryItems="more";
      data["path"] = currentPage;
      data["more"] = "next";  
      data["modeGallery"]=modeGallery;
      if($('.journeyType').val()!=undefined)
		{
			data["journeyType"]=$('.journeyType').val();
		}
      var url="/bin/sparkdigital/products/advancedfilter.json";
       accessoryPagination(data,url,"post");
    }  
    //Ajax for accessory pagination
    function accessoryPagination(data, url, method){
      $.ajax({															
          type: method,
          dataType: 'json',				
          data: data,							
          url: url,
          success: function(data){
      	  getDeviceGalleryProducts(data.products,"loadmore");
        	  if((data['moreItems'])=='false')
              {
               $( ".acc-pagination" ).attr( "disabled", true ); 
               $( ".acc-pagination" ).hide(); 
              }
        	      
          }  
      });  
}
	
});
$(document).ready(function() {

    var deviceGalleryJsonString = $('#deviceGalleryProductsJson').val();
    var devicegGalleryData = [];
    if (typeof deviceGalleryJsonString !== "undefined" && deviceGalleryJsonString!="") {
        devicegGalleryData = JSON.parse(deviceGalleryJsonString);
        $('#errorDeviceGallery').hide();
    }  
    else {  
       if($('#errorMessageDeviceGallery').val() =="") {
    	  var errorHtml ='<div class="container"> <div class="screen-title">'+
   		'<h4>Oops. There is a small glitch Please try after some time..</h4>'+
   		'</div></div><div class="clearfix"></div>';
    	}else {
    		var errorHtml ='<div class="container"> <div class="screen-title">'+
    		'<h4>'+$('#errorMessageDeviceGallery').val()+ '</h4>'+
    		'</div></div><div class="clearfix"></div>';	
    	}
    	 $('#errorDeviceGallery').append(errorHtml);  
    }
    if(devicegGalleryData.products !=undefined) {
    	getDeviceGalleryProducts(devicegGalleryData.products, "pageload");
    }
    // On click of each variant of phone, this function apply active class on the corresponding storage options
    $(document).on('click', '.overlay-outer .storage-selection input[type="radio"] + label.device-storage-label', function() {
        $(this).parent().siblings().removeClass('active')
        $(this).parent().addClass('active');
        var compareMap = getCampareMapFromCookie();
        var keys = Object.keys(compareMap);
        var deviceCode = $(this).parent().find('#devicecode').val();
        if ($.inArray(deviceCode, keys) != -1 & keys.length > 0) {
            $(this).closest('.overlay-inner').find('.prefer-remove').show();
            $(this).closest('.overlay-inner').find('.prefer-select').hide();
        } else {
            $(this).closest('.overlay-inner').find('.prefer-select').show();
            $(this).closest('.overlay-inner').find('.prefer-remove').hide();
        }
    });

    $('.device-gallery').on('click', 'button.prefer-select', function() {
        //if(($(this).parent()).find('.storage-selection').find('.active').find('#devicecode').val()!=undefined){
        addtopanel($(this).parent());
        // }
    });
    
    $('.device-gallery').on('click', 'button.prefer-remove', function() {
        $(this).hide();
        $(this).siblings('.prefer-select').show();
        removetopanel($(this).parent());
    });


    // On click of compare, constructing all the color options and memory options available for the product.
    $('.device-gallery').on("click", ".device-compare", function() {
        // Resetting the html in color and storage selection - So it will not append to the existing ones if second time the click is performed.
        $(this).siblings('.overlay-outer').find('div.color-selection').html('');
        $(this).siblings('.overlay-outer').find('div.storage-selection').html('');
        var compareMap = getCampareMapFromCookie();
        var colourHtmlAndStorage = getAllAvailableColoursAndStoragesForProduct($(this).siblings("input.productJSON").attr("id"));
        $(this).siblings('.overlay-outer').find('div.color-selection').append(colourHtmlAndStorage[0]);
        var prodStorageHtml = '';
        var storage = $(colourHtmlAndStorage[1]);
        
        storage.sort(function (a, b) {
        	var storage1 = parseInt(a);
        	var storage2 = parseInt(b);
        	
        	if(isNaN(storage1) || isNaN(storage2)){
        		return 0;
        	}
        	return storage1 - storage2;
        	
        });

        for (var i = 0; i < storage.length; i++) {
            prodStorageHtml = '<fieldset class="">' +
                '<input type="radio" name="devicestorage" id="storage' + [i] + '" value="' + storage[i] + '" class="storage-option device-storage' + [i] + '"/>' +
                '<label for="storage' + [i] + '" class="device-storage-label">' +
                '<span class="big-size">' + storage[i] + '</span>' +
                '</label>' +
                '</fieldset>';
                $(this).siblings('.overlay-outer').find('div.storage-selection').append(prodStorageHtml);
        }

        // Performing click on the first available color and first enabled and available memory option.
        $(this).siblings('.overlay-outer').find('div.color-selection input[type="radio"]:first + label.device-color-label').click();
        $(this).siblings('.overlay-outer').find('div.storage-selection fieldset:not(.disable):first input[type="radio"] + label.device-storage-label').click();
        $(this).siblings('.overlay-outer').find('.color-selection').find('fieldset').first().addClass('active');
        $(this).siblings('.overlay-outer').find('.storage-selection').find('fieldset').first().addClass('active');
        if ($(this).siblings('.overlay-outer').find('div.storage-selection fieldset').length <= 1 && $(this).siblings('.overlay-outer').find('div.color-selection fieldset').length <= 1) {
            /*$(this).siblings('.overlay-outer').hide();
        	// $(this).siblings(".btn-popup").prop('disabled', true);
        	 $(this).siblings('.overlay-outer').find('button.prefer-select').click();*/
            if ($(this).find('.toggle-close').is(':visible')) {
                $(this).siblings('.overlay-outer').hide();
                $(this).siblings('.overlay-outer').find('button.prefer-select').click();
                $(this).find('.toggle-close').hide();
                $(this).find('.toggle-compare').show();
                $(this).siblings('.device-card-ribbon').show();
                if (Object.keys(compareMap).length < 3) {
                    $(this).find('.toggle-compare').addClass('disable');
                    $(this).attr("disabled", "disabled");
                } else {
                    $(this).parent().find('[data-toggle="tooltip1"]').tooltip();
                }
            }
            /*
             if($(this).find('.toggle-compare').is(':visible')){
             $(this).siblings('.overlay-outer').hide();
        	 $(this).siblings('.overlay-outer').find('button.prefer-remove').click();
             }*/
        }
    });

    // On click of each color, this function shows the corresponding storage options with its price/GST information for the particular product.
    $(document).on('click', '.overlay-outer .color-selection input[type="radio"] + label.device-color-label', function() {
        var targetStorageList = getTargetsArrayForProduct($(this).siblings('input').val(), $(this).siblings('input').data("prod-code"));
        var prodStorageHtml = '';
        var storageSelection = $(this).closest('.color-selection').siblings('div.storage-selection');
        $(storageSelection).find('fieldset input').next('label').find('span.storage-price').remove();
        $(storageSelection).find('fieldset input').next('label').find('span.gstIncluded').remove();
        //showing all memory variants initially (hiding of invalid variants will happen based on the 'disable' class in the below logic)
        $(storageSelection).find('.disable').show();
        $(storageSelection).find('fieldset input').parent().addClass('disable');

        for (var i = 0; i < $(targetStorageList).length; i++) {
            var targetStorage = targetStorageList[i];
            $(storageSelection).find('fieldset input[value="' + targetStorage.size + '"]').next('label').append('<span class="storage-price">' + targetStorage.price.formattedValue + '</span>');
            //$(storageSelection).parent().find('#devicecode').attr("value",targetStorage.code);
            // If GST excluded is true, then we will append the txt (excl GST).
            if (targetStorage.gstExcluded == true) {
                $(storageSelection).find('fieldset input[value="' + targetStorage.size + '"]').next('label').append('<span class="gstIncluded">excl GST</span>');
            }
            var inputHidden = $(storageSelection).find('fieldset input[value="' + targetStorage.size + '"]').next().next();
            if (inputHidden.length == 0) {
                $(storageSelection).find('fieldset input[value="' + targetStorage.size + '"]').parent().append('<input type="hidden" id="devicecode" value="' + targetStorage.code + '">');
            } else {
                $(inputHidden).remove();
                $(storageSelection).find('fieldset input[value="' + targetStorage.size + '"]').parent().append('<input type="hidden" id="devicecode" value="' + targetStorage.code + '">');
            }
            $(storageSelection).find('fieldset input[value="' + targetStorage.size + '"]').parent().removeClass('disable');
        }
        $(storageSelection).find('fieldset:not(.disable):first input[type="radio"] + label.device-storage-label').click();
        $(storageSelection).find('.disable').hide();
        $(this).parent().siblings().removeClass('active');
        $(this).parent().addClass('active');
        //for Remove button functionality
        var compareMap = getCampareMapFromCookie();
        var keys = Object.keys(compareMap);
        var deviceCode = $(this).closest('.overlay-inner').find('.storage-selection').find('.active').find('#devicecode').val();
        deviceCode=deviceCode==undefined?$(this).closest('.overlay-inner').find('.color-selection').find('.active').find('#devicecode').val():deviceCode;
        if ($.inArray(deviceCode, keys) != -1 & keys.length > 0) {
            $(this).closest('.overlay-inner').find('.prefer-remove').show();
            $(this).closest('.overlay-inner').find('.prefer-select').hide();
        } else {
            $(this).closest('.overlay-inner').find('.prefer-select').show();
            $(this).closest('.overlay-inner').find('.prefer-remove').hide();
        }
    });


    //Gets all the available colors for a particular product on click of compare.
    function getAllAvailableColoursAndStoragesForProduct(prodCode) {
        var prodColourHtml = '';
        var prodColourArr = [];
        var prodStorageArr = [];
        var colourHtmlAndStorageArr = [];

        var clickedProdReferences = getParsedProductJSONProductReferences(prodCode);

        if (clickedProdReferences.length) {
            for (var i = 0; i < $(clickedProdReferences).length; i++) {
                var target = clickedProdReferences[i]["target"];

                if (target["productColour"] !== undefined) {
                    var colourCode = target["productColour"].code;
                    var colourName = target["productColour"].name;
                    var colourHexCode = target["productColour"].hexCode;

                    // Displays the color fieldset only if it is not constructed in the previous iteration.
                    if (prodColourHtml != undefined && $.inArray(colourCode, prodColourArr) != undefined && $.inArray(colourCode, prodColourArr) == -1) {
                        prodColourHtml = prodColourHtml + '<fieldset>' +
                            '<input type="radio" name="devicecolor" data-prod-code = "' + prodCode + '" id="clr' + [i] + '" value="' + colourCode + '" class="color-option device-color' + [i] + ' ' + colourCode + '"/>' +
                            '<label for="clr' + [i] + '" class= "device-color-label" style="background-color:' + colourHexCode + '">' +
                            '<span>' + colourName + '</span>' +
                            '</label>' +
                            '<input type="hidden" id="devicecode" value="' + target.code + '">'+
                            '</fieldset>';
                        prodColourArr.push(colourCode);
                    }
                }
                var storageSize = '';
                if (target.size !== undefined && target.size.length && target.size !== '') {
                    storageSize = target.size;
                }

                if (prodColourHtml != undefined && storageSize !== '' && $.inArray(storageSize, prodStorageArr) != undefined && $.inArray(storageSize, prodStorageArr) == -1) {
                    prodStorageArr.push(storageSize);
                }
            }
        }

        colourHtmlAndStorageArr.push(prodColourHtml);
        colourHtmlAndStorageArr.push(prodStorageArr);
        return colourHtmlAndStorageArr;
    }

    //This function returns the list of targets with particular product color and product code.
    function getTargetsArrayForProduct(color, prodCode) {
        var targetListArr = [];
        var clickedProdReferences = getParsedProductJSONProductReferences(prodCode);
        if (clickedProdReferences.length) {
            for (var i = 0; i < $(clickedProdReferences).length; i++) {
                var target = clickedProdReferences[i]["target"];
                if (target["productColour"].code == color) {
                    targetListArr.push(target);

                }
            }
        }
        return targetListArr;
    }

    // This function returns the product references of the parsed JSON for the product 
    function getParsedProductJSONProductReferences(productCode) {
        var clickedProd = $('#' + productCode).val();
        var clickedProdJSON = [];

        if (typeof decodeURIComponent(clickedProd) !== "undefined") {
            clickedProdJSON = JSON.parse(decodeURIComponent(clickedProd));
        }
        var clickedProdReferences = clickedProdJSON["productReferences"];

        return clickedProdReferences;
    }



});

   
// Constructing the device gallery html on page load - this can be used in Ajax call on load more as well.
function getDeviceGalleryProducts(deviceGalleryProducts, query) {
	if(query!='loadmore') {
		$('#deviceGalleryProducts').html('');
	}
	 $( ".acc-pagination" ).attr( "disabled", false ); 
    for (var i = 0; i < $(deviceGalleryProducts).length; i++) {
        var deviceGalleryProduct = deviceGalleryProducts[i];
        var deviceBoxOnLoad1 = '';
        var deviceBoxOnLoad2 = '';
        var deviceBoxOnLoad3 = '';
        var JSONForEachProduct = JSON.stringify(deviceGalleryProduct);
        deviceBoxOnLoad1 = '<div class="col-xs-12 col-sm-6 col-lg-4"><div class="device-box panel-theme sp-in-20 text-center pos-rel wow fadeInUp">';
        var productBadge = '';

        if (deviceGalleryProduct.productBadge !== undefined && deviceGalleryProduct.productBadge.name !== undefined
        		&& deviceGalleryProduct.productBadge.name !== "") {
            productBadge = '<div class="device-card-ribbon" style="display: block;">' +
                '<div class="device-card-ribbon-body">' + deviceGalleryProduct.productBadge.name + '</div>' +
                '</div>';
        }

        // Adding all the prices into an array, which will be used to find the minimum price available for all the targets for this product.
        var prodReferences = deviceGalleryProduct["productReferences"];
        var targetForThisProductCode = '';
        var targetPricesArr = [];
        if (prodReferences.length) {
            for (var j = 0; j < $(prodReferences).length; j++) {
                var target = prodReferences[j]["target"];
                if (target.code !== undefined && deviceGalleryProduct.code == target.code) {
                    targetForThisProductCode = target;
                }
                if (target["price"] !== undefined) {
                    targetPricesArr.push(target["price"].value);
                }
            }
        }

        // Check if the price for this particular products target is miminum or not in all available prices.
        var isTargetForThisProductCodeMinimum = false;
        if (Math.min.apply(Math, targetPricesArr) == targetForThisProductCode["price"].value) {
            isTargetForThisProductCodeMinimum = true;
        }

        if ($('.deviceType').val().toLowerCase().indexOf("devices") >= 0) {
            deviceBoxOnLoad2 = '<button class="btn-popup device-compare pull-right" data-toggle="tooltip1" data-placement="top" title="" data-original-title="Maximum 3 devices are allowed for comparison">' +
                '<span class="toggle-compare"><span>Compare</span><span class="icon-add-comp"><i class="icon-add-f"></i></span></span>' +
                '<span class="toggle-close"><span>Close</span><span class="icon-remove-comp"><i class="icon-close"></i></span></span>' +
                '</button>' +
                '<div class="device-default-block">' +
                '<div class="product-img">' +
                '<img src="' + deviceGalleryProduct.deviceImagePath + '" alt="Mobile Device image" />' +
                '</div>' +
                '<fieldset>' +
                '<p class="product-name text-theme1">' + deviceGalleryProduct.productGroupCode + '</p>' +
                '<div class="product-price-group">' +
                '<span class="text-default">';
           
                deviceBoxOnLoad2 = deviceGalleryProduct.comparable == true ? deviceBoxOnLoad2 : "" +
                    '<div class="device-default-block">' +
                    '<div class="product-img">' +
                    '<img src="' + deviceGalleryProduct.deviceImagePath + '" alt="Mobile Device image" />' +
                    '</div>' +
                    '<fieldset>' +
                    '<p class="product-name text-theme1">' + deviceGalleryProduct.productGroupCode + '</p>' +
                    '<div class="product-price-group">' +
                    '<span class="text-default">';
            
        } else {
            deviceBoxOnLoad2 = '<div class="device-default-block">' +
                '<div class="product-img">' +
                '<img src="' + deviceGalleryProduct.deviceImagePath + '" alt="Mobile Device image" />' +
                '</div>' +
                '<fieldset>' +
                '<p class="product-name text-theme1">' + deviceGalleryProduct.productGroupCode + '</p>' +
                '<div class="product-price-group">' +
                '<span class="text-default">';
        }
        var fromTxtForThisProduct = '';
        if (isTargetForThisProductCodeMinimum == true && targetPricesArr.length > 1) {
            fromTxtForThisProduct = '<span class="product-price-label">From</span>';
        }

        var priceForThisProduct = '';
        priceForThisProduct = '<span class="product-price">' + targetForThisProductCode["price"].formattedValue + '</span>';

        var exclGSTForThisProduct = '';
        if (targetForThisProductCode.gstExcluded == true) {
            exclGSTForThisProduct = '</span><span class="product-price-tax">excl GST</span>';
        }

        deviceBoxOnLoad3 = '</div>' +
            '</fieldset>' +
            '<a class="link-arrow view-details" href="' + deviceGalleryProduct.deviceDetailUrl +'?' +'deviceCode='+deviceGalleryProduct.code + '" title="View" data-toggle="modal"><span>View</span><span class="link-arrow-icon"><i class="icon-arrow-right"></i></span></a>' +
            '</div>' +
            '<input type="hidden" id="' + deviceGalleryProduct.code + '" class ="productJSON" value="' + encodeURIComponent(JSONForEachProduct) + '"/>';

        var overlayBox = '';
        overlayBox = '<div class="overlay-outer"><div class="device-selection-overlay">' +
            '<div class="overlay-inner">' +
            '<p class="product-name text-theme1">' + deviceGalleryProduct.productGroupCode + '</p>';
        var colourSelection = '';
        colourSelection = '<div class="color-selection"><div class="clearfix"></div></div>';

        var storageSelection = '';
        storageSelection = '<div class="storage-selection"><div class="clearfix"></div></div><div class="clearfix"></div>';

        var overlaySelectButton = '';
        overlaySelectButton =
            '<button type="button" data-toggle="tooltip" data-placement="top" title="" class="btn-device-select btn-primary sp-in-15 wd-222 sp-out-top-40 prefer-select" data-original-title="Maximum 3 devices are allowed for comparison">' +
            '<span>' +
            'Select' +
            '</span>' +
            '</button>' +
            '<button type="button" class="btn-device-select btn-secondary sp-in-15 wd-222 sp-out-top-40 prefer-remove">' +
            '<span class="">' +
            'Remove' +
            '</span>' +
            '</button>' +
            '<div class="clearfix"> </div>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '</div>' +
            '</div>' ;
            

        var completeStructure = deviceBoxOnLoad1 + productBadge + deviceBoxOnLoad2 + fromTxtForThisProduct + " " + priceForThisProduct + " " + exclGSTForThisProduct + deviceBoxOnLoad3 + overlayBox + colourSelection + storageSelection + overlaySelectButton;
        if (query === 'pageload') {
            if (productBadge == "") {
                $('#deviceGalleryProducts').append($(completeStructure));
            } else {
                $('#deviceGalleryProducts').prepend($(completeStructure));
            }
        } else {
            $('#deviceGalleryProducts').html();
            $('#deviceGalleryProducts').append($(completeStructure));
        }
    }
}

$(document).ready(function() {
    //compare-panel.js
    checkAddToCompareOnLoad();
    
    //Slick for Compare Panel tab and Mobile View
    var sp = window.matchMedia("(max-width: 939px)");
    if (sp.matches) {
        $(".selectphone").slick({
            dots: false,
            infinite: false,
            variableWidth: true
        });
    }
    
    $('.full-compare').on('click', function() {

        var redirectCPURL = $("input[name=comparePage]").val();
        //var deviceCodes = document.getElementsByName("devicecode");
        var compareMap = getCampareMapFromCookie();
        var deviceCodes = Object.keys(compareMap);
        var deviceCount = 0;
        if (redirectCPURL != undefined && redirectCPURL != "") {
            if (deviceCodes != undefined) {
                redirectCPURL = redirectCPURL + '?';
                for (i = 0; i < deviceCodes.length; i++) {
                    if (deviceCodes[i] != "") {
                        redirectCPURL = redirectCPURL + "device" + i + "=" + deviceCodes[i] + "&";
                        deviceCount++;
                    }
                }

            }

            if (deviceCount > 0) {
                window.location = redirectCPURL.slice(0, -1);
            }
        }
    });

    $('.btn-compare-clear').on('click', function() {
        $.removeCookie('compareMap', {
            path: '/'
        });
        $('.comparePanelDesktop').children().remove();
        $('.comparePanelTablet').children().remove();
        $('.comparePanelMobile').children().remove();
        $('.device-compare-panel').hide();
        $('[data-toggle="tooltip"]').tooltip('destroy');
        $('[data-toggle="tooltip1"]').tooltip('destroy');
        $('#deviceGalleryProducts .device-box').each(function(index) {
            if ($(this).find('.overlay-outer').find('div.storage-selection fieldset').length <= 1 && $(this).find('.overlay-outer').find('div.color-selection fieldset').length <= 1) {
                $(this).find('.toggle-compare').removeClass('disable');
                $(this).find('.device-compare').removeAttr("disabled");
            }
            $(this).find('.overlay-inner').find('.prefer-remove').hide();
            $(this).find('.overlay-inner').find('.prefer-select').show();
        });

    });


    $('.compare-panel-inner').on('click', '.dev-remove', function() {
    	var deviceCode = "";
        deviceCode = $(this).hasClass("desktop-remove") ? $(this).parent().parent().find('input').attr("value") : deviceCode;
        deviceCode = $(this).hasClass("tablet-remove") ? $(this).closest('.tab-blk-box').attr('id') : deviceCode;
        deviceCode = $(this).hasClass("mobile-remove") ? $(this).parent().parent().attr('id') : deviceCode;
        var compareMap = getCampareMapFromCookie();
        var keys = Object.keys(compareMap);
        delete compareMap[deviceCode];
        $.cookie("compareMap", JSON.stringify(compareMap), {
            path: '/'
        });
        $('[data-toggle="tooltip"]').tooltip('destroy');
        $('[data-toggle="tooltip1"]').tooltip('destroy');
        $(this).closest('#' + deviceCode).remove();
        if (keys.length == 1) {
            $('.device-compare-panel').hide();
        }

        $('#deviceGalleryProducts .device-box').each(function(index) {
            if ($(this).find('.overlay-outer').find('div.storage-selection fieldset').length <= 1 && $(this).find('.overlay-outer').find('div.color-selection fieldset').length <= 1) {
                if (deviceCode == $(this).find('.productJSON').attr('id')) {
                    $(this).find('.toggle-compare').removeClass('disable');
                    $(this).find('.device-compare').removeAttr("disabled");
                }
            }
        });

        $('#deviceGalleryProducts .device-box').each(function(index) {
            var code = $(this).find('.overlay-outer').find('.storage-selection').find('.active').find('#devicecode').val();
            code=$(this).find('.storage-selection').children().length==0 && $(this).find('.color-selection').children().length>0?$(this).find('.overlay-outer').find('.color-selection').find('.active').find('#devicecode').val():code;
            if (code == deviceCode) {
                $(this).find('.overlay-inner').find('.prefer-remove').hide();
                $(this).find('.overlay-inner').find('.prefer-select').show();
            }
        });
    });

});

function removetopanel(device) {
    var compareMap = getCampareMapFromCookie();
    var keys = Object.keys(compareMap);
    if (device != undefined) {
        var deviceCode = $(device).find('.storage-selection').find('.active').find('#devicecode').val();
        if (deviceCode === undefined) {
            deviceCode = $(device).closest('.overlay-outer').siblings('.productJSON').attr('id');
        }
        deviceCode=$(device).find('.storage-selection').children().length==0?$(device).find('.color-selection').find('.active').find('#devicecode').val():deviceCode;
    }
    if ($.inArray(deviceCode, keys) != -1 && keys.length > 0) {
        $('.compare-panel-inner').find('#' + deviceCode).remove();

        delete compareMap[deviceCode];
        $.cookie("compareMap", JSON.stringify(compareMap), {
            path: '/'
        });
        $('[data-toggle="tooltip"]').tooltip('destroy');
        $('[data-toggle="tooltip1"]').tooltip('destroy');
        if (keys.length == 1) {
            $('.device-compare-panel').hide();
        }
    }

}


function addtopanel(device) {
    //add device to panel code goes here. Read device name , code, colour, selected varient,lowest price, tax info.
    var compareMap = getCampareMapFromCookie();

    if ($('section.device-compare-panel').val() != undefined) {
        if (device != undefined) {
            var deviceCode = $(device).find('.storage-selection').find('.active').find('#devicecode').val();
            var deviceName = $(device).find('.product-name').html();
            var deviceColor = $(device).find('.color-selection').find('.active').find('span').html();
            var storage = $(device).find('.storage-selection').find('.active').find('.big-size').html();
            var price = $(device).find('.storage-selection').find('.active').find('.storage-price').html();
            var gstIncluded = $(device).find('.storage-selection').find('.active').find('.gstIncluded').html();
            var imgURL= $(device).closest('.overlay-outer').siblings('.device-default-block').find('.product-img').find('img').attr('src');
            var viewDetailURL= $(device).closest('.overlay-outer').siblings('.device-default-block').find('a').attr('href');

            if (deviceCode === undefined) {
                deviceCode = $(device).closest('.overlay-outer').siblings('.productJSON').attr('id');
                price = $(device).closest('.overlay-outer').siblings('.device-default-block').find('fieldset').find('.product-price').html();
                gstIncluded = $(device).closest('.overlay-outer').siblings('.device-default-block').find('fieldset').find('.product-price-tax').html();

            }
            deviceCode=$(device).find('.storage-selection').children().length==0 && $(device).find('.color-selection').children().length>0?$(device).find('.color-selection').find('.active').find('#devicecode').val():deviceCode;
            deviceColor = deviceColor == undefined ? "" : deviceColor;
            storage = storage == undefined ? "" : storage;
            gstIncluded = gstIncluded == undefined ? "" : gstIncluded;

            var deviceTpPanel = '<div id="' + deviceCode + '" class="col-md-4 col-lg-4 br-rt"><input type="hidden" name="devicecode" value="' + deviceCode + '">' +
                '<div class="spacer-comp-list pos-rel"><div class="dev-remove desktop-remove"><i class="icon-close"></i></div>' +
                '<div class="compare-panel-data"><div class="device-compare-name purple">	' + deviceName + ' </div>' +
                '<div class="sp-out-bot-15"><span class="device-compare-color "> ' + deviceColor + ' </span> ' +
                ' <span class="device-compare-size "> ' + storage + ' </span></div>' +
                '<div class="product-price-group"><div class="text-default">' +
                '<span class="product-price"> ' + price + '</span><span class="product-price-tax"> ' + gstIncluded + '</span></div>' +
                '</div></div></div></div>';

             var devicetabPanel =
                '<div id="' + deviceCode + '" class="pos-rel tab-blk-box phone-options col-md-4 col-lg-4">' +
                '<div class="dev-remove tablet-remove"><i class="icon-close"></i></div>' +
                '<div class="compare-panel-data left-blk">' +
                '<div class="device-compare-name purple"> ' + deviceName + ' </div>' +
                '<div class="sp-out-bot-15">' +
                '<span class="device-compare-color ">  ' + deviceColor + ' </span>' +
                '<span class="device-compare-size "> ' + storage + ' </span>' +
                '</div>' +
                '<div class="product-price-group sp-out-bot-15">' +
                '<div class="text-default">' +
                '<span class="product-price">' + price + '</span>' +
                '</div>' +
                '<div class="product-price-tax">  ' + gstIncluded + '</div>' +
                '</div>' +
                '</div>' +
                '<div class="right-blk">' +
                '</div>' +
                '<div class="clearfix"></div>' +
                '</div></div>';

            var devicemobPanel =
                '<div id="' + deviceCode + '" class="pos-rel tab-blk-box phone-options-m col-md-4 col-lg-4">' +
                '<button type="button" class="btn-plain btn-popup btn-pos">' +
                '<div class="dev-remove mobile-remove"><i class="icon-close"></i></div>' +
                '</button>' +
                '<div class="right-blk-m">' +
                '</div>' +
                '<span class="device-name">' + deviceName + '</span>' +
                '</div>';


            if (deviceCode != undefined) {
                if (Object.keys(compareMap).length < 3) {
                    compareMap[deviceCode] = deviceName + '@' + deviceColor + '@' + storage + '@' + price + '@' + gstIncluded + '@' + imgURL + '@'
                            + viewDetailURL;
                    $('.comparePanelDesktop').append(deviceTpPanel);
                    $('.comparePanelTablet').append(devicetabPanel);
                    $('.comparePanelMobile').append(devicemobPanel);
                    // adding 'h-280' class, so that the compare panel will be
                    // visible in UI
                    $(".device-compare-panel").addClass('h-280');
                    $(".device-compare-panel").removeClass('h-0');
                    $('.device-compare-panel').show();
                    if (window.screen.width >= 320 && window.screen.width < 939) {
                        location.reload();
                    }
                    $(device).find('.prefer-select').hide();
                    $(device).find('.prefer-remove').show();
                    $('[data-toggle="tooltip"]').tooltip('destroy');
                    $.cookie("compareMap", JSON.stringify(compareMap), {
                        path : '/'
                    });
                } else {
                    $('[data-toggle="tooltip"]').tooltip();
                }
            }


        }

    }
}


function getCampareMapFromCookie() {
    var compareMapJson = $.cookie("compareMap");
    var compareMap = {};
    if (compareMapJson != null && compareMapJson.length != 0) {
        compareMap = jQuery.parseJSON(compareMapJson);
    }
    return compareMap;
}

function updateCompareFooter(compareMap) {
    var keys = Object.keys(compareMap);
    if (keys.length == 0) {
        $('.device-compare-panel').hide();
    } else {
        for (var i = 0; i < 3; i++) {
            if (keys[i] != undefined) {
                var deviceCode = keys[i];
                var deviceName = compareMap[keys[i]].split('@')[0];
                var deviceColor = compareMap[keys[i]].split('@')[1];
                var storage = compareMap[keys[i]].split('@')[2];
                var price = compareMap[keys[i]].split('@')[3];
                var gstIncluded = compareMap[keys[i]].split('@')[4];

                var deviceTpPanel = '<div id="' + deviceCode + '" class="col-md-4 col-lg-4 br-rt"><input type="hidden" name="devicecode" value="' + deviceCode + '">' +
                    '<div class="spacer-comp-list pos-rel"><div class="dev-remove desktop-remove"><i class="icon-close"></i></div>' +
                    '<div class="compare-panel-data"><div class="device-compare-name purple">	' + deviceName + ' </div>' +
                    '<div class="sp-out-bot-15"><span class="device-compare-color "> ' + deviceColor + ' </span> ' +
                    ' <span class="device-compare-size "> ' + storage + ' </span></div>' +
                    '<div class="product-price-group"><div class="text-default">' +
                    '<span class="product-price"> ' + price + '</span><span class="product-price-tax"> ' + gstIncluded + '</span></div>' +
                    '</div></div></div></div>';

                var devicetabPanel =
                '<div id="' + deviceCode + '" class="pos-rel tab-blk-box phone-options col-md-4 col-lg-4">' +
                '<div class="dev-remove tablet-remove"><i class="icon-close"></i></div>' +
                '<div class="compare-panel-data left-blk">' +
                '<div class="device-compare-name purple"> ' + deviceName + ' </div>' +
                '<div class="sp-out-bot-15">' +
                '<span class="device-compare-color ">  ' + deviceColor + ' </span>' +
                '<span class="device-compare-size "> ' + storage + ' </span>' +
                '</div>' +
                '<div class="product-price-group sp-out-bot-15">' +
                '<div class="text-default">' +
                '<span class="product-price">' + price + '</span>' +
                '</div>' +
                '<div class="product-price-tax">  ' + gstIncluded + '</div>' +
                '</div>' +
                '</div>' +
                '<div class="right-blk">' +
                '</div>' +
                '<div class="clearfix"></div>' +
                '</div></div>';

                var devicemobPanel =

                    '<div id="' + deviceCode + '" class="pos-rel tab-blk-box phone-options-m col-md-4 col-lg-4">' +
                    '<button type="button" class="btn-plain btn-popup btn-pos">' +
                    '<div class="dev-remove mobile-remove"><i class="icon-close"></i></div>' +
                    '</button>' +
                    '<div class="right-blk-m">' +
                    '</div>' +
                    '<span class="device-name">' + deviceName + '</span>' +
                    '</div>';

                $('.comparePanelDesktop').append(deviceTpPanel);
                $('.comparePanelTablet').append(devicetabPanel);
                $('.comparePanelMobile').append(devicemobPanel);
                $(".device-compare-panel").addClass('h-280');
                $('.device-compare-panel').show();
            }
        }
    }
}

function checkAddToCompareOnLoad() {
    $('.device-compare-panel').hide();
    var compareMap = getCampareMapFromCookie();
    var keys = Object.keys(compareMap);
    updateCompareFooter(compareMap);
    
  //For Compare Button UI if device is already there in compare panel
    $('#deviceGalleryProducts .device-box').each(function(index) {
          if ($(this).find('.overlay-outer').find('div.storage-selection fieldset').length <= 1 && $(this).find('.overlay-outer').find('div.color-selection fieldset').length <= 1) {
				var code =  $(this).find('.productJSON').attr('id');
              code=$(this).find('.overlay-outer').find('.storage-selection').children().length==0 && $(this).find('.overlay-outer').find('.color-selection').children().length>0?$(this).find('.overlay-outer').find('.color-selection').find('.active').find('#devicecode').val():code;
				for (var i = 0; i < 3; i++) {
          		if (keys[i] != undefined && keys[i] == code) {
              			$(this).find('.toggle-compare').addClass('disable');
              			$(this).attr("disabled", "disabled");
                   }
              }
          }
      });
}
$(document).on('ready', function() {
    alterGetStartedDiv();
    var mq = window.matchMedia("(max-width: 939px)");
    var index = 0;
    if (mq.matches) {
        $(".compdevice").slick({
            dots: false,
            infinite: false,
            variableWidth: true,
            responsive: [{
                breakpoint: 939,
                settings: {
                    arrows: false,
                    slidesToShow: 1,
                    slidesToScroll: 1
                }
            }, {
                breakpoint: 639,
                settings: {
                    arrows: false,
                    slidesToShow: 1,
                    slidesToScroll: 1

                }
            }]
        });
    }
    $(".device-compare-panel").addClass('h-0');
    
    $('.btn-compare-panel').on('click', function() {
        $('.toggle-hide').toggle();
        $('.toggle-show').toggleClass('toggle-block');
        $(this).toggleClass('toggle-width');
        $('.compare-panel-container').toggle();
        //$('.btn-compare-panel').parent().parent().toggleClass('h-280');
        $('.btn-compare-panel').parent().parent().toggleClass('h-35');
        $('.btn-compare-panel').parent().parent().parent().toggleClass('h-35');
        $('.btn-compare-panel').parent().parent().removeClass('h-0 h-280');
        $('.btn-compare-panel').parent().parent().parent().removeClass('h-0 h-280');
        //$('.btn-compare-panel').parent().parent().css("height","0"));
    });

});
/*
//Adding Class on the basic of text size of specification
$('.spec-list li').each(function(index, value) {
    if ($(this).text().length > 14 && $(this).text().length < 23) {
        var index = $(this).index() + 1;
        $(".device-box .comp-lst li:nth-child(" + index + ")").addClass('med-text');
    }
    if ($(this).text().length > 23) {
        var index = $(this).index() + 1;
        $(".device-box .comp-lst li:nth-child(" + index + ")").addClass('lar-text');
    }

});
*/

//Adjusting the height of classification and features on the basisi of max height
function alterGetStartedDiv() {
    setTimeout(
        function() {
            var maxheight = [];
            $('.spec-list li').each(function() {
                maxheight.push($(this).height());
            });
            $('.device-box .comp-lst li').each(function() {
                maxheight.push($(this).height());
            });
            var max = Math.max.apply(Math, maxheight)
            $('.spec-list li').height(max);
            $(".device-box .comp-lst li").height(max);


        }, 500);

    //setting the compare product Image of the comapre product
    var compareMap = getCampareMapFromCookie();
    var keys = Object.keys(compareMap);
    var imgURL = "";
   	var deviceDetailUrl = "";
    var deviceName ="";
    $('.cmp-blocks').each(function(index) {
        var position=parseInt($(this).find('#position').val()) + 1;
        var deviceCode = $(this).find('#deviceid').attr("value");

        for (var i = 0; i < 3; i++) {
            if (keys[i] != undefined && (keys[i] == deviceCode)) {
                var imgURL = compareMap[keys[i]].split('@')[5];
                var deviceDetailUrl = compareMap[keys[i]].split('@')[6];
                var deviceName = compareMap[keys[i]].split('@')[0];
            }
        }

            if(position==1){
                imgURL = imgURL!="undefined"?compareMap[keys[0]].split('@')[5]:imgURL;
                deviceDetailUrl = deviceDetailUrl!="undefined"?compareMap[keys[0]].split('@')[6]:deviceDetailUrl;
                deviceName = deviceName!="undefined"?compareMap[keys[0]].split('@')[0]:deviceName;

            }
            if(position==2){
                  imgURL = imgURL!="undefined"?compareMap[keys[1]].split('@')[5]:imgURL;
                deviceDetailUrl = deviceDetailUrl!="undefined"?compareMap[keys[1]].split('@')[6]:deviceDetailUrl;
                deviceName = deviceName!="undefined"?compareMap[keys[1]].split('@')[0]:deviceName;
            }

            if(position==3){
                imgURL = imgURL!="undefined"?compareMap[keys[2]].split('@')[5]:imgURL;
                deviceDetailUrl = deviceDetailUrl!=undefined?compareMap[keys[2]].split('@')[6]:deviceDetailUrl;
                deviceName = deviceName!=undefined?compareMap[keys[2]].split('@')[0]:deviceName;
            }
             $(this).find('.product-img').find('img').attr('src', imgURL);
             $(this).find('.product-name').html(deviceName);
             $(this).find('.firstViewDetails').attr('href', deviceDetailUrl);



    });
}


//On click of available colors/variant drop down-displaying the corresponding device details
$(".dropdown-menu .otherOptions").click(function(event) {
    var url = window.location.href;
    var separators = ['[\\\?,\\\&]device[0-2]='];
    var arr = url.split(new RegExp(separators.join('|'), 'g'));
    var position = parseInt($(this).parent().find('#position').val()) + 1;
    var newCode = $(this).find('#devicecode').val();
    var removeIndex = arr.indexOf(newCode);
    var redirectCPURL = arr[0] + '?';
    var temp = '';
    if (removeIndex > 0) {
        arr.splice(position, 1);
    } else {
        arr[position] = newCode;
    }
    for (i = 0; i <= arr.length - 2; i++) {
        temp = temp + "device" + i + "=" + (arr[i + 1] != undefined ? arr[i + 1] : '') + "&";
    }
    redirectCPURL = redirectCPURL + temp;
    window.location = redirectCPURL.slice(0, -1);
});
//On click of available close button removing the selected device
$(".device-compare .btn-popup").click(function(event) {
    var url = window.location.href;
    var compareMap = getCampareMapFromCookie();
    var deviceCode = $(this).parent().parent().parent().find('#deviceid').attr("value");
    var separators = ['[\\\?,\\\&]device[0-2]='];
    var arr = url.split(new RegExp(separators.join('|'), 'g'));
    var position = parseInt($(this).parent().parent().parent().find('#position').val()) + 1;
    delete compareMap[deviceCode];
    $.cookie("compareMap", JSON.stringify(compareMap), {
        path: '/'
    });
    // updateCompareFooter(compareMap);
    var redirectCPURL = arr[0] + '?';
    var temp = '';
    arr.splice(position, 1);
    for (i = 0; i <= arr.length - 2; i++) {
        temp = temp + "device" + i + "=" + (arr[i + 1] != undefined ? arr[i + 1] : '') + "&";
    }
    redirectCPURL = redirectCPURL + temp;
    window.location = redirectCPURL.slice(0, -1);
});
$(document).ready(function() {
    $("#contactus-form .dropdown-menu li a").click(function() {
        $(this).parents(".dropdown").find('.btn').html(' <label class="input-label in-lab-added">' + $(this).text() + '</label> <span class="icon-arrow-down pull-right"></span>');
        $(this).parents(".dropdown").find('.btn').val($(this).data('value')).addClass('drop-val');
    });
    /*$("input").focusin(function(){
    $(this).css("background-color", "#FFFFCC");
    });*/
    $("input").focusout(function() {
        if ($(this).val != null) {
            $(this).addClass('drop-val');
        } else {
            $(this).removeClass('drop-val');
        }
    });

    /* ****Validation****** */
    $("#nearestcityErrorMessages").hide();
    $("#firstnameErrorMessages").hide();
    $("#lastnameErrorMessages").hide();
    $("#emailErrorMessages").hide();
    $("#phoneErrorMessages").hide();
    $("#companyErrorMessages").hide();
    $("#companysizeErrorMessages").hide();
    $("#messageErrorMessages").hide();
    
/*    $("#dropdownMenu1").focusout(function() {
         if (nearestCity != '' && nearestCity !== undefined) {
        	$(this).parent().removeClass("dropdown-has-error");
        	$("#nearestcityErrorMessages").hide();
        }
         else{
        	 $("#dropdownMenu1").parent().addClass("dropdown-has-error");
             $("#dropdownMenu1").focusin();
             $("#nearestcityErrorMessages").show().addClass("has-error");
         }
         
         
    });
    
    $("#dropdownMenu2").focusout(function() {
        if (nearestCity != '' && nearestCity !== undefined) {
	       	$(this).parent().removeClass("dropdown-has-error");
	       	$("#companysizeErrorMessages").hide();
       }       
        else{
        	$("#dropdownMenu2").parent().addClass("dropdown-has-error");
            $("#dropdownMenu2").focusin();
            $("#companysizeErrorMessages").show().addClass("has-error");
        }
   });*/
    
    $("#firstname").focusout(function() {
        if ($(this).val() != "" && $(this).val() != $("#lastname").val()) {
            $(this).parent().removeClass("has-error");
            $("#firstnameErrorMessages").hide();
        }
        else{
        	 $("#firstname").parent().addClass("has-error");
             $("#firstname").focusin();
             $("#firstnameErrorMessages").show().addClass("has-error");
        }
    });
    
    $("#lastname").focusout(function() {
        if ($(this).val() != "" && $(this).val() != $("#firstname").val()) {
            $(this).parent().removeClass("has-error");
            $("#lastnameErrorMessages").hide();
        }
        else{
        	$("#lastname").parent().addClass("has-error");
            $("#lastname").focusin();
            $("#lastnameErrorMessages").show().addClass("has-error");
        }
    });

    $("#email").focusout(function() {
        if ($(this).val() != "" && isValidEmailAddress($(this).val())) {
            $(this).parent().removeClass("has-error");
            $("#emailErrorMessages").hide();
        }
        else{
            $("#email").parent().addClass("has-error");
            $("#email").focusin();
            $("#emailErrorMessages").show().addClass("has-error");
        }
        
    });

    
    $("#company").focusout(function() {
        if ($(this).val() != "") {
            $(this).parent().removeClass("has-error");
            $("#companyErrorMessages").hide();
        }
        else{
        	$("#company").parent().addClass("has-error");
            $("#company").focusin();
            $("#companyErrorMessages").show().addClass("has-error");
        }
    });
    
    

    function isValidEmailAddress(emailAddress) {
	    var pattern = /^([a-z\d!#$%&'*+\-\/=?^_`{|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+(\.[a-z\d!#$%&'*+\-\/=?^_`{|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)*|"((([ \t]*\r\n)?[ \t]+)?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*(([ \t]*\r\n)?[ \t]+)?")@(([a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|[a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF][a-z\d\-._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]*[a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])\.)+([a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|[a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF][a-z\d\-._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]*[a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])\.?$/i;
	    return pattern.test(emailAddress);
	}
    
    $(".contact-success-blk").hide();
    $(".contact-error-blk").hide();
    var locationAndContactDetails = $('#locationAndContactDetails').val();
    var nearestCity;
    var companySize;

    $("#companySize li").each(function(index) {
        $(this).hide();
    });
    if (locationAndContactDetails !== undefined) {
        var locationAndContactDetailsData = JSON.parse(locationAndContactDetails);
        $('#nearestCity ul li a').on('click', function() {
            nearestCity = $(this).text();
            var contactNumber = locationAndContactDetailsData[nearestCity];
            $('#contactNumber a').text(contactNumber);
            $('#contactNumber a').attr("href","tel:"+contactNumber);
            /*if (nearestCity === 'Auckland' || nearestCity === 'Hamilton' || nearestCity === 'Wellington' || nearestCity === 'Nelson' || nearestCity === 'Christchurch') {
                $("#companySize li").each(function(index) {

                    if ($(this).text().indexOf('30') > -1) {
                        $(this).show();
                    } else {
                        $(this).hide();
                    }
                });
            } else {*/
                $("#companySize li").each(function(index) {
                    if ($(this).text().indexOf('100') > -1) {
                        $(this).show();
                    } else {
                        $(this).hide();
                    }
                });
            //}
            
            $("#dropdownMenu1").parent().removeClass("dropdown-has-error");
        	$("#nearestcityErrorMessages").hide();
        	$("#dropdownMenu2 label").html("Company Size").removeClass("in-lab-added");
        	companySize ="";
        });
    }

    var companySizeValues = $('#companySizeValues').val();
    var thisFormHasError;

    if (companySizeValues !== undefined) {
        var companySizeValuesData = JSON.parse(companySizeValues);
        $('#companySize ul li a').on('click', function() {
            var selectedCompanySize = $(this).text();
            companySize = companySizeValuesData[selectedCompanySize];
            $("#dropdownMenu2").parent().removeClass("dropdown-has-error");
        	$("#companysizeErrorMessages").hide();
        });
    }

    var referrerPageTitle=top.document.title;
    var referrerPageUrl=top.window.location.href;
    
    $('#contactus-form').submit(function(e) {
    	e.preventDefault();
	    validateForm();
	    if (thisFormHasError){
	    	return;
	    }
	    
    	if (nearestCity != '' && nearestCity !== undefined) {
            $('#00N20000001FsFA').attr({
                name: '00N20000001FsFA',
                value: nearestCity
            });
        }
    	

        if (companySize != '' && companySize !== undefined) {
            $('#employees').attr({
                name: 'employees',
                value: companySize
            });
        }
        
        
        if (referrerPageTitle != '' && referrerPageTitle !== undefined) {
            $('#00N20000002NceE').attr({
                name: '00N20000002NceE',
                value: referrerPageTitle
            });
        }
        
        
		var data = $("#contactus-form :input").serialize();
	    submitContactUsForm(data);
	    
    });
    
    function validateForm(){
    	thisFormHasError=false;
    	validateListvalues();
    	validateTextvalues();
    	validateEmailaddress();
    }
    
    function validateListvalues(){
    	if (nearestCity == '' || nearestCity === undefined) {
         
    		$("#dropdownMenu1").parent().addClass("dropdown-has-error");
            $("#dropdownMenu1").focusin();
            $("#nearestcityErrorMessages").show().addClass("has-error");
    		thisFormHasError=true;
    	}else{
    		$("#dropdownMenu1").parent().removeClass("dropdown-has-error");
        	$("#nearestcityErrorMessages").hide();
    	}
    	
    	if (companySize == '' || companySize === undefined) {
        	$("#dropdownMenu2").parent().addClass("dropdown-has-error");
            $("#dropdownMenu2").focusin();
            $("#companysizeErrorMessages").show().addClass("has-error");
    		thisFormHasError=true;
    	}else{
    		$("#dropdownMenu2").parent().removeClass("dropdown-has-error");
        	$("#companysizeErrorMessages").hide();
    	}
   }
    
    function validateTextvalues(){
    	if ($("#firstname").val() == "" || $("#firstname").val() == $("#lastname").val()) {
            $("#firstname").parent().addClass("has-error");
            $("#firstname").focusin();
            $("#firstnameErrorMessages").show().addClass("has-error");
			thisFormHasError=true;
        }else{
        	$("#firstname").parent().removeClass("has-error");
            $("#firstnameErrorMessages").hide();
        }
    	
    	if ($("#lastname").val() == "" || $("#firstname").val() == $("#lastname").val()) {
            $("#lastname").parent().addClass("has-error");
            $("#lastname").focusin();
            $("#lastnameErrorMessages").show().addClass("has-error");
			thisFormHasError=true;
        }else{
        	$("#lastname").parent().removeClass("has-error");
            $("#lastnameErrorMessages").hide();
        }
    	
    	if ($("#company").val() == "") {
            $("#company").parent().addClass("has-error");
            $("#company").focusin();
            $("#companyErrorMessages").show().addClass("has-error");
			thisFormHasError=true;
        }else{
        	$("#company").parent().removeClass("has-error");
            $("#companyErrorMessages").hide();
        }
    	   
    	
    }
    
    function validateEmailaddress(){
    	if ($("#email").val() == "" || !isValidEmailAddress($("#email").val())) {
            $("#email").parent().addClass("has-error");
            $("#email").focusin();
            $("#emailErrorMessages").show().addClass("has-error");
			thisFormHasError=true;
        }  
    	else{
    		$("#email").parent().removeClass("has-error");
            $("#emailErrorMessages").hide();
    	}
    }
   // $("#messagetextarea").attr("placeholder",getPlaceholderText(window.parent.window.location.href,window.parent.document.title));
    $("#messagetextarea").attr("placeholder",getPlaceholderText(referrerPageUrl,referrerPageTitle));
    
    function getPlaceholderText(pageUrl,pageTitle){
    	var customMessageFlag = false;
    	if(pageUrl.indexOf("guide") > -1 || pageUrl.indexOf("solutions") > -1 ){
    		customMessageFlag = true;
    	}
        if (customMessageFlag){
        	return "I would like to enquire about "+pageTitle;
        }
        else
            return "I would like to enquire about...";
    }
    
    function submitContactUsForm(data){

		var contactUsFormAction = $( '#contactus-form' ).attr('action');
        $.ajax({
      		url:contactUsFormAction,
     		type:'post',
      		data:data,
      		dataType:'html',
            success: function () {
                		console.info("Success!!");
                		$(".contact-form-blk").hide();
            			$('.cust-pop-sd iframe', window.parent.document).addClass('msg-sucess-error');
                		$(".contact-success-blk").show();

    				 },
            error: function (xhr, status, errorThrown ) {
		            	console.info("Error!!");
		            	if (status == 200){
		            		$(".contact-form-blk").hide();
                            $('.cust-pop-sd iframe', window.parent.document).addClass('msg-sucess-error');
	            			$(".contact-success-blk").show();
		            	}
		            	else{
		            		$(".contact-form-blk").hide();
                            $('.cust-pop-sd iframe', window.parent.document).addClass('msg-sucess-error');
			    			$(".contact-error-blk").show();
		            	}
		    			
     				}
    	});  

    }
});


	

/**
 * 
 */
if($("#newCustImg").val() !=""){
	var backgroundImage = $("#newCustImg").val();
	if(!(backgroundImage == undefined)){
		$('.newCustImgDiv').css({
			"background":"url('"+backgroundImage+"') no-repeat scroll 0 0 / cover"
		});
	}
	fnDescrptionColor(".newCustImgDiv .cat-get-spacer","newCustDescColor");
}

if($("#newCustImg").val() ==""){
	$('.newCustImgDiv').css({
		background:"#fff !important"
	});
	fnDescrptionColor(".newCustImgDiv .cat-get-spacer","newCustDescColor");
}

if($("#exstCustImg").val() !=""){
	var backgroundImage = $("#exstCustImg").val();
	if(!(backgroundImage == undefined)){
		$('.exstCustImgDiv').css({
			"background":"url('"+backgroundImage+"') no-repeat scroll 0 0 / cover"
		});
	}
	fnDescrptionColor(".exstCustImgDiv .cat-get-spacer","exstCustDescColor");
}

if($("#exstCustImg").val() ==""){
	$('.exstCustImgDiv').css({
		background:"#ffffff"
	});
	fnDescrptionColor(".exstCustImgDiv .cat-get-spacer","exstCustDescColor");
}

function fnDescrptionColor(classname,id,cond){
	$(classname+" > p").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val()
	});
	$(classname+" > ul").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val()
	});
	$(classname+" > ol").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val()
	});
	$(classname+" a.fontcolor").css({
		color:$("#"+id).val() =="none" ? "#6f6f72" : $("#"+id).val()
	});
}

$(window).resize(function(){
    $('.cat-getstarted-block').height("auto");
	alterCategoryDiv();
});

$(document).ready(function() {
	alterCategoryDiv();
});

function alterCategoryDiv(){
	setTimeout(function(){
	if ($(window).width() <= 639) {
		$('.cat-getstarted-block').css({"height":"auto"});
	}
    if ($(window).width() >= 640){

		var maxheight = [];
		$('.cat-getstarted-block .cat-get-spacer').css("height","");
		$('.cat-getstarted-block .cat-get-spacer').each(function(){
			maxheight.push($(this).height());
		});
		$('.cat-getstarted-block').height(Math.max.apply(Math,maxheight)+35);
	}},500)
}
/*
 * File: iframeResizer.js
 * Desc: Force iframes to size to content.
 * Requires: iframeResizer.contentWindow.js to be loaded into the target frame.
 * Doc: https://github.com/davidjbradshaw/iframe-resizer
 * Author: David J. Bradshaw - dave@bradshaw.net
 * Contributor: Jure Mav - jure.mav@gmail.com
 * Contributor: Reed Dadoune - reed@dadoune.com
 */

// eslint-disable-next-line sonarjs/cognitive-complexity, no-shadow-restricted-names
;(function(undefined) {
  if (typeof window === 'undefined') return // don't run for server side render

  var count = 0,
    logEnabled = false,
    hiddenCheckEnabled = false,
    msgHeader = 'message',
    msgHeaderLen = msgHeader.length,
    msgId = '[iFrameSizer]', // Must match iframe msg ID
    msgIdLen = msgId.length,
    pagePosition = null,
    requestAnimationFrame = window.requestAnimationFrame,
    resetRequiredMethods = {
      max: 1,
      scroll: 1,
      bodyScroll: 1,
      documentElementScroll: 1
    },
    settings = {},
    timer = null,
    defaults = {
      autoResize: true,
      bodyBackground: null,
      bodyMargin: null,
      bodyMarginV1: 8,
      bodyPadding: null,
      checkOrigin: true,
      inPageLinks: false,
      enablePublicMethods: true,
      heightCalculationMethod: 'bodyOffset',
      id: 'iFrameResizer',
      interval: 32,
      log: false,
      maxHeight: Infinity,
      maxWidth: Infinity,
      minHeight: 0,
      minWidth: 0,
      resizeFrom: 'parent',
      scrolling: false,
      sizeHeight: true,
      sizeWidth: false,
      warningTimeout: 5000,
      tolerance: 0,
      widthCalculationMethod: 'scroll',
      onClosed: function() {},
      onInit: function() {},
      onMessage: function() {
        warn('onMessage function not defined')
      },
      onResized: function() {},
      onScroll: function() {
        return true
      }
    }

  function getMutationObserver() {
    return (
      window.MutationObserver ||
      window.WebKitMutationObserver ||
      window.MozMutationObserver
    )
  }

  function addEventListener(el, evt, func) {
    el.addEventListener(evt, func, false)
  }

  function removeEventListener(el, evt, func) {
    el.removeEventListener(evt, func, false)
  }

  function setupRequestAnimationFrame() {
    var vendors = ['moz', 'webkit', 'o', 'ms']
    var x

    // Remove vendor prefixing if prefixed and break early if not
    for (x = 0; x < vendors.length && !requestAnimationFrame; x += 1) {
      requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']
    }

    if (!requestAnimationFrame) {
      log('setup', 'RequestAnimationFrame not supported')
    }
  }

  function getMyID(iframeId) {
    var retStr = 'Host page: ' + iframeId

    if (window.top !== window.self) {
      if (window.parentIFrame && window.parentIFrame.getId) {
        retStr = window.parentIFrame.getId() + ': ' + iframeId
      } else {
        retStr = 'Nested host page: ' + iframeId
      }
    }

    return retStr
  }

  function formatLogHeader(iframeId) {
    return msgId + '[' + getMyID(iframeId) + ']'
  }

  function isLogEnabled(iframeId) {
    return settings[iframeId] ? settings[iframeId].log : logEnabled
  }

  function log(iframeId, msg) {
    output('log', iframeId, msg, isLogEnabled(iframeId))
  }

  function info(iframeId, msg) {
    output('info', iframeId, msg, isLogEnabled(iframeId))
  }

  function warn(iframeId, msg) {
    output('warn', iframeId, msg, true)
  }

  function output(type, iframeId, msg, enabled) {
    if (true === enabled && 'object' === typeof window.console) {
      // eslint-disable-next-line no-console
      console[type](formatLogHeader(iframeId), msg)
    }
  }

  function iFrameListener(event) {
    function resizeIFrame() {
      function resize() {
        setSize(messageData)
        setPagePosition(iframeId)
        on('onResized', messageData)
      }

      ensureInRange('Height')
      ensureInRange('Width')

      syncResize(resize, messageData, 'init')
    }

    function processMsg() {
      var data = msg.substr(msgIdLen).split(':')

      return {
        iframe: settings[data[0]] && settings[data[0]].iframe,
        id: data[0],
        height: data[1],
        width: data[2],
        type: data[3]
      }
    }

    function ensureInRange(Dimension) {
      var max = Number(settings[iframeId]['max' + Dimension]),
        min = Number(settings[iframeId]['min' + Dimension]),
        dimension = Dimension.toLowerCase(),
        size = Number(messageData[dimension])

      log(iframeId, 'Checking ' + dimension + ' is in range ' + min + '-' + max)

      if (size < min) {
        size = min
        log(iframeId, 'Set ' + dimension + ' to min value')
      }

      if (size > max) {
        size = max
        log(iframeId, 'Set ' + dimension + ' to max value')
      }

      messageData[dimension] = '' + size
    }

    function isMessageFromIFrame() {
      function checkAllowedOrigin() {
        function checkList() {
          var i = 0,
            retCode = false

          log(
            iframeId,
            'Checking connection is from allowed list of origins: ' +
              checkOrigin
          )

          for (; i < checkOrigin.length; i++) {
            if (checkOrigin[i] === origin) {
              retCode = true
              break
            }
          }
          return retCode
        }

        function checkSingle() {
          var remoteHost = settings[iframeId] && settings[iframeId].remoteHost
          log(iframeId, 'Checking connection is from: ' + remoteHost)
          return origin === remoteHost
        }

        return checkOrigin.constructor === Array ? checkList() : checkSingle()
      }

      var origin = event.origin,
        checkOrigin = settings[iframeId] && settings[iframeId].checkOrigin

      if (checkOrigin && '' + origin !== 'null' && !checkAllowedOrigin()) {
        throw new Error(
          'Unexpected message received from: ' +
            origin +
            ' for ' +
            messageData.iframe.id +
            '. Message was: ' +
            event.data +
            '. This error can be disabled by setting the checkOrigin: false option or by providing of array of trusted domains.'
        )
      }

      return true
    }

    function isMessageForUs() {
      return (
        msgId === ('' + msg).substr(0, msgIdLen) &&
        msg.substr(msgIdLen).split(':')[0] in settings
      ) // ''+Protects against non-string msg
    }

    function isMessageFromMetaParent() {
      // Test if this message is from a parent above us. This is an ugly test, however, updating
      // the message format would break backwards compatibity.
      var retCode = messageData.type in { true: 1, false: 1, undefined: 1 }

      if (retCode) {
        log(iframeId, 'Ignoring init message from meta parent page')
      }

      return retCode
    }

    function getMsgBody(offset) {
      return msg.substr(msg.indexOf(':') + msgHeaderLen + offset)
    }

    function forwardMsgFromIFrame(msgBody) {
      log(
        iframeId,
        'onMessage passed: {iframe: ' +
          messageData.iframe.id +
          ', message: ' +
          msgBody +
          '}'
      )
      on('onMessage', {
        iframe: messageData.iframe,
        message: JSON.parse(msgBody)
      })
      log(iframeId, '--')
    }

    function getPageInfo() {
      var bodyPosition = document.body.getBoundingClientRect(),
        iFramePosition = messageData.iframe.getBoundingClientRect()

      return JSON.stringify({
        iframeHeight: iFramePosition.height,
        iframeWidth: iFramePosition.width,
        clientHeight: Math.max(
          document.documentElement.clientHeight,
          window.innerHeight || 0
        ),
        clientWidth: Math.max(
          document.documentElement.clientWidth,
          window.innerWidth || 0
        ),
        offsetTop: parseInt(iFramePosition.top - bodyPosition.top, 10),
        offsetLeft: parseInt(iFramePosition.left - bodyPosition.left, 10),
        scrollTop: window.pageYOffset,
        scrollLeft: window.pageXOffset,
        documentHeight: document.documentElement.clientHeight,
        documentWidth: document.documentElement.clientWidth,
        windowHeight: window.innerHeight,
        windowWidth: window.innerWidth
      })
    }

    function sendPageInfoToIframe(iframe, iframeId) {
      function debouncedTrigger() {
        trigger('Send Page Info', 'pageInfo:' + getPageInfo(), iframe, iframeId)
      }
      debounceFrameEvents(debouncedTrigger, 32, iframeId)
    }

    function startPageInfoMonitor() {
      function setListener(type, func) {
        function sendPageInfo() {
          if (settings[id]) {
            sendPageInfoToIframe(settings[id].iframe, id)
          } else {
            stop()
          }
        }

        ;['scroll', 'resize'].forEach(function(evt) {
          log(id, type + evt + ' listener for sendPageInfo')
          func(window, evt, sendPageInfo)
        })
      }

      function stop() {
        setListener('Remove ', removeEventListener)
      }

      function start() {
        setListener('Add ', addEventListener)
      }

      var id = iframeId // Create locally scoped copy of iFrame ID

      start()

      if (settings[id]) {
        settings[id].stopPageInfo = stop
      }
    }

    function stopPageInfoMonitor() {
      if (settings[iframeId] && settings[iframeId].stopPageInfo) {
        settings[iframeId].stopPageInfo()
        delete settings[iframeId].stopPageInfo
      }
    }

    function checkIFrameExists() {
      var retBool = true

      if (null === messageData.iframe) {
        warn(iframeId, 'IFrame (' + messageData.id + ') not found')
        retBool = false
      }
      return retBool
    }

    function getElementPosition(target) {
      var iFramePosition = target.getBoundingClientRect()

      getPagePosition(iframeId)

      return {
        x: Math.floor(Number(iFramePosition.left) + Number(pagePosition.x)),
        y: Math.floor(Number(iFramePosition.top) + Number(pagePosition.y))
      }
    }

    function scrollRequestFromChild(addOffset) {
      /* istanbul ignore next */ // Not testable in Karma
      function reposition() {
        pagePosition = newPosition
        scrollTo()
        log(iframeId, '--')
      }

      function calcOffset() {
        return {
          x: Number(messageData.width) + offset.x,
          y: Number(messageData.height) + offset.y
        }
      }

      function scrollParent() {
        if (window.parentIFrame) {
          window.parentIFrame['scrollTo' + (addOffset ? 'Offset' : '')](
            newPosition.x,
            newPosition.y
          )
        } else {
          warn(
            iframeId,
            'Unable to scroll to requested position, window.parentIFrame not found'
          )
        }
      }

      var offset = addOffset
          ? getElementPosition(messageData.iframe)
          : { x: 0, y: 0 },
        newPosition = calcOffset()

      log(
        iframeId,
        'Reposition requested from iFrame (offset x:' +
          offset.x +
          ' y:' +
          offset.y +
          ')'
      )

      if (window.top !== window.self) {
        scrollParent()
      } else {
        reposition()
      }
    }

    function scrollTo() {
      if (false !== on('onScroll', pagePosition)) {
        setPagePosition(iframeId)
      } else {
        unsetPagePosition()
      }
    }

    function findTarget(location) {
      function jumpToTarget() {
        var jumpPosition = getElementPosition(target)

        log(
          iframeId,
          'Moving to in page link (#' +
            hash +
            ') at x: ' +
            jumpPosition.x +
            ' y: ' +
            jumpPosition.y
        )
        pagePosition = {
          x: jumpPosition.x,
          y: jumpPosition.y
        }

        scrollTo()
        log(iframeId, '--')
      }

      function jumpToParent() {
        if (window.parentIFrame) {
          window.parentIFrame.moveToAnchor(hash)
        } else {
          log(
            iframeId,
            'In page link #' +
              hash +
              ' not found and window.parentIFrame not found'
          )
        }
      }

      var hash = location.split('#')[1] || '',
        hashData = decodeURIComponent(hash),
        target =
          document.getElementById(hashData) ||
          document.getElementsByName(hashData)[0]

      if (target) {
        jumpToTarget()
      } else if (window.top !== window.self) {
        jumpToParent()
      } else {
        log(iframeId, 'In page link #' + hash + ' not found')
      }
    }

    function on(funcName, val) {
      return chkEvent(iframeId, funcName, val)
    }

    function actionMsg() {
      if (settings[iframeId] && settings[iframeId].firstRun) firstRun()

      switch (messageData.type) {
        case 'close':
          if (settings[iframeId].closeRequeston)
            chkEvent(iframeId, 'onCloseRequest', settings[iframeId].iframe)
          else closeIFrame(messageData.iframe)
          break

        case 'message':
          forwardMsgFromIFrame(getMsgBody(6))
          break

        case 'scrollTo':
          scrollRequestFromChild(false)
          break

        case 'scrollToOffset':
          scrollRequestFromChild(true)
          break

        case 'pageInfo':
          sendPageInfoToIframe(
            settings[iframeId] && settings[iframeId].iframe,
            iframeId
          )
          startPageInfoMonitor()
          break

        case 'pageInfoStop':
          stopPageInfoMonitor()
          break

        case 'inPageLink':
          findTarget(getMsgBody(9))
          break

        case 'reset':
          resetIFrame(messageData)
          break

        case 'init':
          resizeIFrame()
          on('onInit', messageData.iframe)
          break

        default:
          resizeIFrame()
      }
    }

    function hasSettings(iframeId) {
      var retBool = true

      if (!settings[iframeId]) {
        retBool = false
        warn(
          messageData.type +
            ' No settings for ' +
            iframeId +
            '. Message was: ' +
            msg
        )
      }

      return retBool
    }

    function iFrameReadyMsgReceived() {
      // eslint-disable-next-line no-restricted-syntax, guard-for-in
      for (var iframeId in settings) {
        trigger(
          'iFrame requested init',
          createOutgoingMsg(iframeId),
          document.getElementById(iframeId),
          iframeId
        )
      }
    }

    function firstRun() {
      if (settings[iframeId]) {
        settings[iframeId].firstRun = false
      }
    }

    var msg = event.data,
      messageData = {},
      iframeId = null

    if ('[iFrameResizerChild]Ready' === msg) {
      iFrameReadyMsgReceived()
    } else if (isMessageForUs()) {
      messageData = processMsg()
      iframeId = messageData.id
      if (settings[iframeId]) {
        settings[iframeId].loaded = true
      }

      if (!isMessageFromMetaParent() && hasSettings(iframeId)) {
        log(iframeId, 'Received: ' + msg)

        if (checkIFrameExists() && isMessageFromIFrame()) {
          actionMsg()
        }
      }
    } else {
      info(iframeId, 'Ignored: ' + msg)
    }
  }

  function chkEvent(iframeId, funcName, val) {
    var func = null,
      retVal = null

    if (settings[iframeId]) {
      func = settings[iframeId][funcName]

      if ('function' === typeof func) {
        retVal = func(val)
      } else {
        throw new TypeError(
          funcName + ' on iFrame[' + iframeId + '] is not a function'
        )
      }
    }

    return retVal
  }

  function removeIframeListeners(iframe) {
    var iframeId = iframe.id
    delete settings[iframeId]
  }

  function closeIFrame(iframe) {
    var iframeId = iframe.id
    log(iframeId, 'Removing iFrame: ' + iframeId)

    try {
      // Catch race condition error with React
      if (iframe.parentNode) {
        iframe.parentNode.removeChild(iframe)
      }
    } catch (error) {
      warn(error)
    }

    chkEvent(iframeId, 'onClosed', iframeId)
    log(iframeId, '--')
    removeIframeListeners(iframe)
  }

  function getPagePosition(iframeId) {
    if (null === pagePosition) {
      pagePosition = {
        x:
          window.pageXOffset !== undefined
            ? window.pageXOffset
            : document.documentElement.scrollLeft,
        y:
          window.pageYOffset !== undefined
            ? window.pageYOffset
            : document.documentElement.scrollTop
      }
      log(
        iframeId,
        'Get page position: ' + pagePosition.x + ',' + pagePosition.y
      )
    }
  }

  function setPagePosition(iframeId) {
    if (null !== pagePosition) {
      window.scrollTo(pagePosition.x, pagePosition.y)
      log(
        iframeId,
        'Set page position: ' + pagePosition.x + ',' + pagePosition.y
      )
      unsetPagePosition()
    }
  }

  function unsetPagePosition() {
    pagePosition = null
  }

  function resetIFrame(messageData) {
    function reset() {
      setSize(messageData)
      trigger('reset', 'reset', messageData.iframe, messageData.id)
    }

    log(
      messageData.id,
      'Size reset requested by ' +
        ('init' === messageData.type ? 'host page' : 'iFrame')
    )
    getPagePosition(messageData.id)
    syncResize(reset, messageData, 'reset')
  }

  function setSize(messageData) {
    function setDimension(dimension) {
      if (!messageData.id) {
        log('undefined', 'messageData id not set')
        return
      }
      messageData.iframe.style[dimension] = messageData[dimension] + 'px'
      log(
        messageData.id,
        'IFrame (' +
          iframeId +
          ') ' +
          dimension +
          ' set to ' +
          messageData[dimension] +
          'px'
      )
    }

    function chkZero(dimension) {
      // FireFox sets dimension of hidden iFrames to zero.
      // So if we detect that set up an event to check for
      // when iFrame becomes visible.

      /* istanbul ignore next */ // Not testable in PhantomJS
      if (!hiddenCheckEnabled && '0' === messageData[dimension]) {
        hiddenCheckEnabled = true
        log(iframeId, 'Hidden iFrame detected, creating visibility listener')
        fixHiddenIFrames()
      }
    }

    function processDimension(dimension) {
      setDimension(dimension)
      chkZero(dimension)
    }

    var iframeId = messageData.iframe.id

    if (settings[iframeId]) {
      if (settings[iframeId].sizeHeight) {
        processDimension('height')
      }
      if (settings[iframeId].sizeWidth) {
        processDimension('width')
      }
    }
  }

  function syncResize(func, messageData, doNotSync) {
    /* istanbul ignore if */ // Not testable in PhantomJS
    if (doNotSync !== messageData.type && requestAnimationFrame) {
      log(messageData.id, 'Requesting animation frame')
      requestAnimationFrame(func)
    } else {
      func()
    }
  }

  function trigger(calleeMsg, msg, iframe, id, noResponseWarning) {
    function postMessageToIFrame() {
      var target = settings[id] && settings[id].targetOrigin
      log(
        id,
        '[' +
          calleeMsg +
          '] Sending msg to iframe[' +
          id +
          '] (' +
          msg +
          ') targetOrigin: ' +
          target
      )
      iframe.contentWindow.postMessage(msgId + msg, target)
    }

    function iFrameNotFound() {
      warn(id, '[' + calleeMsg + '] IFrame(' + id + ') not found')
    }

    function chkAndSend() {
      if (
        iframe &&
        'contentWindow' in iframe &&
        null !== iframe.contentWindow
      ) {
        // Null test for PhantomJS
        postMessageToIFrame()
      } else {
        iFrameNotFound()
      }
    }

    function warnOnNoResponse() {
      function warning() {
        if (settings[id] && !settings[id].loaded && !errorShown) {
          errorShown = true
          warn(
            id,
            'IFrame has not responded within ' +
              settings[id].warningTimeout / 1000 +
              ' seconds. Check iFrameResizer.contentWindow.js has been loaded in iFrame. This message can be ignored if everything is working, or you can set the warningTimeout option to a higher value or zero to suppress this warning.'
          )
        }
      }

      if (
        !!noResponseWarning &&
        settings[id] &&
        !!settings[id].warningTimeout
      ) {
        settings[id].msgTimeout = setTimeout(
          warning,
          settings[id].warningTimeout
        )
      }
    }

    var errorShown = false

    id = id || iframe.id

    if (settings[id]) {
      chkAndSend()
      warnOnNoResponse()
    }
  }

  function createOutgoingMsg(iframeId) {
    return (
      iframeId +
      ':' +
      settings[iframeId].bodyMarginV1 +
      ':' +
      settings[iframeId].sizeWidth +
      ':' +
      settings[iframeId].log +
      ':' +
      settings[iframeId].interval +
      ':' +
      settings[iframeId].enablePublicMethods +
      ':' +
      settings[iframeId].autoResize +
      ':' +
      settings[iframeId].bodyMargin +
      ':' +
      settings[iframeId].heightCalculationMethod +
      ':' +
      settings[iframeId].bodyBackground +
      ':' +
      settings[iframeId].bodyPadding +
      ':' +
      settings[iframeId].tolerance +
      ':' +
      settings[iframeId].inPageLinks +
      ':' +
      settings[iframeId].resizeFrom +
      ':' +
      settings[iframeId].widthCalculationMethod
    )
  }

  function setupIFrame(iframe, options) {
    function setLimits() {
      function addStyle(style) {
        if (
          Infinity !== settings[iframeId][style] &&
          0 !== settings[iframeId][style]
        ) {
          iframe.style[style] = settings[iframeId][style] + 'px'
          log(
            iframeId,
            'Set ' + style + ' = ' + settings[iframeId][style] + 'px'
          )
        }
      }

      function chkMinMax(dimension) {
        if (
          settings[iframeId]['min' + dimension] >
          settings[iframeId]['max' + dimension]
        ) {
          throw new Error(
            'Value for min' +
              dimension +
              ' can not be greater than max' +
              dimension
          )
        }
      }

      chkMinMax('Height')
      chkMinMax('Width')

      addStyle('maxHeight')
      addStyle('minHeight')
      addStyle('maxWidth')
      addStyle('minWidth')
    }

    function newId() {
      var id = (options && options.id) || defaults.id + count++
      if (null !== document.getElementById(id)) {
        id += count++
      }
      return id
    }

    function ensureHasId(iframeId) {
      if ('' === iframeId) {
        // eslint-disable-next-line no-multi-assign
        iframe.id = iframeId = newId()
        logEnabled = (options || {}).log
        log(
          iframeId,
          'Added missing iframe ID: ' + iframeId + ' (' + iframe.src + ')'
        )
      }

      return iframeId
    }

    function setScrolling() {
      log(
        iframeId,
        'IFrame scrolling ' +
          (settings[iframeId] && settings[iframeId].scrolling
            ? 'enabled'
            : 'disabled') +
          ' for ' +
          iframeId
      )
      iframe.style.overflow =
        false === (settings[iframeId] && settings[iframeId].scrolling)
          ? 'hidden'
          : 'auto'
      switch (settings[iframeId] && settings[iframeId].scrolling) {
        case 'omit':
          break

        case true:
          iframe.scrolling = 'yes'
          break

        case false:
          iframe.scrolling = 'no'
          break

        default:
          iframe.scrolling = settings[iframeId]
            ? settings[iframeId].scrolling
            : 'no'
      }
    }

    // The V1 iFrame script expects an int, where as in V2 expects a CSS
    // string value such as '1px 3em', so if we have an int for V2, set V1=V2
    // and then convert V2 to a string PX value.
    function setupBodyMarginValues() {
      if (
        'number' ===
          typeof (settings[iframeId] && settings[iframeId].bodyMargin) ||
        '0' === (settings[iframeId] && settings[iframeId].bodyMargin)
      ) {
        settings[iframeId].bodyMarginV1 = settings[iframeId].bodyMargin
        settings[iframeId].bodyMargin =
          '' + settings[iframeId].bodyMargin + 'px'
      }
    }

    function checkReset() {
      // Reduce scope of firstRun to function, because IE8's JS execution
      // context stack is borked and this value gets externally
      // changed midway through running this function!!!
      var firstRun = settings[iframeId] && settings[iframeId].firstRun,
        resetRequertMethod =
          settings[iframeId] &&
          settings[iframeId].heightCalculationMethod in resetRequiredMethods

      if (!firstRun && resetRequertMethod) {
        resetIFrame({ iframe: iframe, height: 0, width: 0, type: 'init' })
      }
    }

    function setupIFrameObject() {
      if (settings[iframeId]) {
        settings[iframeId].iframe.iFrameResizer = {
          close: closeIFrame.bind(null, settings[iframeId].iframe),

          removeListeners: removeIframeListeners.bind(
            null,
            settings[iframeId].iframe
          ),

          resize: trigger.bind(
            null,
            'Window resize',
            'resize',
            settings[iframeId].iframe
          ),

          moveToAnchor: function(anchor) {
            trigger(
              'Move to anchor',
              'moveToAnchor:' + anchor,
              settings[iframeId].iframe,
              iframeId
            )
          },

          sendMessage: function(message) {
            message = JSON.stringify(message)
            trigger(
              'Send Message',
              'message:' + message,
              settings[iframeId].iframe,
              iframeId
            )
          }
        }
      }
    }

    // We have to call trigger twice, as we can not be sure if all
    // iframes have completed loading when this code runs. The
    // event listener also catches the page changing in the iFrame.
    function init(msg) {
      function iFrameLoaded() {
        trigger('iFrame.onload', msg, iframe, undefined, true)
        checkReset()
      }

      function createDestroyObserver(MutationObserver) {
        if (!iframe.parentNode) {
          return
        }

        var destroyObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            var removedNodes = Array.prototype.slice.call(mutation.removedNodes) // Transform NodeList into an Array
            removedNodes.forEach(function(removedNode) {
              if (removedNode === iframe) {
                closeIFrame(iframe)
              }
            })
          })
        })
        destroyObserver.observe(iframe.parentNode, {
          childList: true
        })
      }

      var MutationObserver = getMutationObserver()
      if (MutationObserver) {
        createDestroyObserver(MutationObserver)
      }

      addEventListener(iframe, 'load', iFrameLoaded)
      trigger('init', msg, iframe, undefined, true)
    }

    function checkOptions(options) {
      if ('object' !== typeof options) {
        throw new TypeError('Options is not an object')
      }
    }

    function copyOptions(options) {
      // eslint-disable-next-line no-restricted-syntax
      for (var option in defaults) {
        if (Object.prototype.hasOwnProperty.call(defaults, option)) {
          settings[iframeId][option] = Object.prototype.hasOwnProperty.call(
            options,
            option
          )
            ? options[option]
            : defaults[option]
        }
      }
    }

    function getTargetOrigin(remoteHost) {
      return '' === remoteHost || 'file://' === remoteHost ? '*' : remoteHost
    }

    function depricate(key) {
      var splitName = key.split('Callback')

      if (splitName.length === 2) {
        var name =
          'on' + splitName[0].charAt(0).toUpperCase() + splitName[0].slice(1)
        this[name] = this[key]
        delete this[key]
        warn(
          iframeId,
          "Deprecated: '" +
            key +
            "' has been renamed '" +
            name +
            "'. The old method will be removed in the next major version."
        )
      }
    }

    function processOptions(options) {
      options = options || {}
      settings[iframeId] = {
        firstRun: true,
        iframe: iframe,
        remoteHost: iframe.src
          .split('/')
          .slice(0, 3)
          .join('/')
      }

      checkOptions(options)
      Object.keys(options).forEach(depricate, options)
      copyOptions(options)

      if (settings[iframeId]) {
        settings[iframeId].targetOrigin =
          true === settings[iframeId].checkOrigin
            ? getTargetOrigin(settings[iframeId].remoteHost)
            : '*'
      }
    }

    function beenHere() {
      return iframeId in settings && 'iFrameResizer' in iframe
    }

    var iframeId = ensureHasId(iframe.id)

    if (!beenHere()) {
      processOptions(options)
      setScrolling()
      setLimits()
      setupBodyMarginValues()
      init(createOutgoingMsg(iframeId))
      setupIFrameObject()
    } else {
      warn(iframeId, 'Ignored iFrame, already setup.')
    }
  }

  function debouce(fn, time) {
    if (null === timer) {
      timer = setTimeout(function() {
        timer = null
        fn()
      }, time)
    }
  }

  var frameTimer = {}
  function debounceFrameEvents(fn, time, frameId) {
    if (!frameTimer[frameId]) {
      frameTimer[frameId] = setTimeout(function() {
        frameTimer[frameId] = null
        fn()
      }, time)
    }
  }

  // Not testable in PhantomJS
  /* istanbul ignore next */

  function fixHiddenIFrames() {
    function checkIFrames() {
      function checkIFrame(settingId) {
        function chkDimension(dimension) {
          return (
            '0px' ===
            (settings[settingId] && settings[settingId].iframe.style[dimension])
          )
        }

        function isVisible(el) {
          return null !== el.offsetParent
        }

        if (
          settings[settingId] &&
          isVisible(settings[settingId].iframe) &&
          (chkDimension('height') || chkDimension('width'))
        ) {
          trigger(
            'Visibility change',
            'resize',
            settings[settingId].iframe,
            settingId
          )
        }
      }

      Object.keys(settings).forEach(function(key) {
        checkIFrame(settings[key])
      })
    }

    function mutationObserved(mutations) {
      log(
        'window',
        'Mutation observed: ' + mutations[0].target + ' ' + mutations[0].type
      )
      debouce(checkIFrames, 16)
    }

    function createMutationObserver() {
      var target = document.querySelector('body'),
        config = {
          attributes: true,
          attributeOldValue: false,
          characterData: true,
          characterDataOldValue: false,
          childList: true,
          subtree: true
        },
        observer = new MutationObserver(mutationObserved)

      observer.observe(target, config)
    }

    var MutationObserver = getMutationObserver()
    if (MutationObserver) {
      createMutationObserver()
    }
  }

  function resizeIFrames(event) {
    function resize() {
      sendTriggerMsg('Window ' + event, 'resize')
    }

    log('window', 'Trigger event: ' + event)
    debouce(resize, 16)
  }

  // Not testable in PhantomJS
  /* istanbul ignore next */
  function tabVisible() {
    function resize() {
      sendTriggerMsg('Tab Visable', 'resize')
    }

    if ('hidden' !== document.visibilityState) {
      log('document', 'Trigger event: Visiblity change')
      debouce(resize, 16)
    }
  }

  function sendTriggerMsg(eventName, event) {
    function isIFrameResizeEnabled(iframeId) {
      return (
        settings[iframeId] &&
        'parent' === settings[iframeId].resizeFrom &&
        settings[iframeId].autoResize &&
        !settings[iframeId].firstRun
      )
    }

    Object.keys(settings).forEach(function(iframeId) {
      if (isIFrameResizeEnabled(iframeId)) {
        trigger(eventName, event, document.getElementById(iframeId), iframeId)
      }
    })
  }

  function setupEventListeners() {
    addEventListener(window, 'message', iFrameListener)

    addEventListener(window, 'resize', function() {
      resizeIFrames('resize')
    })

    addEventListener(document, 'visibilitychange', tabVisible)

    addEventListener(document, '-webkit-visibilitychange', tabVisible)
  }

  function factory() {
    function init(options, element) {
      function chkType() {
        if (!element.tagName) {
          throw new TypeError('Object is not a valid DOM element')
        } else if ('IFRAME' !== element.tagName.toUpperCase()) {
          throw new TypeError(
            'Expected <IFRAME> tag, found <' + element.tagName + '>'
          )
        }
      }

      if (element) {
        chkType()
        setupIFrame(element, options)
        iFrames.push(element)
      }
    }

    function warnDeprecatedOptions(options) {
      if (options && options.enablePublicMethods) {
        warn(
          'enablePublicMethods option has been removed, public methods are now always available in the iFrame'
        )
      }
    }

    var iFrames

    setupRequestAnimationFrame()
    setupEventListeners()

    return function iFrameResizeF(options, target) {
      iFrames = [] // Only return iFrames past in on this call

      warnDeprecatedOptions(options)

      switch (typeof target) {
        case 'undefined':
        case 'string':
          Array.prototype.forEach.call(
            document.querySelectorAll(target || 'iframe'),
            init.bind(undefined, options)
          )
          break

        case 'object':
          init(options, target)
          break

        default:
          throw new TypeError('Unexpected data type (' + typeof target + ')')
      }

      return iFrames
    }
  }

  function createJQueryPublicMethod($) {
    if (!$.fn) {
      info('', 'Unable to bind to jQuery, it is not fully loaded.')
    } else if (!$.fn.iFrameResize) {
      $.fn.iFrameResize = function $iFrameResizeF(options) {
        function init(index, element) {
          setupIFrame(element, options)
        }

        return this.filter('iframe')
          .each(init)
          .end()
      }
    }
  }

  if (window.jQuery) {
    createJQueryPublicMethod(window.jQuery)
  }

  if (typeof define === 'function' && define.amd) {
    define([], factory)
  } else if (typeof module === 'object' && typeof module.exports === 'object') {
    // Node for browserfy
    module.exports = factory()
  }
  window.iFrameResize = window.iFrameResize || factory()
})()
$(document).ready(function() {
    // The script below is for loading iframe provided by Bookingbug. Do not modify.
    if ($("#bb-journey").length) {
        let iframeSrc = $("#bb-journey-src").val();
        iFrameResize({
            log : false,
            checkOrigin : false,
            enablePublicMethods : true,
            sizeWidth: true
        }, '#bb-journey');
        // pass url params to the iframe
        var params = window.location.search.replace("?", "&");
        var iframe = document.getElementById("bb-journey");
        iframe.src = iframeSrc + params;
    }
});
$(document).ready(function() {
    $(".availableExtras .gallery").slick({
        dots: true,
        infinite: true,
        arrows: true,
        swipe: true,
        variableWidth : true,
        speed: 300,
        slidesToShow: 4,
        slidesToScroll: 4,
        responsive: [
			{
			    breakpoint: 1025,
			    settings: {
			        slidesToShow: 3,
			        slidesToScroll: 3
			    }
			},
            {
                breakpoint: 940,
                settings: {
                    slidesToShow: 2,
                    slidesToScroll: 2
                }
            },
            {
           	 	breakpoint: 640,
           	 	settings: {
           	 		slidesToShow: 1,
           	 		slidesToScroll: 1
           	 	}
            }
        ]
    });
    var is_chrome = navigator.userAgent.indexOf('Chrome') > -1;
    var is_firefox = navigator.userAgent.indexOf('Firefox') > -1;
    var is_safari = navigator.userAgent.indexOf("Safari") > -1;
    if(is_firefox){
    	$(".downloadText span").hide();
    	$(".downloadText a").show();
    }
    if(is_chrome == true && is_safari == true) {
    	//chrome browser
    	$(".downloadText span").hide();
    	$(".downloadText a").show();
    }
    if(is_chrome == false && is_safari == true) {
    	//safari browser
    	$(".downloadText span").show();
    	$(".downloadText a").hide();
    }
    if (window.navigator.userAgent.indexOf("MSIE ") > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./)) {
    	//IE browser
    	$(".downloadText span").show();
    	$(".downloadText a").hide();
    }
    return false;
});

$('.downloadText span').on('click',function(){
	var id =$(this)[0].id;
	var hreflink =$('.'+id).val();
	var newWindow = window.open(hreflink, '_blank');
	newWindow.focus();
	return false;
});
/*
 *  This file contains addScript, LPStartABC function and some
 *  other code; that is provided from LivePerson services as is,
 *  to get the Live Person availability status which can
 *  be used to initiate the business chat with customers.
 *  Find out more about LivePerson on www.liveperson.com
 */

(function () {
  var abcUrl = "";
  var whatsappUrl = "";

  //Inject ABC Button from Apple
  function addScript() {
    var b = document.createElement("script");
    b.setAttribute("type", "text/javascript");
    b.setAttribute("charset", "iso-8859-1");
    b.setAttribute(
      "src",
      "https://static.cdn-apple.com/businesschat/start-chat-button/2/index.js"
    );
    document.getElementsByTagName("head").item(0).appendChild(b);
  }

  //Check for ABC engagement from LiveEngage. When exposed, bring in updated Apple assets to display
  function LPStartABC() {
    if (
      typeof lpTag !== "undefined" &&
      typeof lpTag.events !== "undefined" &&
      typeof lpTag.events.bind !== "undefined"
    ) {
      lpTag.events.bind("LP_OFFERS", "OFFER_IMPRESSION", function (a, b) {
        if (a.engagementName.indexOf("ABCInject") > -1) {
          addScript();
        }
      });
    } else {
      setTimeout("LPStartABC()", 1000);
    }
  }

  function getAbcMessaging(asyncChatCampaign) {
    LPStartABC();

    // Default to offer messaging experience
    var targetChannel = asyncChatCampaign;

    // Push the target channel value to sde which is used for campaign's target audience settings
    lpTag.sdes = lpTag.sdes || [];
    lpTag.sdes.push({
      type: "mrktInfo",
      info: {
        campaignId: targetChannel,
      },
    });
  }

  function getLivePerson(asyncChatSiteId) {
    window.lpTag = window.lpTag || {};

    if ("undefined" == typeof window.lpTag._tagCount) {
      window.lpTag = {
        wl: lpTag.wl || null,
        scp: lpTag.scp || null,
        site: asyncChatSiteId || "",
        section: lpTag.section || "",
        tagletSection: lpTag.tagletSection || null,
        autoStart: lpTag.autoStart !== !1,
        ovr: lpTag.ovr || {},
        _v: "1.10.0",
        _tagCount: 1,
        protocol: "https:",
        events: {
          bind: function (t, e, i) {
            lpTag.defer(function () {
              lpTag.events.bind(t, e, i);
            }, 0);
          },
          trigger: function (t, e, i) {
            lpTag.defer(function () {
              lpTag.events.trigger(t, e, i);
            }, 1);
          },
        },
        defer: function (t, e) {
          if (0 === e) {
            this._defB = this._defB || [];
            this._defB.push(t);
          } else if (1 === e) {
            this._defT = this._defT || [];
            this._defT.push(t);
          } else {
            this._defL = this._defL || [];
            this._defL.push(t);
          }
        },
        load: function (t, e, i) {
          var n = this;
          setTimeout(function () {
            n._load(t, e, i);
          }, 0);
        },
        _load: function (t, e, i) {
          var n = t;
          var domain =
            this.ovr && this.ovr.domain
              ? this.ovr.domain
              : "lptag.liveperson.net";
          if (!t) {
            n = this.protocol + "//" + domain + "/tag/tag.js?site=" + this.site;
          }

          var o = document.createElement("script");
          o.setAttribute("charset", e ? e : "UTF-8");
          i && o.setAttribute("id", i);
          o.setAttribute("src", n);
          document.getElementsByTagName("head").item(0).appendChild(o);
        },
        init: function () {
          this._timing = this._timing || {};
          this._timing.start = new Date().getTime();
          var t = this;
          if (window.attachEvent) {
            window.attachEvent("onload", function () {
              t._domReady("domReady");
            });
          } else {
            window.addEventListener(
              "DOMContentLoaded",
              function () {
                t._domReady("contReady");
              },
              !1
            );
            window.addEventListener(
              "load",
              function () {
                t._domReady("domReady");
              },
              !1
            );
          }

          "undefined" === typeof window._lptStop && this.load();
        },
        start: function () {
          this.autoStart = !0;
        },
        _domReady: function (t) {
          if (this.isDom) {
            return;
          }

          this.isDom = true;
          this.events.trigger("LPT", "DOM_READY", { t: t });
          this._timing[t] = new Date().getTime();
        },
        vars: lpTag.vars || [],
        dbs: lpTag.dbs || [],
        ctn: lpTag.ctn || [],
        sdes: lpTag.sdes || [],
        hooks: lpTag.hooks || [],
        identities: lpTag.identities || [],
        ev: lpTag.ev || [],
      };
      lpTag.init();
    } else {
      window.lpTag._tagCount += 1;
    }

    lpTag.section = [
      //SET A LIST OF YOUR SITE LOCATION GROUPS
      "test",
      "messaging",
    ];

    lpTag.sdes = lpTag.sdes || [];
  }

  function handleAbcButtonClick() {
    _satellite.track("snz.shop.asyncChat.interaction");

    window.open(abcUrl);
  }

  function handleWhatsappButtonClick() {
    _satellite.track("snz.shop.asyncChat.interaction");

    window.open(whatsappUrl, "_blank");
  }

  function onDOMReady(onReadyCallback) {
    if (document.readyState === "complete" ||
        (document.readyState !== "loading" && !document.documentElement.doScroll)
    ) {
      onReadyCallback();
    } else {
      document.addEventListener("DOMContentLoaded", onReadyCallback);
    }
  }

  document.addEventListener("snz-async-chat-initialise", function (event) {
    getLivePerson(event.detail.siteId);
    getAbcMessaging(event.detail.campaign);
    abcUrl = event.detail.abcUrl || "";
    whatsappUrl = event.detail.whatsappUrl || "";
  });

  var abcChatButtonScript = document.createElement("script");
  abcChatButtonScript.src =
    "https://static.cdn-apple.com/businesschat/start-chat-button/2/index.js";
  document.head.appendChild(abcChatButtonScript);

  onDOMReady(function () {

    var asyncChatDiv = document.createElement('div');
    asyncChatDiv.style.cssText = 'position: fixed; bottom: 10px; right: 10px; z-index: 1000';
    asyncChatDiv.innerHTML = '<div id="abc_example"></div><div id="whatsappButton"></div>';
    document.querySelector('body').appendChild(asyncChatDiv);

    var targetAbc = document.querySelector("#abc_example");
    var targetWhatsapp = document.querySelector("#whatsappButton");

    // create an observer instance
    var observer = new MutationObserver(function () {
      var whatsappDiv = document.getElementById("whatsappButton");
      var haswhatsappButton =
        whatsappDiv.querySelector("#whatsapp-chat-button") != null;

      var abcDiv = document.getElementById("abc_example");
      var hasAbcButton = abcDiv.querySelector("#abc-chat-button") != null;

      if (haswhatsappButton || hasAbcButton) {
        if (hasAbcButton) {
          var abcButton = document.getElementById("abc-chat-button");
          abcButton.onclick = handleAbcButtonClick;
        }

        if (haswhatsappButton) {
          var whatsappButton = document.getElementById("whatsapp-chat-button");
          whatsappButton.onclick = handleWhatsappButtonClick;
        }

        // later, you can stop observing
        observer.disconnect();
      }
    });

    // configuration of the observer:
    var config = { childList: true };

    // pass in the target node, as well as the observer options
    observer.observe(targetAbc, config);
    observer.observe(targetWhatsapp, config);
  });
})();

(function () {
  function debounce(func, wait) {
    var timeout;
    return function executedFunction() {
      var context = this;
      var args = arguments;

      var later = function () {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  function isInsideChatActive() {
    var insideChatFrame = document.querySelector("iframe#insideChatFrame");
    if (insideChatFrame) {
      var insideChatContent = insideChatFrame.contentDocument.getElementById("insideChatPaneContent");
      if (insideChatContent) {
        return insideChatContent.querySelectorAll(".bubble").length > 1;
      }
    }
    return false;
  }

  function getInsideChat() {
    return document.querySelector(".inside_chatTabImage");
  }

  function getInsideChatContainer() {
    return document.querySelector("#inside_holder");
  }

  function isIvyChatActive() {
    return document.querySelectorAll(".cx-message-group").length > 4;
  }

  function getIvyChat() {
    return document.querySelector(".cx-floater");
  }

  function getIvyChatWindow() {
    return document.querySelector(".cx-window-manager");
  }

  function getLiveChat() {
    var whatsAppButton = document.querySelector("#whatsappButton");
    if (whatsAppButton) {
      var isWhatsAppButtonVisible = whatsAppButton.querySelector("#whatsapp-chat-button");
      if (isWhatsAppButtonVisible) {
        return whatsAppButton.parentNode;
      }
    }

    var appleBusinessChatButton = document.querySelector("#abc_example");
    if (appleBusinessChatButton) {
      isAppleBussinessVisible = appleBusinessChatButton.querySelector("#abc-chat-button");
      if (isAppleBussinessVisible) {
        return appleBusinessChatButton.parentNode;
      }
    }

    return null;
  }

  var debouncedManageDisplayHierarchy = debounce(function () {
    manageDisplayHierarchy();
  }, 200);

  function manageDisplayHierarchy() {
    var isInsideChatWithActiveSessionVisible = isInsideChatActive();
    var isInsideChatVisible = !!getInsideChat();
    var isIvyChatWithActiveSessionVisible = isIvyChatActive();
    var isLiveChatVisible = !!getLiveChat();

    if (isInsideChatWithActiveSessionVisible) {
      hideIvyChat();
      hideLiveChat();
      return;
    }

    if (isIvyChatWithActiveSessionVisible) {
      hideInsideChat();
      hideLiveChat();
      return;
    }

    if (isLiveChatVisible) {
      hideInsideChat();
      hideIvyChat();
      return;
    }

    if (isInsideChatVisible) {
      hideLiveChat();
      hideIvyChat();
      return;
    }
  }

  function hideInsideChat() {
    hideElement(getInsideChatContainer());
  }

  function hideIvyChat() {
    hideElement(getIvyChat());
    hideElement(getIvyChatWindow());
  }

  function hideLiveChat() {
    hideElement(getLiveChat());
  }

  function hideElement(element) {
    if (element) {
      element.style.display = "none";
    }
  }

  function onDOMReady(onReadyCallback) {
    if (document.readyState === "complete" ||
        (document.readyState !== "loading" && !document.documentElement.doScroll)
    ) {
      onReadyCallback();
    } else {
      document.addEventListener("DOMContentLoaded", onReadyCallback);
    }
  }

  var manageChatConfig = {
    childList: true,
    subtree: true,
    attributes: false,
  };

  var manageChatObserver = new MutationObserver(
    debouncedManageDisplayHierarchy
  );

  var container = document.documentElement || document.body;

  onDOMReady(function () {
    // Running it once proactively in case the DOM already has the chat windows mounted
    manageDisplayHierarchy();
    manageChatObserver.observe(container, manageChatConfig);
  });
})();

$(document).ready((function(){
 $(".otherbtn").on('change',function(){
	$("#plan-name-blk").show();
});
 	
$(".carpo").on('change',function(){
	$("#plan-name-blk").hide();
	$("#planName").val("");
});

$(".likeNewNumber").on('click',function(){
	$(".activationBlock").show();
	$(".existaccBlock").hide();
	//TODO below should be handled with the proper jquery selector query
	$("#mobileNumber").val("");
	$("#accountName").val("");
	$("#accountNumber").val("");
	
});
 
$(".oldSim").on('click',function(){
	$(".activationBlock").hide();
    $(".existaccBlock").show();
  //TODO below should be handled with the proper jquery selector query
    $("#date").val("");
    
});
 
 $('input[name=needNewSim]').click(function() {
	if($(this).is(':checked')){
		$(this).val("Yes, i need a new SIM card"); 
	}else{
		$(this).val("Keep my SIM card");
	} 	 
 });
 $(".oldSim").click();
 $(".affiliates-success-blk").hide();
 $(".affiliates-error-blk").hide();
 
 $("form[name='affiliatesform'] #send").click(function(e) {
     var dataObj = {};
     
     var form = $("form[name='affiliatesform']");
     var fields = form.find('input');
     $( "#addressLine2" ).removeAttr( "required" );
     $( "#companyReference" ).removeAttr( "required" );
     $( "#billingReference" ).removeAttr( "required" );
     $( "#billaddresscompany" ).removeAttr( "required" );

     if (fields.valid()) {
	     fields.each(function () {
	    	 dataObj[this.name] = $(this).val();
	     });
	     dataObj["numberOption"] = $("input[name='numberOption']:checked").val();
	     dataObj["planSelection"] = $("input[name='planSelection']:checked").val();
	     submitAffilaitesForm(dataObj);
     }else{
    	$( "#addressLine2" ).attr( "required" ,"");
        $( "#companyReference" ).attr( "required","" );
        $( "#billingReference" ).attr( "required" ,"");
        $( "#billaddresscompany" ).attr( "required","" );
     }
    e.preventDefault();
 });
 
 function submitAffilaitesForm(dataObj) {
     $.ajax({
         dataType: 'html',
         type: "POST",
         url: "/bin/sparkdigital/form/affiliates",
         contentType: "application/x-www-form-urlencoded",
         timeout: 3600,
         data: dataObj,
         success: function(data, textStatus, jqXHR){
        	 $(".affiliates-form-blk").hide();
             $(".affiliates-success-blk").show();
         },
         error: function(err){
        	 $(".affiliates-form-blk").hide();
             $(".affiliates-error-blk").show();
         },
         complete: function(){
         }
     });
 }
 
 $("form[name='affiliatesform']").validate({
     rules: {
    	 firstName: 'required',
    	 lastName: 'required',
    	 emailAddress: {
             required : true,
             email: true
         },
         contactNumber: 'required',
         company: 'required',
         addressLine1: 'required',
         suburb: 'required',
         town: 'required',
         postcode: 'required',
         planSelection:'required',
         planName: 'required',
         numberOption: 'required',
         date: 'required',
         termsAndConditions: 'required'
     },
     messages: {
    	 firstName: 'Please enter your firstname',
    	 lastName: 'Please enter your lastname',
    	 emailAddress: {
             required : 'Please enter your email',
             email: 'Please enter valid email'
         },
         contactNumber: 'Please enter your contact number',
         company: 'Please enter your Company',
         addressLine1: 'Please enter your address',
         suburb: 'Please enter your Suburb',
         town: 'Please enter your City',
         postcode: 'Please enter your Post code',
         planSelection:'Please select a plan type',
         planName: 'Please enter your Plan',
         numberOption: 'Please select an option',
         date: 'Please enter the activation date',
         mobileNumber: 'Please enter the Mobile number',
         accountNumber: 'Please enter the Account number',
         accountName: 'Please enter the Account name',
         termsAndConditions: 'Please accept the terms and conditions'
     },
     errorPlacement: function (error, element) {
         error.appendTo($('#' + element.attr('id') + 'ErrorMessages'));
     },
     submitHandler: function (form) {
         return false;
     }
 });
})()
);
 
$(document).ready(function() {
    var tableData = [];
    var tableId = [];
    $(".tableDetails").each(function() {
        tableData.push($(this).val());
    });
    $(".uniqueTableId").each(function() {
        tableId.push($(this).val());
    });
    if (tableData !== undefined) {
        var noOfTables = $("div[class*='cmp-table-card']").length;
        for (var i = 0; i < noOfTables; i++) {
            var generateData = '#' + tableId[i];
            $(generateData).html(populateTable(JSON.parse(tableData[i])));
        }
    }
});

function populateTable(tableData) {
    var z;
    var myHTML = "";
    var tableLength;
    if (tableData.length > tableData[0].addRow.length) {
        tableLength = tableData.length;
    } else {
        tableLength = tableData[0].addRow.length;
    }
    myHTML += '<table cellspacing="0" cellpadding="0" border="0" width="100%" class=" table"><tr>';
    for (z in tableData) {
        myHTML += '<th><h5><span style="font-weight: 400;">' + tableData[z].columnValue + '</span></h5></th>';
    }
    myHTML += '</tr>';
    for (var i = 0; i < tableLength; i++) {
        myHTML += '<tr>';
        for (var j = 0; j < tableLength; j++) {
            if (tableData[j] !== undefined && tableData[j].addRow[i] !== undefined) {
                myHTML += '<td data-th=' + tableData[j].columnValue + '><span class="table-content">' + tableData[j].addRow[i].row + '</span></td>';
            }
        }
        myHTML += '</tr>';
    }
    myHTML += '</table>';
    return myHTML;
}
    $(document).ready(function() {
            var mobslides = $(".cmp-device-card-carousel .cmp-device-card__card").length;
            if (mobslides < 3) {
                $('.cmp-device-card-carousel').slick({
                    dots: true,
                    centerMode: false,
                    infinite: false,
                    slidesToShow: 2,
                    slidesToScroll: 1,
                    responsive: [{
                            breakpoint: 640,
                            settings: {
                                slidesToShow: 1,
                                slidesToScroll: 1
                            }
                        }
                    ]
                });
            }
            if (mobslides >= 3) {
                $('.cmp-device-card-carousel').slick({
                    dots: true,
                    centerMode: false,
                    infinite: false,
                    slidesToShow: 3,
                    slidesToScroll: 1,
                    responsive: [{
                            breakpoint: 1200,
                            settings: {
                                slidesToShow: 2,
                                slidesToScroll: 1
                            }
                        }, {
                            breakpoint: 940,
                            settings: {
                                slidesToShow: 2,
                                slidesToScroll: 1
                            }
                        },
                        {
                            breakpoint: 640,
                            settings: {
                                slidesToShow: 1,
                                slidesToScroll: 1
                            }
                        }
                    ]
                });
            }
        });
var smbChangePlan = {
    addEmailSelector : "#addEmailLink",
    changePlanEmailEntryTmpl : "#changePlanEmailEntry",
    nameEntryTmplSelector : "#nameEntry",
    removeLinkEntryTmpl : "#removeLinkTemplate",
    addMailBoxOptionValue : "Add mailbox",
    formSelector : "#smb-change-plan-form",
    buttonSelector : "#smbform-submit",
    emailSectionsCount : 1,
    form : ''
};
var smbChangePlanController = {
    init : function() {
        smbChangePlan.form = $(smbChangePlan.formSelector);
        smbChangePlanController.addLinkEvent();
        smbChangePlanController.onSelectRequestDropdownEvent();
        smbChangePlanController.bindValidation();
    },
    addSection : function() {
        var template = $($(smbChangePlan.changePlanEmailEntryTmpl).clone().html());
        var removeLink = $($(smbChangePlan.removeLinkEntryTmpl).clone().html());
        var last = $("[data-section='emailEntrySection']").last();
        var labelSection = template.find("[data-section='email-label']");
        smbChangePlan.emailSectionsCount++;
        smbChangePlanController.updateElementName(template, smbChangePlan.emailSectionsCount);
        labelSection.append(removeLink);
        last.after(template);
        smbChangePlanController.onSelectRequestDropdownEvent();
        smbChangePlanController.addFieldValidation(smbChangePlan.emailSectionsCount);
        smbChangePlanController.bindRemoveEmailSection(smbChangePlan.emailSectionsCount);
        smbChangePlanController.checkAndEnableAddSection();
    },
    requestOptionSelection : function(liElement) {
        var value = liElement.data("value");
        var requestSection = liElement.closest("[data-section='requestSection']");
        var emailEntrySection = liElement.closest("[data-section='emailEntrySection']");
        var nameSection = emailEntrySection.find("[data-section='nameSection']");
        if (smbChangePlan.addMailBoxOptionValue === value) {
            if (0 === nameSection.length) {
                var nameEntry = $($(smbChangePlan.nameEntryTmplSelector).clone().html());
                var index = emailEntrySection.data("index");
                smbChangePlanController.updateElementName(nameEntry, index);
                requestSection.after(nameEntry);
                smbChangePlanController.addNameFieldsValidation(index);
            }
        } else {
            nameSection.remove();
        }
    },
    updateElementName : function(content, index) {
        var elements = content.find("[data-nametmpl]");
        if(content.data("nametmpl")) {
            elements.push(content);
        }
        content.find("[data-section='position-number']").text(index);
        elements.each(function(elementIndex, ele) {
            var element = $(ele);
            var name = element.data("nametmpl").replace("{index}", index);
            if ("INPUT" === element.prop("tagName")) {
                element.attr("name", name);
                element.attr("id", name);
            } else if ("LABEL" === element.prop("tagName")) {
                element.attr("for", name);
            } else if ("DIV" === element.prop("tagName")) {
                element.attr("data-index", name);
            } else {
                element.attr("id", name);
            }
        });
    },
    bindRemoveEmailSection : function(index) {
        var emailSection = smbChangePlan.form.find("[data-section='emailEntrySection'][data-index='" + index + "']");
        emailSection.find("a[data-element='removeLink']").click(function(event) {
            event.preventDefault();
            $(this).closest("[data-section='emailEntrySection']").remove();
            smbChangePlanController.renameInputFields();
            smbChangePlanController.checkAndEnableAddSection();
        });
    },
    isAddEmailSectionAllowed : function() {
        return smbChangePlan.emailSectionsCount < 10;
    },
    checkAndEnableAddSection : function() {
        if (smbChangePlanController.isAddEmailSectionAllowed()) {
            $("#addEmailLink").removeClass("hide");
            $("#limitReachedSection").addClass("hide");
        } else {
            $("#addEmailLink").addClass("hide");
            $("#limitReachedSection").removeClass("hide");
        }
    },
    renameInputFields : function() {
        var emailEntries = smbChangePlan.form.find("[data-section='emailEntrySection']");
        emailEntries.each(function(idx, entry) {
            var index = idx + 1;
            if (idx > 0) {
                var element = $(entry);
                smbChangePlanController.updateElementName(element, index);
            }
            smbChangePlan.emailSectionsCount = index;
        });
    },
    submitForm : function() {
        $.ajax({
            dataType : 'json',
            type : smbChangePlan.form.attr('method'),
            url : smbChangePlan.form.attr('action'),
            data : smbChangePlan.form.serialize(),
            processData : false,
            contentType : false,
            timeout : 60000,
            success : function(data) {
                $("#smb-change-plan-container").html($("#successContent").html());
            },
            error : function(data) {
                $("#errorContainer").html($("#errorContent").html());
            }
        });
    },
    bindValidation : function() {
        smbChangePlan.form.validate({
            ignore : '',
            rules : {
                firstName : {
                    required : true
                },
                lastName : {
                    required : true
                },
                sparkAccNumber : {
                    required : true,
                    number : true,
                    minlength : 9,
                    maxlength : 9
                },
                contactEmailAddress : {
                    required : true,
                    email : true
                },
                confirmEmailAddress : {
                    required : true,
                    email : true,
                    equalTo : '#contactEmailAddress'
                },
                contactPhoneNumber : {
                    required : true,
                    number : true
                },
                tcCheck : {
                    required : true
                },
                firstName1 : {
                    required : {
                        depends : function(element) {
                            return $('#emailAddress1Request').val() === 'Add mailbox';
                        }
                    }
                },
                lastName1 : {
                    required : {
                        depends : function(element) {
                            return $('#emailAddress1Request').val() === 'Add mailbox';
                        }
                    }
                },
                emailAddress1 : {
                    required : true,
                    email : true
                },
                emailAddress1Plan : {
                    required : true
                },
                emailAddress1Request : {
                    required : true
                }
            },
            messages : {
                firstName : {
                    required : "Enter first name"
                },
                lastName : {
                    required : "Enter last name"
                },
                sparkAccNumber : {
                    required : "Enter spark account number",
                    number : "Please enter a valid account number",
                    minlength : "Please enter a valid account number - Spark account numbers are 9 digits long",
                    maxlength : "Please enter a valid account number - Spark account numbers are 9 digits long"
                },
                contactEmailAddress : {
                    required : "Enter contact email address",
                    email : "Please enter a valid email address"
                },
                confirmEmailAddress : {
                    required : "Enter confirm email address",
                    email : "Please enter a valid email address",
                    equalTo : "Confirm email address must match email address"
                },
                contactPhoneNumber : {
                    required : "Enter Phone Number",
                    number : "Please enter a valid phone number"
                },
                tcCheck : {
                    required : "Please agree with terms and conditions"
                },
                firstName1 : {
                    required : "Enter first name"
                },
                lastName1 : {
                    required : "Enter last name"
                },
                emailAddress1 : {
                    required : "Enter email address",
                    email : "Please enter a valid email address"
                },
                emailAddress1Plan : {
                    required : "Enter plan"
                },
                emailAddress1Request : {
                    required : "Select what you would like to do"
                }
            },
            errorPlacement : function(error, element) {
                error.appendTo($("#" + element.attr("id") + "Error"));
            },
            submitHandler : function(form) {
                $(smbChangePlan.buttonSelector).attr('disabled', 'disabled');
                smbChangePlanController.submitForm();
            }
        });
    },
    addLinkEvent : function() {
        $(smbChangePlan.addEmailSelector).click(function(event) {
            event.preventDefault();
            smbChangePlanController.addSection();
        });
    },
    onSelectRequestDropdownEvent : function() {
        $("[data-dropdown='emailAddressRequest'] .sp-form-dropdown-options li").click(function() {
            var liElement = $(this);
            smbChangePlanController.requestOptionSelection(liElement);
        });
    },
    addFieldValidation : function(index) {
        // Add validation rules
        $('#emailAddress' + index + 'Request').rules('add', {
            required : true,
            messages : {
                required : "Select what you would like to do"
            }
        });
        $('#emailAddress' + index).rules('add', {
            required : true,
            messages : {
                required : "Enter email address"
            }
        });
        $('#emailAddress' + index + 'Plan').rules('add', {
            required : true,
            messages : {
                required : "Enter plan"
            }
        });
    },
    addNameFieldsValidation : function(index) {
        // add the validation
        $('#firstName' + index).rules('add', {
            required : {
                depends : function(element) {
                    return $('#emailAddress' + index + 'Request').val() === 'Add mailbox';
                }
            },
            messages : {
                required : "Enter first name"
            }
        });
        $('#lastName' + index).rules('add', {
            required : {
                depends : function(element) {
                    return $('#emailAddress' + index + 'Request').val() === 'Add mailbox';
                }
            },
            messages : {
                required : "Enter last name"
            }
        });
    }
};

$(document).ready(function() {
    smbChangePlanController.init();
});

/**
 * jquery.mask.js
 * @version: v1.14.10
 * @author: Igor Escobar
 *
 * Created by Igor Escobar on 2012-03-10. Please report any bug at http://blog.igorescobar.com
 *
 * Copyright (c) 2012 Igor Escobar http://blog.igorescobar.com
 *
 * The MIT License (http://www.opensource.org/licenses/mit-license.php)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* jshint laxbreak: true */
/* jshint maxcomplexity:17 */
/* global define */

'use strict';

// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.
// https://github.com/umdjs/umd/blob/master/jqueryPluginCommonjs.js
(function (factory, jQuery, Zepto) {

    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery || Zepto);
    }

}(function ($) {

    var Mask = function (el, mask, options) {

        var p = {
            invalid: [],
            getCaret: function () {
                try {
                    var sel,
                        pos = 0,
                        ctrl = el.get(0),
                        dSel = document.selection,
                        cSelStart = ctrl.selectionStart;

                    // IE Support
                    if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {
                        sel = dSel.createRange();
                        sel.moveStart('character', -p.val().length);
                        pos = sel.text.length;
                    }
                    // Firefox support
                    else if (cSelStart || cSelStart === '0') {
                        pos = cSelStart;
                    }

                    return pos;
                } catch (e) {}
            },
            setCaret: function(pos) {
                try {
                    if (el.is(':focus')) {
                        var range, ctrl = el.get(0);

                        // Firefox, WebKit, etc..
                        if (ctrl.setSelectionRange) {
                            ctrl.setSelectionRange(pos, pos);
                        } else { // IE
                            range = ctrl.createTextRange();
                            range.collapse(true);
                            range.moveEnd('character', pos);
                            range.moveStart('character', pos);
                            range.select();
                        }
                    }
                } catch (e) {}
            },
            events: function() {
                el
                .on('keydown.mask', function(e) {
                    el.data('mask-keycode', e.keyCode || e.which);
                    el.data('mask-previus-value', el.val());
                })
                .on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour)
                .on('paste.mask drop.mask', function() {
                    setTimeout(function() {
                        el.keydown().keyup();
                    }, 100);
                })
                .on('change.mask', function(){
                    el.data('changed', true);
                })
                .on('blur.mask', function(){
                    if (oldValue !== p.val() && !el.data('changed')) {
                        el.trigger('change');
                    }
                    el.data('changed', false);
                })
                // it's very important that this callback remains in this position
                // otherwhise oldValue it's going to work buggy
                .on('blur.mask', function() {
                    oldValue = p.val();
                })
                // select all text on focus
                .on('focus.mask', function (e) {
                    if (options.selectOnFocus === true) {
                        $(e.target).select();
                    }
                })
                // clear the value if it not complete the mask
                .on('focusout.mask', function() {
                    if (options.clearIfNotMatch && !regexMask.test(p.val())) {
                       p.val('');
                   }
                });
            },
            getRegexMask: function() {
                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;

                for (var i = 0; i < mask.length; i++) {
                    translation = jMask.translation[mask.charAt(i)];

                    if (translation) {

                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');
                        optional = translation.optional;
                        recursive = translation.recursive;

                        if (recursive) {
                            maskChunks.push(mask.charAt(i));
                            oRecursive = {digit: mask.charAt(i), pattern: pattern};
                        } else {
                            maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));
                        }

                    } else {
                        maskChunks.push(mask.charAt(i).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    }
                }

                r = maskChunks.join('');

                if (oRecursive) {
                    r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')
                         .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);
                }

                return new RegExp(r);
            },
            destroyEvents: function() {
                el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));
            },
            val: function(v) {
                var isInput = el.is('input'),
                    method = isInput ? 'val' : 'text',
                    r;

                if (arguments.length > 0) {
                    if (el[method]() !== v) {
                        el[method](v);
                    }
                    r = el;
                } else {
                    r = el[method]();
                }

                return r;
            },
            calculateCaretPosition: function(caretPos, newVal) {
                var newValL = newVal.length,
                    oValue  = el.data('mask-previus-value') || '',
                    oValueL = oValue.length;

                // edge cases when erasing digits
                if (el.data('mask-keycode') === 8 && oValue !== newVal) {
                    caretPos = caretPos - (newVal.slice(0, caretPos).length - oValue.slice(0, caretPos).length);

                // edge cases when typing new digits
                } else if (oValue !== newVal) {
                    // if the cursor is at the end keep it there
                    if (caretPos >= oValueL) {
                        caretPos = newValL;
                    } else {
                        caretPos = caretPos + (newVal.slice(0, caretPos).length - oValue.slice(0, caretPos).length);
                    }
                }

                return caretPos;
            },
            behaviour: function(e) {
                e = e || window.event;
                p.invalid = [];

                var keyCode = el.data('mask-keycode');

                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {
                    var newVal   = p.getMasked(),
                        caretPos = p.getCaret();

                    setTimeout(function(caretPos, newVal) {
                      p.setCaret(p.calculateCaretPosition(caretPos, newVal));
                    }, 10, caretPos, newVal);

                    p.val(newVal);
                    p.setCaret(caretPos);
                    return p.callbacks(e);
                }
            },
            getMasked: function(skipMaskChars, val) {
                var buf = [],
                    value = val === undefined ? p.val() : val + '',
                    m = 0, maskLen = mask.length,
                    v = 0, valLen = value.length,
                    offset = 1, addMethod = 'push',
                    resetPos = -1,
                    lastMaskChar,
                    check;

                if (options.reverse) {
                    addMethod = 'unshift';
                    offset = -1;
                    lastMaskChar = 0;
                    m = maskLen - 1;
                    v = valLen - 1;
                    check = function () {
                        return m > -1 && v > -1;
                    };
                } else {
                    lastMaskChar = maskLen - 1;
                    check = function () {
                        return m < maskLen && v < valLen;
                    };
                }

                var lastUntranslatedMaskChar;
                while (check()) {
                    var maskDigit = mask.charAt(m),
                        valDigit = value.charAt(v),
                        translation = jMask.translation[maskDigit];

                    if (translation) {
                        if (valDigit.match(translation.pattern)) {
                            buf[addMethod](valDigit);
                             if (translation.recursive) {
                                if (resetPos === -1) {
                                    resetPos = m;
                                } else if (m === lastMaskChar) {
                                    m = resetPos - offset;
                                }

                                if (lastMaskChar === resetPos) {
                                    m -= offset;
                                }
                            }
                            m += offset;
                        } else if (valDigit === lastUntranslatedMaskChar) {
                            // matched the last untranslated (raw) mask character that we encountered
                            // likely an insert offset the mask character from the last entry; fall
                            // through and only increment v
                            lastUntranslatedMaskChar = undefined;
                        } else if (translation.optional) {
                            m += offset;
                            v -= offset;
                        } else if (translation.fallback) {
                            buf[addMethod](translation.fallback);
                            m += offset;
                            v -= offset;
                        } else {
                          p.invalid.push({p: v, v: valDigit, e: translation.pattern});
                        }
                        v += offset;
                    } else {
                        if (!skipMaskChars) {
                            buf[addMethod](maskDigit);
                        }

                        if (valDigit === maskDigit) {
                            v += offset;
                        } else {
                            lastUntranslatedMaskChar = maskDigit;
                        }

                        m += offset;
                    }
                }

                var lastMaskCharDigit = mask.charAt(lastMaskChar);
                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {
                    buf.push(lastMaskCharDigit);
                }

                return buf.join('');
            },
            callbacks: function (e) {
                var val = p.val(),
                    changed = val !== oldValue,
                    defaultArgs = [val, e, el, options],
                    callback = function(name, criteria, args) {
                        if (typeof options[name] === 'function' && criteria) {
                            options[name].apply(this, args);
                        }
                    };

                callback('onChange', changed === true, defaultArgs);
                callback('onKeyPress', changed === true, defaultArgs);
                callback('onComplete', val.length === mask.length, defaultArgs);
                callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);
            }
        };

        el = $(el);
        var jMask = this, oldValue = p.val(), regexMask;

        mask = typeof mask === 'function' ? mask(p.val(), undefined, el,  options) : mask;

        // public methods
        jMask.mask = mask;
        jMask.options = options;
        jMask.remove = function() {
            var caret = p.getCaret();
            p.destroyEvents();
            p.val(jMask.getCleanVal());
            p.setCaret(caret);
            return el;
        };

        // get value without mask
        jMask.getCleanVal = function() {
           return p.getMasked(true);
        };

        // get masked value without the value being in the input or element
        jMask.getMaskedVal = function(val) {
           return p.getMasked(false, val);
        };

       jMask.init = function(onlyMask) {
            onlyMask = onlyMask || false;
            options = options || {};

            jMask.clearIfNotMatch  = $.jMaskGlobals.clearIfNotMatch;
            jMask.byPassKeys       = $.jMaskGlobals.byPassKeys;
            jMask.translation      = $.extend({}, $.jMaskGlobals.translation, options.translation);

            jMask = $.extend(true, {}, jMask, options);

            regexMask = p.getRegexMask();

            if (onlyMask) {
                p.events();
                p.val(p.getMasked());
            } else {
                if (options.placeholder) {
                    el.attr('placeholder' , options.placeholder);
                }

                // this is necessary, otherwise if the user submit the form
                // and then press the "back" button, the autocomplete will erase
                // the data. Works fine on IE9+, FF, Opera, Safari.
                if (el.data('mask')) {
                  el.attr('autocomplete', 'off');
                }

                // detect if is necessary let the user type freely.
                // for is a lot faster than forEach.
                for (var i = 0, maxlength = true; i < mask.length; i++) {
                    var translation = jMask.translation[mask.charAt(i)];
                    if (translation && translation.recursive) {
                        maxlength = false;
                        break;
                    }
                }

                if (maxlength) {
                    el.attr('maxlength', mask.length);
                }

                p.destroyEvents();
                p.events();

                var caret = p.getCaret();
                p.val(p.getMasked());
                p.setCaret(caret);
            }
        };

        jMask.init(!el.is('input'));
    };

    $.maskWatchers = {};
    var HTMLAttributes = function () {
        var input = $(this),
            options = {},
            prefix = 'data-mask-',
            mask = input.attr('data-mask');

        if (input.attr(prefix + 'reverse')) {
            options.reverse = true;
        }

        if (input.attr(prefix + 'clearifnotmatch')) {
            options.clearIfNotMatch = true;
        }

        if (input.attr(prefix + 'selectonfocus') === 'true') {
           options.selectOnFocus = true;
        }

        if (notSameMaskObject(input, mask, options)) {
            return input.data('mask', new Mask(this, mask, options));
        }
    },
    notSameMaskObject = function(field, mask, options) {
        options = options || {};
        var maskObject = $(field).data('mask'),
            stringify = JSON.stringify,
            value = $(field).val() || $(field).text();
        try {
            if (typeof mask === 'function') {
                mask = mask(value);
            }
            return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;
        } catch (e) {}
    },
    eventSupported = function(eventName) {
        var el = document.createElement('div'), isSupported;

        eventName = 'on' + eventName;
        isSupported = (eventName in el);

        if ( !isSupported ) {
            el.setAttribute(eventName, 'return;');
            isSupported = typeof el[eventName] === 'function';
        }
        el = null;

        return isSupported;
    };

    $.fn.mask = function(mask, options) {
        options = options || {};
        var selector = this.selector,
            globals = $.jMaskGlobals,
            interval = globals.watchInterval,
            watchInputs = options.watchInputs || globals.watchInputs,
            maskFunction = function() {
                if (notSameMaskObject(this, mask, options)) {
                    return $(this).data('mask', new Mask(this, mask, options));
                }
            };

        $(this).each(maskFunction);

        if (selector && selector !== '' && watchInputs) {
            clearInterval($.maskWatchers[selector]);
            $.maskWatchers[selector] = setInterval(function(){
                $(document).find(selector).each(maskFunction);
            }, interval);
        }
        return this;
    };

    $.fn.masked = function(val) {
        return this.data('mask').getMaskedVal(val);
    };

    $.fn.unmask = function() {
        clearInterval($.maskWatchers[this.selector]);
        delete $.maskWatchers[this.selector];
        return this.each(function() {
            var dataMask = $(this).data('mask');
            if (dataMask) {
                dataMask.remove().removeData('mask');
            }
        });
    };

    $.fn.cleanVal = function() {
        return this.data('mask').getCleanVal();
    };

    $.applyDataMask = function(selector) {
        selector = selector || $.jMaskGlobals.maskElements;
        var $selector = (selector instanceof $) ? selector : $(selector);
        $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);
    };

    var globals = {
        maskElements: 'input,td,span,div',
        dataMaskAttr: '*[data-mask]',
        dataMask: true,
        watchInterval: 300,
        watchInputs: true,
        // old versions of chrome dont work great with input event
        useInput: !/Chrome\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),
        watchDataMask: false,
        byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
        translation: {
            '0': {pattern: /\d/},
            '9': {pattern: /\d/, optional: true},
            '#': {pattern: /\d/, recursive: true},
            'A': {pattern: /[a-zA-Z0-9]/},
            'S': {pattern: /[a-zA-Z]/}
        }
    };

    $.jMaskGlobals = $.jMaskGlobals || {};
    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);

    // looking for inputs with data-mask attribute
    if (globals.dataMask) {
        $.applyDataMask();
    }

    setInterval(function() {
        if ($.jMaskGlobals.watchDataMask) {
            $.applyDataMask();
        }
    }, globals.watchInterval);
}, window.jQuery, window.Zepto));

function showExtraAccountNumbers(){
    $('.extra-account-number').removeClass('hide');
    $('.add-more-account-numbers').addClass('hide');
    $('.remove-more-account-numbers').removeClass('hide');
}

function hideExtraAccountNumbers(){
    $('.extra-account-number').addClass('hide');
    $('.add-more-account-numbers').removeClass('hide');
    $(".extra-account-number").val("");
    $('.remove-more-account-numbers').addClass('hide');
}

function showHideDropdownValues() {
    $("#buttonPrefixNumber,#buttonBank,#buttonBankCode").on('click',function(){
        $(this).parent().toggleClass('open');
    });
}

function updateBankCode(bank){
    var codes = null;
    switch (bank) {
        case "ASB":
        case "NZ Home Loans":
        case "Bank Direct":
        case "Sovereign Home Loans":
            codes = ["12"];
            break;
        case "ANZ National":
            codes = ["01", "11", "06", "25"];
            break;
        case "BNZ":
            codes = ["02", "08"];
            break;
        case "Kiwibank":
            codes = ["38"];
            break;
        case "Westpac":
            codes = ["03", "13", "14", "16", "17", "18", "19", "20", "21", "22", "23", "24", "27"];
            break;
        case "TSB":
            codes = ["15"];
            break;
        default:
            codes = ["01","02", "03", "06","08", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "27", "38"];
    }
    var menu = $('#bank-code-select');
    menu.empty();
    $('#bank_code').val(codes[0]);
    $('#buttonBankCode').text(codes[0]);
    for(var i=0 ; i < codes.length ; ++i){
        menu.append('<li><a role="menuitem">'+codes[i]+'</a></li>');
    }
}
$(document).ready(function() {
    $(".add-more-account-numbers a").click(function(e) {
        e.preventDefault();
        showExtraAccountNumbers();
    });
    $(".remove-more-account-numbers a").click(function(e) {
        e.preventDefault();
        hideExtraAccountNumbers();
    });
    $("#bank").on( "change", function(e){
        e.preventDefault();
        updateBankCode($("#bank").val());
    });
    var partFields = [ "bank_code", "bank_branch_code", "bank_acct_num", "bank_acct_suffix" ];
    var maskInputField = $("#businessDirectDebitForm #accountNumber"), maskVal = "00-0000-0000000-000";
    if (typeof (maskInputField.val()) !== "undefined") {
        // Mask number based on first few input strokes
        maskInputField.on('change keyup paste', function() {
            for (var index = 0; index < partFields.length; index++) {
                $("#" + partFields[index]).val("");
            }
            maskInputField.mask(maskVal, {
                'translation' : {
                    X : {
                        pattern : /[0-9]/
                    }
                }
            });
            var nuberParts = maskInputField.val().split("-");
            for (var i = 0; i < nuberParts.length; i++) {
                $("#" + partFields[i]).val(nuberParts[i]);
            }
        });
    }
    if( $('#businessDirectDebitForm').length) {
        $("#businessDirectDebitForm").validate({
            ignore: [],
            rules: {
                companyname: {
                    required: true
                },
                sparkaccountnumber: {
                    required: true,
                    minlength: 9,
                    maxlength: 9
                },
                extra_account_number_1 : {
                    required: false
                },
                extra_account_number_2 : {
                    required: false
                },
                extra_account_number_3 : {
                    required: false
                },
                extra_account_number_4 : {
                    required: false
                },
                extra_account_number_5 : {
                    required: false
                },
                extra_account_number_6 : {
                    required: false
                },
                extra_account_number_7 : {
                    required: false
                },
                extra_account_number_8 : {
                    required: false
                },
                firstname: {
                    required: true
                },
                lastname: {
                    required: true
                },
                position: {
                    required: true
                },
                number: {
                    required: false
                },
                email: {
                    required: true,
                    email: true
                },
                confirmemail: {
                    equalTo: '#email'
                },
                bank: {
                    required: true
                },
                opt_bank_acct_name: {
                    required: true
                },
                accountNumber: {
                    required: false
                },
                bank_code: {
                    required: true
                },
                bank_branch_code: {
                    required: true
                },
                bank_acct_num: {
                    required: true
                },
                bank_acct_suffix: {
                    required: true
                },
                bank_authority: {
                    required: true
                },
                authority: {
                    required: true
                },
                iaccept:{
                    required: true
                }
            },
            messages: {
                companyname: {
                    required: $("#DIRECT_DEBIT_COMPANY_NAME_BLANK_ERROR").val()
                },
                sparkaccountnumber: {
                    required: $("#DIRECT_DEBIT_SPARK_ACCOUNT_NUMBER_BLANK_ERROR").val(),
                    minlength: $("#DIRECT_DEBIT_SPARK_ACCOUNT_NUMBER_INVALID").val(),
                    maxlength: $("#DIRECT_DEBIT_SPARK_ACCOUNT_NUMBER_INVALID").val()
                },
                firstname: {
                    required: $("#DIRECT_DEBIT_FIRST_NAME_ERROR").val()
                },
                lastname: {
                    required: $("#DIRECT_DEBIT_LAST_NAME_ERROR").val()
                },
                position: {
                    required: $("#DIRECT_DEBIT_POSITION_ERROR").val()
                },
                email: {
                    required:$("#DIRECT_DEBIT_CONTACT_EMAIL_ERROR").val(),
                    email: $("#DIRECT_DEBIT_CONTACT_EMAIL_INVALID_ERROR").val()
                },
                confirmemail: {
                    equalTo: $("#DIRECT_DEBIT_CONTACT_CONFIRM_EMAIL_NOT_MATCH").val()
                },
                bank: {
                    required: $("#DIRECT_DEBIT_BANK_NAME_BLANK").val()
                },
                opt_bank_acct_name: {
                    required: $("#DIRECT_DEBIT_BANK_ACCOUNT_NAME_BLANK").val()
                },
                bank_code: {
                    required: $("#DIRECT_DEBIT_BANK_ACCOUNT_CODE_BLANK").val()
                },
                bank_branch_code: {
                    required: $("#DIRECT_DEBIT_BANK_BRANCH_CODE_BLANK").val()
                },
                bank_acct_num: {
                    required: $("#DIRECT_DEBIT_BANK_ACCOUNT_NUMBER_BLANK").val()
                },
                bank_acct_suffix: {
                    required: $("#DIRECT_DEBIT_BANK_ACCOUNT_SUFFIX_BLANK").val()
                },
                bank_authority: {
                    required: $("#DIRECT_DEBIT_BANK_AUTHORITY_BLANK").val()
                },
                authority: {
                    required: $("#DIRECT_DEBIT_SPARK_AUTHORITY_BLANK").val()
                },
                iaccept: {
                    required: $("#DIRECT_DEBIT_ACCEPT_TERMS_CONDITIONS_LINK").val()
                }

            },
            errorPlacement: function (error, element) {
                error.appendTo($("#" + element.attr("id") + "Error"));
            },
            submitHandler: function (form) {
                form.submit();
            }
        });
    }
    showHideDropdownValues();
});
$(document).ready(function() {
    $("a[data-target='#emailThisPage']").on('click', function() {
        $(".cmp-onespark-modal .modal-details").show();
        $(".email-page-error").addClass('hide');
        if ($("#email-captcha-wrapper1 #recaptcha-html-element").length) {
            $("#email-captcha-wrapper1 #recaptcha-html-element").remove();
        }
        $("#emailThisForm small.error").hide();
        $("#emailThisPage input,#emailThisPage textarea").val('');
    });
    $("#try-again-send-email").on("click", function() {
        $(".cmp-onespark-modal .modal-details").show();
        $(".email-page-error").addClass('hide');
    });
    formValidation();
});
var addFBValidation = function() {
    var thankYouBlock = $(".thank-you-block").html();
    var emailForm = $("#emailThisForm");
    if (emailForm.length) {
        var ajaxUrl = emailForm.attr('action');
        var emailData = emailForm.serialize();
        var snackbar = snackbarService();
        snackbar.hideAllSnackbars();
        $.ajax({
            url : ajaxUrl,
            type : "POST",
            data : emailData,
            dataType : 'json',
            success : function(data) {
                if (data.isSuccessful) {
                    $(".email-page-error").addClass('hide');
                    var recipientIds = "";
                    for (var i = 1; i <= 3; i++) {
                        if (undefined !== $('#emailRecipient' + i).val() && $('#emailRecipient' + i).val().length) {
                            recipientIds += "<p>" + $('#emailRecipient' + i).val() + "</p>";
                        }
                    }
                    $('.email-recipients-id').html(recipientIds);
                    snackbar.showSuccessSnackbar(thankYouBlock);
                    $(".cmp-onespark-modal").modal('hide');
                } else if (!data.captchaValid) {
                    resetCaptcha();
                    $("<small id='email-captcha-error1' class='error help-block'>Input required - please try again</small>").insertAfter($("#email-captcha-wrapper1"));
                    $('#g-recaptcha-response-1').removeClass('valid');
                } else {
                    $(".email-page-error").removeClass('hide');
                    $(".cmp-onespark-modal .modal-details").hide();
                }
            },
            error : function() {
                $(".email-page-error").removeClass('hide');
                $(".cmp-onespark-modal .modal-details").hide();
            },
            complete : function() {
                $("#emailThisPage input,#emailThisPage textarea").val('');
            }
        });
    }
};
var addingCaptcha = function() {
    var delay = 1000;
    setTimeout(function() {
        $('#recaptcha-html-element-emailThisPage').appendTo($("#email-captcha-wrapper1"));
    }, delay);
};
var formValidation = function() {
    $("#emailThisForm").validate({
        ignore : ".skipValidate,.skipValidateSection", // ignore hidden fields,
                                                        // but not hidden inputs
        errorClass : "error",
        errorElement : "small",
        rules : {
            firstName : {
                required : true
            },
            lastName : {
                required : true
            },
            emailAddress : {
                required : true,
                email : true
            },
            emailRecipient1 : {
                required : true,
                email : true
            },
            emailRecipient2 : {
                email : true
            },
            emailRecipient3 : {
                email : true
            }
        },
        messages : {
            firstName : {
                required : "Please enter your first name"
            },
            lastName : {
                required : "Please enter your last name"
            },
            emailAddress : {
                required : "Please enter your email address",
                email : "Your email address is invalid, please re-enter"
            },
            emailRecipient1 : {
                required : "Please enter your email address",
                email : "Your email address is invalid, please re-enter"
            },
            emailRecipient2 : {
                email : "Your email address is invalid, please re-enter"
            },
            emailRecipient3 : {
                email : "Your email address is invalid, please re-enter"
            }
        },
        submitHandler : function(form, event) {
            addFBValidation();
        },
        errorPlacement : function(error, element) {
            var $errorElement = element.closest(".form-element-container").find(":first .help-block.error");
            error.addClass("help-block");
            if ($errorElement.length !== 0) {
                $errorElement.replaceWith(error);
            } else {
                element.parent().parent().append(error);
            }
        }
    });
    addingCaptcha();
};
$(document).ready(function() {
  if ($('#manage-redirect-component').length) {
    var AJAX_ERROR = "oops something went wrong with your request,please try again"
    $('#entered-name').val('');
    var addMessage = "Added successfully";
    var updateMessage = "Updated successfully";
    var deleteMessage = "Deleted successfully";

    var displayErrorMessages = function(err) {
        var errorMessage;
        try {
            errorMessage = JSON.parse(err.responseText).messages.messages[0].description;
        } catch (error) {
            errorMessage = AJAX_ERROR;
        }
        $('.ui-dialog-titlebar-close').click();
        $('#redirect-error').html(errorMessage);
        $('#redirect-error').removeClass('hidden');
    }

    var displayMessages = function(message) {
        $('#redirect-error').html(message);
        $('#redirect-error').removeClass('hidden');
    }

    var displayInfoMessages = function(message) {
        $('#redirect-info-message').html(message);
        $('#redirect-info-message').removeClass('hidden');
    }

    $('#ManageRedirectsContainer').jtable({
        title: 'Manage Redirects',
        paging: true,
        pageSize: 30,
        messages : {
            addNewRecord : 'Add'
        },
        sorting: true,
        actions: {
            listAction: function(postData, jtParams) {
                $('#redirect-error').addClass('hidden');
                $('#redirect-info-message').addClass('hidden');
                return $.Deferred(function($dfd) {
                    $.ajax({
                        url: '/bin/sparkredirects/redirecturldetails?jtStartIndex=' + jtParams.jtStartIndex + '&jtPageSize=' + jtParams.jtPageSize + '&jtSorting=' + jtParams.jtSorting,
                        type: 'GET',
                        dataType: 'json',
                        data: postData,
                        success: function(data) {
                            $dfd.resolve(data);
                        },
                        error: function(err) {
                            displayErrorMessages(err);
                        }
                    });
                });
            },

            deleteAction: function(postData) {
                $('#redirect-error').addClass('hidden');
                $('#redirect-info-message').addClass('hidden');
                return $.Deferred(function($dfd) {
                    $.ajax({
                        url: '/bin/sparkredirects/redirecturldetails?action=delete',
                        type: 'POST',
                        dataType: 'json',
                        data: postData,
                        success: function(data) {
                            $dfd.resolve(data);
                            displayMessages(deleteMessage);
                        },
                        error: function(err) {
                            displayErrorMessages(err);
                        }
                    });
                });
            },
            createAction: function(postData) {
                $('#redirect-error').addClass('hidden');
                $('#redirect-info-message').addClass('hidden');
                return $.Deferred(function($dfd) {
                    $.ajax({
                        url: '/bin/sparkredirects/redirecturldetails?action=create',
                        type: 'POST',
                        dataType: 'json',
                        data: postData,
                        success: function(data) {
                            $dfd.resolve(data);
                            if (data.Record.messages.messages != undefined) {
                                var infoMessage = data.Record.messages.messages[0].description;
                                displayInfoMessages(infoMessage);
                            }
                            displayMessages(addMessage);
                        },
                        error: function(err) {
                            displayErrorMessages(err);
                        }
                    });
                });
            },
            updateAction: function(postData) {
                $('#redirect-error').addClass('hidden');
                $('#redirect-info-message').addClass('hidden');
                return $.Deferred(function($dfd) {
                    $.ajax({
                        url: '/bin/sparkredirects/redirecturldetails?action=update',
                        type: 'POST',
                        dataType: 'json',
                        data: postData,
                        success: function(data) {
                            $dfd.resolve(data);
                            if (data.Record.messages.messages != undefined) {
                                var infoMessage = data.Record.messages.messages[0].description;
                                displayInfoMessages(infoMessage);
                            }
                            displayMessages(updateMessage);
                        },
                        error: function(err) {
                            displayErrorMessages(err);
                        }
                    });
                });
            }
        },
        fields: {
            entryId: {
                key: true,
                list: false
            },
            siteName: {
                title: 'Site',
                width: '10%',
                options: {
                    'Spark': 'Spark',
                    'Spark Digital': 'Spark Digital',
                    'Spark Lab': 'Spark Lab',
                    'Spark NZ': 'Spark NZ'
                }
            },
            sourceURL: {
                title: 'Source URL',
                width: '23%'
            },
            destinationURL: {
                title: 'Destination URL',
                width: '23%'
            },
            redirectType: {
                title: 'Redirect Type',
                width: '15%',
                options: {
                    '301': '301',
                    '302': '302'
                }
            }
        }
    });

    //Load redirects list from server
    $('#LoadRecordsButton').click(function(e) {
        e.preventDefault();
        $('#ManageRedirectsContainer').jtable('load', {
            siteName: $('#site-id').val(),
            redirectType: $('#type-id').val(),
            searchValue: $('#entered-name').val(),
        });
    });

    $('#ManageRedirectsContainer').jtable('load');
  }
});
$(document).ready(function() {
    if ($('#generate-redirects-component').length) {
        var AJAX_ERROR = "Oops something went wrong with the request,please try again";
        var successMessage = 'File successfully generated. Please view <a href ="/assets.html/content/dam/sparkredirects/filestopublish">here</a>';
        $('#generate-redirect-button').click(function(e) {
            e.preventDefault();
            var postData = {
                "siteName" : $('#site-value').val(),
                "redirectType" : $('#type-value').val(),
            };
            performAjax(postData);
        });

        var displayErrorMessages = function(err) {
            var errorMessage;
            try {
                errorMessage = JSON.parse(err.responseText).messages.messages[0].description;
            } catch (error) {
                errorMessage = AJAX_ERROR;
            }
            displayMessages(errorMessage);
        }

        var displayMessages = function(message) {
            $('#generate-redirect-error').html(message);
            $('#generate-redirect-error').removeClass('hidden');
        }

        var performAjax = function(postData) {
            $.ajax({
                dataType : 'json',
                type : 'POST',
                data : postData,
                url : '/bin/sparkredirects/generateredirects',
                success : function(data, textStatus, jqXHR) {
                    try {
                        var responseText = JSON.parse(jqXHR.responseText);
                        if (responseText.messages.messages != undefined) {
                            var errorMessage = responseText.messages.messages[0].description;
                            displayMessages(errorMessage);
                        } else {
                            displayMessages(successMessage);
                        }
                    } catch (err) {
                        displayMessages(AJAX_ERROR);
                    }
                },
                error : function(err) {
                    displayErrorMessages(err)
                }
            });
        }
    }
});
$(document).ready(function() {
    if ($('#bulk-upload-component').length) {
        $('#redirect-upload-info-message').addClass('hidden');
        $('#redirect-upload-error').addClass('hidden');
        var AJAX_ERROR = "Oops something went wrong with the request,please try again";
        var successMessage = "All records are processsed successfully";
        $('#upload-button-id').on('click', function(e) {
            e.preventDefault();
            $('#redirect-upload-info-message').addClass('hidden');
            $('#redirect-upload-error').addClass('hidden');
            var formData = new FormData();
            var fileInput = document.getElementById('file-id');
            var file = fileInput.files[0];
            formData.append('our-file', file);
            sendXHRequest(formData);
        });

        var displayErrorMessages = function(err) {
            var errorMessage;
            try {
                errorMessage = JSON.parse(err.responseText).messages.messages[0].description;
            } catch (error) {
                errorMessage = AJAX_ERROR;
            }
            $('#redirect-upload-error').html(errorMessage);
            $('#redirect-upload-error').removeClass('hidden');
        }

        var displayUploadInfoMessages = function(message) {
            $('#redirect-upload-info-message').html(message);
            $('#redirect-upload-info-message').removeClass('hidden');
        }

        var sendXHRequest = function(formData) {
            $.ajax({
                type : 'POST',
                url : '/bin/sparkredirects/bulkupload',
                processData : false,
                contentType : false,
                data : formData,
                success : function(data, textStatus, jqXHR) {
                    try {
                        var response = JSON.parse(jqXHR.responseText);
                        var message;
                        if (undefined !== response.messages.messages) {
                            var infoMessage = response.messages.messages[0].description;
                            displayUploadInfoMessages(infoMessage);
                        }
                        if (undefined !== response.successRecords && undefined !== response.errorRecords) {
                            message = response.successRecords + ' number of records are uploaded successfully, and ' + response.errorRecords
                            + ' number of records failed due to error. Please view <a href ="/assets.html/content/dam/sparkredirects/errorfiles">erroneous_redirects.csv </a>for more information.';
                        } else {
                            message = successMessage;
                        }
                        $('#LoadRecordsButton').click();
                        $('#redirect-upload-error').html(message);
                        $('#redirect-upload-error').removeClass('hidden');
                    } catch (error) {
                        var errorMessage = AJAX_ERROR;
                        $('#redirect-upload-error').html(errorMessage);
                        $('#redirect-upload-error').removeClass('hidden');
                    }
                },
                error : function(err) {
                    displayErrorMessages(err)
                }
            });
        }
    }
});
$(document).ready(function(){
    $("#shareurlButton").click(function() {
        $('#shareUrl-content').show();
        var snackbar = snackbarService();
        snackbar.hideAllSnackbars();
        if(	$('textarea#emails').val()===''){
            populateErrorDialog("Thats not quite right. Please enter a valid email address");
            return false;
        }
        var flag=isMulEmailValid($('textarea#emails').val());
        
        if(flag=== false){
            populateErrorDialog("Thats not quite right. Please enter a ; (semicolon) after each email address.");
            return false;
        }
        var recipientMail = $('textarea#emails').val();                   
        var helpPathShareurl =$('#helpPathShareurl').val();
        var emailHeaderImagePath = $('#emailHeaderImagePath').val();
        var emailLogoImagePath = $('#emailLogoImagePath').val();
        var emailTermsAndConditionsUrl = $('#emailTermsAndConditionsUrl').val();
        $('textarea#emails').val('');
        $.ajax({
            type: 'POST',    
            url:'/rest/v1/ibase/shareurl/submit',
            dataType:'text',
            data: {
                recipientMail: recipientMail,
                helpPathShareurl: helpPathShareurl,
                emailHeaderImagePath: emailHeaderImagePath,
                emailLogoImagePath: emailLogoImagePath,
                emailTermsAndConditionsUrl: emailTermsAndConditionsUrl
            },
            success: function(data){
                snackbar.showSuccessSnackbar(data);
                $('#cmp-shareUrl').hide();
            },
            error: function() {
                populateErrorDialog("Sorry, something went wrong. Please try sharing again.");
            } 
        });
    });

    function isEmailValid(email){
        var flag = false;
        if(typeof email !== 'undefined' && email=== "" ){
            flag = false;
        }else{
            var regex = /^([a-zA-Z0-9_\.\-\+])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
            flag = regex.test(email);
        }
        return flag;
    };

    /* Check whether the multiple email's is valid or not */
    function isMulEmailValid(emailStr){
        var emailArray = emailStr.split(/[;,]+/);
        var flag = true;
        for (var i = 0; i < emailArray.length; i++) {
            var check=emailArray[i].trim();           
            flag  =isEmailValid(check);
        }
        return flag;
    }

    function populateErrorDialog(errorMsg) {
        $('#share-url-error').removeClass('hide');
        $('#errorMsg').text(errorMsg); 
        $('#shareUrl-content').hide();
    }

    /**Click on try again button.**/
    $("#try-again-email").click(function() { 
        showShareUrlModal();
    });

    /**Click on close button.**/
    $("#close-modal-shareurl").click(function() { 
        showShareUrlModal();
    });

	/**To hide error content and show shareUrl content in popup modal.**/
    function showShareUrlModal() {
        $('textarea#emails').val("");
        $('#share-url-error').addClass('hide');
        $('#shareUrl-content').show();
    } 
});






